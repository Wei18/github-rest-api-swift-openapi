// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// List organization repositories
    ///
    /// Lists repositories for the specified organization.
    ///
    /// > [!NOTE]
    /// > In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/repos`.
    /// - Remark: Generated from `#/paths//orgs/{org}/repos/get(repos/list-for-org)`.
    func reposListForOrg(_ input: Operations.ReposListForOrg.Input) async throws -> Operations.ReposListForOrg.Output
    /// Create an organization repository
    ///
    /// Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /orgs/{org}/repos`.
    /// - Remark: Generated from `#/paths//orgs/{org}/repos/post(repos/create-in-org)`.
    func reposCreateInOrg(_ input: Operations.ReposCreateInOrg.Input) async throws -> Operations.ReposCreateInOrg.Output
    /// Get all organization repository rulesets
    ///
    /// Get all the repository rulesets for an organization.
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/get(repos/get-org-rulesets)`.
    func reposGetOrgRulesets(_ input: Operations.ReposGetOrgRulesets.Input) async throws -> Operations.ReposGetOrgRulesets.Output
    /// Create an organization repository ruleset
    ///
    /// Create a repository ruleset for an organization.
    ///
    /// - Remark: HTTP `POST /orgs/{org}/rulesets`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/post(repos/create-org-ruleset)`.
    func reposCreateOrgRuleset(_ input: Operations.ReposCreateOrgRuleset.Input) async throws -> Operations.ReposCreateOrgRuleset.Output
    /// List organization rule suites
    ///
    /// Lists suites of rule evaluations at the organization level.
    /// For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/rule-suites`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/get(repos/get-org-rule-suites)`.
    func reposGetOrgRuleSuites(_ input: Operations.ReposGetOrgRuleSuites.Input) async throws -> Operations.ReposGetOrgRuleSuites.Output
    /// Get an organization rule suite
    ///
    /// Gets information about a suite of rule evaluations from within an organization.
    /// For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-org-rule-suite)`.
    func reposGetOrgRuleSuite(_ input: Operations.ReposGetOrgRuleSuite.Input) async throws -> Operations.ReposGetOrgRuleSuite.Output
    /// Get an organization repository ruleset
    ///
    /// Get a repository ruleset for an organization.
    ///
    /// **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
    /// making the API request has write access to the ruleset.
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/get(repos/get-org-ruleset)`.
    func reposGetOrgRuleset(_ input: Operations.ReposGetOrgRuleset.Input) async throws -> Operations.ReposGetOrgRuleset.Output
    /// Update an organization repository ruleset
    ///
    /// Update a ruleset for an organization.
    ///
    /// - Remark: HTTP `PUT /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/put(repos/update-org-ruleset)`.
    func reposUpdateOrgRuleset(_ input: Operations.ReposUpdateOrgRuleset.Input) async throws -> Operations.ReposUpdateOrgRuleset.Output
    /// Delete an organization repository ruleset
    ///
    /// Delete a ruleset for an organization.
    ///
    /// - Remark: HTTP `DELETE /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/delete(repos/delete-org-ruleset)`.
    func reposDeleteOrgRuleset(_ input: Operations.ReposDeleteOrgRuleset.Input) async throws -> Operations.ReposDeleteOrgRuleset.Output
    /// Get a repository
    ///
    /// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    ///
    /// > [!NOTE]
    /// > In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)`.
    func reposGet(_ input: Operations.ReposGet.Input) async throws -> Operations.ReposGet.Output
    /// Update a repository
    ///
    /// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics) endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)`.
    func reposUpdate(_ input: Operations.ReposUpdate.Input) async throws -> Operations.ReposUpdate.Output
    /// Delete a repository
    ///
    /// Deleting a repository requires admin access.
    ///
    /// If an organization owner has configured the organization to prevent members from deleting organization-owned
    /// repositories, you will get a `403 Forbidden` response.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `delete_repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)`.
    func reposDelete(_ input: Operations.ReposDelete.Input) async throws -> Operations.ReposDelete.Output
    /// List repository activities
    ///
    /// Lists a detailed history of changes to a repository, such as pushes, merges, force pushes, and branch changes, and associates these changes with commits and users.
    ///
    /// For more information about viewing repository activity,
    /// see "[Viewing activity and data for your repository](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/activity`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/activity/get(repos/list-activities)`.
    func reposListActivities(_ input: Operations.ReposListActivities.Input) async throws -> Operations.ReposListActivities.Output
    /// Create an attestation
    ///
    /// Store an artifact attestation and associate it with a repository.
    ///
    /// The authenticated user must have write permission to the repository and, if using a fine-grained access token, the `attestations:write` permission is required.
    ///
    /// Artifact attestations are meant to be created using the [attest action](https://github.com/actions/attest). For more information, see our guide on [using artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/attestations`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/post(repos/create-attestation)`.
    func reposCreateAttestation(_ input: Operations.ReposCreateAttestation.Input) async throws -> Operations.ReposCreateAttestation.Output
    /// List attestations
    ///
    /// List a collection of artifact attestations with a given subject digest that are associated with a repository.
    ///
    /// The authenticated user making the request must have read access to the repository. In addition, when using a fine-grained access token the `attestations:read` permission is required.
    ///
    /// **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/attestations/{subject_digest}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/{subject_digest}/get(repos/list-attestations)`.
    func reposListAttestations(_ input: Operations.ReposListAttestations.Input) async throws -> Operations.ReposListAttestations.Output
    /// Get all autolinks of a repository
    ///
    /// Gets all autolinks that are configured for a repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/autolinks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/get(repos/list-autolinks)`.
    func reposListAutolinks(_ input: Operations.ReposListAutolinks.Input) async throws -> Operations.ReposListAutolinks.Output
    /// Create an autolink reference for a repository
    ///
    /// Users with admin access to the repository can create an autolink.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/autolinks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/post(repos/create-autolink)`.
    func reposCreateAutolink(_ input: Operations.ReposCreateAutolink.Input) async throws -> Operations.ReposCreateAutolink.Output
    /// Get an autolink reference of a repository
    ///
    /// This returns a single autolink reference by ID that was configured for the given repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/autolinks/{autolink_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/get(repos/get-autolink)`.
    func reposGetAutolink(_ input: Operations.ReposGetAutolink.Input) async throws -> Operations.ReposGetAutolink.Output
    /// Delete an autolink reference from a repository
    ///
    /// This deletes a single autolink reference by ID that was configured for the given repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/delete(repos/delete-autolink)`.
    func reposDeleteAutolink(_ input: Operations.ReposDeleteAutolink.Input) async throws -> Operations.ReposDeleteAutolink.Output
    /// Check if Dependabot security updates are enabled for a repository
    ///
    /// Shows whether Dependabot security updates are enabled, disabled or paused for a repository. The authenticated user must have admin read access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/get(repos/check-automated-security-fixes)`.
    func reposCheckAutomatedSecurityFixes(_ input: Operations.ReposCheckAutomatedSecurityFixes.Input) async throws -> Operations.ReposCheckAutomatedSecurityFixes.Output
    /// Enable Dependabot security updates
    ///
    /// Enables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/put(repos/enable-automated-security-fixes)`.
    func reposEnableAutomatedSecurityFixes(_ input: Operations.ReposEnableAutomatedSecurityFixes.Input) async throws -> Operations.ReposEnableAutomatedSecurityFixes.Output
    /// Disable Dependabot security updates
    ///
    /// Disables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/delete(repos/disable-automated-security-fixes)`.
    func reposDisableAutomatedSecurityFixes(_ input: Operations.ReposDisableAutomatedSecurityFixes.Input) async throws -> Operations.ReposDisableAutomatedSecurityFixes.Output
    /// List branches
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/get(repos/list-branches)`.
    func reposListBranches(_ input: Operations.ReposListBranches.Input) async throws -> Operations.ReposListBranches.Output
    /// Get a branch
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/get(repos/get-branch)`.
    func reposGetBranch(_ input: Operations.ReposGetBranch.Input) async throws -> Operations.ReposGetBranch.Output
    /// Get branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/get(repos/get-branch-protection)`.
    func reposGetBranchProtection(_ input: Operations.ReposGetBranchProtection.Input) async throws -> Operations.ReposGetBranchProtection.Output
    /// Update branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Protecting a branch requires admin or owner permissions to the repository.
    ///
    /// > [!NOTE]
    /// > Passing new arrays of `users` and `teams` replaces their previous values.
    ///
    /// > [!NOTE]
    /// > The list of users, apps, and teams in total is limited to 100 items.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/put(repos/update-branch-protection)`.
    func reposUpdateBranchProtection(_ input: Operations.ReposUpdateBranchProtection.Input) async throws -> Operations.ReposUpdateBranchProtection.Output
    /// Delete branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/delete(repos/delete-branch-protection)`.
    func reposDeleteBranchProtection(_ input: Operations.ReposDeleteBranchProtection.Input) async throws -> Operations.ReposDeleteBranchProtection.Output
    /// Get admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/get(repos/get-admin-branch-protection)`.
    func reposGetAdminBranchProtection(_ input: Operations.ReposGetAdminBranchProtection.Input) async throws -> Operations.ReposGetAdminBranchProtection.Output
    /// Set admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/post(repos/set-admin-branch-protection)`.
    func reposSetAdminBranchProtection(_ input: Operations.ReposSetAdminBranchProtection.Input) async throws -> Operations.ReposSetAdminBranchProtection.Output
    /// Delete admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/delete(repos/delete-admin-branch-protection)`.
    func reposDeleteAdminBranchProtection(_ input: Operations.ReposDeleteAdminBranchProtection.Input) async throws -> Operations.ReposDeleteAdminBranchProtection.Output
    /// Get pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/get(repos/get-pull-request-review-protection)`.
    func reposGetPullRequestReviewProtection(_ input: Operations.ReposGetPullRequestReviewProtection.Input) async throws -> Operations.ReposGetPullRequestReviewProtection.Output
    /// Update pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// > [!NOTE]
    /// > Passing new arrays of `users` and `teams` replaces their previous values.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/patch(repos/update-pull-request-review-protection)`.
    func reposUpdatePullRequestReviewProtection(_ input: Operations.ReposUpdatePullRequestReviewProtection.Input) async throws -> Operations.ReposUpdatePullRequestReviewProtection.Output
    /// Delete pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/delete(repos/delete-pull-request-review-protection)`.
    func reposDeletePullRequestReviewProtection(_ input: Operations.ReposDeletePullRequestReviewProtection.Input) async throws -> Operations.ReposDeletePullRequestReviewProtection.Output
    /// Get commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.
    ///
    /// > [!NOTE]
    /// > You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/get(repos/get-commit-signature-protection)`.
    func reposGetCommitSignatureProtection(_ input: Operations.ReposGetCommitSignatureProtection.Input) async throws -> Operations.ReposGetCommitSignatureProtection.Output
    /// Create commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/post(repos/create-commit-signature-protection)`.
    func reposCreateCommitSignatureProtection(_ input: Operations.ReposCreateCommitSignatureProtection.Input) async throws -> Operations.ReposCreateCommitSignatureProtection.Output
    /// Delete commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/delete(repos/delete-commit-signature-protection)`.
    func reposDeleteCommitSignatureProtection(_ input: Operations.ReposDeleteCommitSignatureProtection.Input) async throws -> Operations.ReposDeleteCommitSignatureProtection.Output
    /// Get status checks protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/get(repos/get-status-checks-protection)`.
    func reposGetStatusChecksProtection(_ input: Operations.ReposGetStatusChecksProtection.Input) async throws -> Operations.ReposGetStatusChecksProtection.Output
    /// Update status check protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/patch(repos/update-status-check-protection)`.
    func reposUpdateStatusCheckProtection(_ input: Operations.ReposUpdateStatusCheckProtection.Input) async throws -> Operations.ReposUpdateStatusCheckProtection.Output
    /// Remove status check protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/delete(repos/remove-status-check-protection)`.
    func reposRemoveStatusCheckProtection(_ input: Operations.ReposRemoveStatusCheckProtection.Input) async throws -> Operations.ReposRemoveStatusCheckProtection.Output
    /// Get all status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/get(repos/get-all-status-check-contexts)`.
    func reposGetAllStatusCheckContexts(_ input: Operations.ReposGetAllStatusCheckContexts.Input) async throws -> Operations.ReposGetAllStatusCheckContexts.Output
    /// Add status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/post(repos/add-status-check-contexts)`.
    func reposAddStatusCheckContexts(_ input: Operations.ReposAddStatusCheckContexts.Input) async throws -> Operations.ReposAddStatusCheckContexts.Output
    /// Set status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/put(repos/set-status-check-contexts)`.
    func reposSetStatusCheckContexts(_ input: Operations.ReposSetStatusCheckContexts.Input) async throws -> Operations.ReposSetStatusCheckContexts.Output
    /// Remove status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/delete(repos/remove-status-check-contexts)`.
    func reposRemoveStatusCheckContexts(_ input: Operations.ReposRemoveStatusCheckContexts.Input) async throws -> Operations.ReposRemoveStatusCheckContexts.Output
    /// Get access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists who has access to this protected branch.
    ///
    /// > [!NOTE]
    /// > Users, apps, and teams `restrictions` are only available for organization-owned repositories.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/get(repos/get-access-restrictions)`.
    func reposGetAccessRestrictions(_ input: Operations.ReposGetAccessRestrictions.Input) async throws -> Operations.ReposGetAccessRestrictions.Output
    /// Delete access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Disables the ability to restrict who can push to this branch.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/delete(repos/delete-access-restrictions)`.
    func reposDeleteAccessRestrictions(_ input: Operations.ReposDeleteAccessRestrictions.Input) async throws -> Operations.ReposDeleteAccessRestrictions.Output
    /// Get apps with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the GitHub Apps that have push access to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/get(repos/get-apps-with-access-to-protected-branch)`.
    func reposGetAppsWithAccessToProtectedBranch(_ input: Operations.ReposGetAppsWithAccessToProtectedBranch.Input) async throws -> Operations.ReposGetAppsWithAccessToProtectedBranch.Output
    /// Add app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified apps push access for this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/post(repos/add-app-access-restrictions)`.
    func reposAddAppAccessRestrictions(_ input: Operations.ReposAddAppAccessRestrictions.Input) async throws -> Operations.ReposAddAppAccessRestrictions.Output
    /// Set app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/put(repos/set-app-access-restrictions)`.
    func reposSetAppAccessRestrictions(_ input: Operations.ReposSetAppAccessRestrictions.Input) async throws -> Operations.ReposSetAppAccessRestrictions.Output
    /// Remove app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of an app to push to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/delete(repos/remove-app-access-restrictions)`.
    func reposRemoveAppAccessRestrictions(_ input: Operations.ReposRemoveAppAccessRestrictions.Input) async throws -> Operations.ReposRemoveAppAccessRestrictions.Output
    /// Get teams with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the teams who have push access to this branch. The list includes child teams.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/get(repos/get-teams-with-access-to-protected-branch)`.
    func reposGetTeamsWithAccessToProtectedBranch(_ input: Operations.ReposGetTeamsWithAccessToProtectedBranch.Input) async throws -> Operations.ReposGetTeamsWithAccessToProtectedBranch.Output
    /// Add team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified teams push access for this branch. You can also give push access to child teams.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/post(repos/add-team-access-restrictions)`.
    func reposAddTeamAccessRestrictions(_ input: Operations.ReposAddTeamAccessRestrictions.Input) async throws -> Operations.ReposAddTeamAccessRestrictions.Output
    /// Set team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/put(repos/set-team-access-restrictions)`.
    func reposSetTeamAccessRestrictions(_ input: Operations.ReposSetTeamAccessRestrictions.Input) async throws -> Operations.ReposSetTeamAccessRestrictions.Output
    /// Remove team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of a team to push to this branch. You can also remove push access for child teams.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/delete(repos/remove-team-access-restrictions)`.
    func reposRemoveTeamAccessRestrictions(_ input: Operations.ReposRemoveTeamAccessRestrictions.Input) async throws -> Operations.ReposRemoveTeamAccessRestrictions.Output
    /// Get users with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the people who have push access to this branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/get(repos/get-users-with-access-to-protected-branch)`.
    func reposGetUsersWithAccessToProtectedBranch(_ input: Operations.ReposGetUsersWithAccessToProtectedBranch.Input) async throws -> Operations.ReposGetUsersWithAccessToProtectedBranch.Output
    /// Add user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified people push access for this branch.
    ///
    /// | Type    | Description                                                                                                                   |
    /// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/post(repos/add-user-access-restrictions)`.
    func reposAddUserAccessRestrictions(_ input: Operations.ReposAddUserAccessRestrictions.Input) async throws -> Operations.ReposAddUserAccessRestrictions.Output
    /// Set user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.
    ///
    /// | Type    | Description                                                                                                                   |
    /// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/put(repos/set-user-access-restrictions)`.
    func reposSetUserAccessRestrictions(_ input: Operations.ReposSetUserAccessRestrictions.Input) async throws -> Operations.ReposSetUserAccessRestrictions.Output
    /// Remove user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of a user to push to this branch.
    ///
    /// | Type    | Description                                                                                                                                   |
    /// | ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/delete(repos/remove-user-access-restrictions)`.
    func reposRemoveUserAccessRestrictions(_ input: Operations.ReposRemoveUserAccessRestrictions.Input) async throws -> Operations.ReposRemoveUserAccessRestrictions.Output
    /// Rename a branch
    ///
    /// Renames a branch in a repository.
    ///
    /// > [!NOTE]
    /// > Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".
    ///
    /// The authenticated user must have push access to the branch. If the branch is the default branch, the authenticated user must also have admin or owner permissions.
    ///
    /// In order to rename the default branch, fine-grained access tokens also need the `administration:write` repository permission.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/rename`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/rename/post(repos/rename-branch)`.
    func reposRenameBranch(_ input: Operations.ReposRenameBranch.Input) async throws -> Operations.ReposRenameBranch.Output
    /// List CODEOWNERS errors
    ///
    /// List any syntax errors that are detected in the CODEOWNERS
    /// file.
    ///
    /// For more information about the correct CODEOWNERS syntax,
    /// see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/codeowners/errors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/codeowners/errors/get(repos/codeowners-errors)`.
    func reposCodeownersErrors(_ input: Operations.ReposCodeownersErrors.Input) async throws -> Operations.ReposCodeownersErrors.Output
    /// List repository collaborators
    ///
    /// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    /// The `permissions` hash returned in the response contains the base role permissions of the collaborator. The `role_name` is the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
    /// There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
    ///
    /// Team members will include the members of child teams.
    ///
    /// The authenticated user must have write, maintain, or admin privileges on the repository to use this endpoint. For organization-owned repositories, the authenticated user needs to be a member of the organization.
    /// OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/get(repos/list-collaborators)`.
    func reposListCollaborators(_ input: Operations.ReposListCollaborators.Input) async throws -> Operations.ReposListCollaborators.Output
    /// Check if a user is a repository collaborator
    ///
    /// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    ///
    /// Team members will include the members of child teams.
    ///
    /// The authenticated user must have push access to the repository to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/get(repos/check-collaborator)`.
    func reposCheckCollaborator(_ input: Operations.ReposCheckCollaborator.Input) async throws -> Operations.ReposCheckCollaborator.Output
    /// Add a repository collaborator
    ///
    /// Add a user to a repository with a specified level of access. If the repository is owned by an organization, this API does not add the user to the organization - a user that has repository access without being an organization member is called an "outside collaborator" (if they are not an Enterprise Managed User) or a "repository collaborator" if they are an Enterprise Managed User. These users are exempt from some organization policies - see "[Adding outside collaborators to repositories](https://docs.github.com/organizations/managing-user-access-to-your-organizations-repositories/managing-outside-collaborators/adding-outside-collaborators-to-repositories-in-your-organization)" to learn more about these collaborator types.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    ///
    /// Adding an outside collaborator may be restricted by enterprise and organization administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)" and "[Setting permissions for adding outside collaborators](https://docs.github.com/organizations/managing-organization-settings/setting-permissions-for-adding-outside-collaborators)" for organization settings.
    ///
    /// For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the role being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:
    ///
    /// ```
    /// Cannot assign {member} permission of {role name}
    /// ```
    ///
    /// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [API](https://docs.github.com/rest/collaborators/invitations).
    ///
    /// For Enterprise Managed Users, this endpoint does not send invitations - these users are automatically added to organizations and repositories. Enterprise Managed Users can only be added to organizations and repositories within their enterprise.
    ///
    /// **Updating an existing collaborator's permission level**
    ///
    /// The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.
    ///
    /// **Rate limits**
    ///
    /// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)`.
    func reposAddCollaborator(_ input: Operations.ReposAddCollaborator.Input) async throws -> Operations.ReposAddCollaborator.Output
    /// Remove a repository collaborator
    ///
    /// Removes a collaborator from a repository.
    ///
    /// To use this endpoint, the authenticated user must either be an administrator of the repository or target themselves for removal.
    ///
    /// This endpoint also:
    /// - Cancels any outstanding invitations sent by the collaborator
    /// - Unassigns the user from any issues
    /// - Removes access to organization projects if the user is not an organization member and is not a collaborator on any other organization repositories.
    /// - Unstars the repository
    /// - Updates access permissions to packages
    ///
    /// Removing a user as a collaborator has the following effects on forks:
    ///  - If the user had access to a fork through their membership to this repository, the user will also be removed from the fork.
    ///  - If the user had their own fork of the repository, the fork will be deleted.
    ///  - If the user still has read access to the repository, open pull requests by this user from a fork will be denied.
    ///
    /// > [!NOTE]
    /// > A user can still have access to the repository through organization permissions like base repository permissions.
    ///
    /// Although the API responds immediately, the additional permission updates might take some extra time to complete in the background.
    ///
    /// For more information on fork permissions, see "[About permissions and visibility of forks](https://docs.github.com/pull-requests/collaborating-with-pull-requests/working-with-forks/about-permissions-and-visibility-of-forks)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/delete(repos/remove-collaborator)`.
    func reposRemoveCollaborator(_ input: Operations.ReposRemoveCollaborator.Input) async throws -> Operations.ReposRemoveCollaborator.Output
    /// Get repository permissions for a user
    ///
    /// Checks the repository permission and role of a collaborator.
    ///
    /// The `permission` attribute provides the legacy base roles of `admin`, `write`, `read`, and `none`, where the
    /// `maintain` role is mapped to `write` and the `triage` role is mapped to `read`.
    /// The `role_name` attribute provides the name of the assigned role, including custom roles. The
    /// `permission` can also be used to determine which base level of access the collaborator has to the repository.
    ///
    /// The calculated permissions are the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
    /// There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators/{username}/permission`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/permission/get(repos/get-collaborator-permission-level)`.
    func reposGetCollaboratorPermissionLevel(_ input: Operations.ReposGetCollaboratorPermissionLevel.Input) async throws -> Operations.ReposGetCollaboratorPermissionLevel.Output
    /// List commit comments for a repository
    ///
    /// Lists the commit comments for a specified repository. Comments are ordered by ascending ID.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/get(repos/list-commit-comments-for-repo)`.
    func reposListCommitCommentsForRepo(_ input: Operations.ReposListCommitCommentsForRepo.Input) async throws -> Operations.ReposListCommitCommentsForRepo.Output
    /// Get a commit comment
    ///
    /// Gets a specified commit comment.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/get(repos/get-commit-comment)`.
    func reposGetCommitComment(_ input: Operations.ReposGetCommitComment.Input) async throws -> Operations.ReposGetCommitComment.Output
    /// Update a commit comment
    ///
    /// Updates the contents of a specified commit comment.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/patch(repos/update-commit-comment)`.
    func reposUpdateCommitComment(_ input: Operations.ReposUpdateCommitComment.Input) async throws -> Operations.ReposUpdateCommitComment.Output
    /// Delete a commit comment
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/delete(repos/delete-commit-comment)`.
    func reposDeleteCommitComment(_ input: Operations.ReposDeleteCommitComment.Input) async throws -> Operations.ReposDeleteCommitComment.Output
    /// List commits
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)`.
    func reposListCommits(_ input: Operations.ReposListCommits.Input) async throws -> Operations.ReposListCommits.Output
    /// List branches for HEAD commit
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/get(repos/list-branches-for-head-commit)`.
    func reposListBranchesForHeadCommit(_ input: Operations.ReposListBranchesForHeadCommit.Input) async throws -> Operations.ReposListBranchesForHeadCommit.Output
    /// List commit comments
    ///
    /// Lists the comments for a specified commit.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/get(repos/list-comments-for-commit)`.
    func reposListCommentsForCommit(_ input: Operations.ReposListCommentsForCommit.Input) async throws -> Operations.ReposListCommentsForCommit.Output
    /// Create a commit comment
    ///
    /// Create a comment for a commit using its `:commit_sha`.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/commits/{commit_sha}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/post(repos/create-commit-comment)`.
    func reposCreateCommitComment(_ input: Operations.ReposCreateCommitComment.Input) async throws -> Operations.ReposCreateCommitComment.Output
    /// List pull requests associated with a commit
    ///
    /// Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, it will return merged and open pull requests associated with the commit.
    ///
    /// To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter to the branch name.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/pulls/get(repos/list-pull-requests-associated-with-commit)`.
    func reposListPullRequestsAssociatedWithCommit(_ input: Operations.ReposListPullRequestsAssociatedWithCommit.Input) async throws -> Operations.ReposListPullRequestsAssociatedWithCommit.Output
    /// Get a commit
    ///
    /// Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.
    ///
    /// > [!NOTE]
    /// > If there are more than 300 files in the commit diff and the default JSON media type is requested, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)." Pagination query parameters are not supported for these media types.
    ///
    /// - **`application/vnd.github.diff`**: Returns the diff of the commit. Larger diffs may time out and return a 5xx status code.
    /// - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property. Larger diffs may time out and return a 5xx status code.
    /// - **`application/vnd.github.sha`**: Returns the commit's SHA-1 hash. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)`.
    func reposGetCommit(_ input: Operations.ReposGetCommit.Input) async throws -> Operations.ReposGetCommit.Output
    /// Get the combined status for a specific reference
    ///
    /// Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
    ///
    ///
    /// Additionally, a combined `state` is returned. The `state` is one of:
    ///
    /// *   **failure** if any of the contexts report as `error` or `failure`
    /// *   **pending** if there are no statuses or a context is `pending`
    /// *   **success** if the latest status for all contexts is `success`
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}/status`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/status/get(repos/get-combined-status-for-ref)`.
    func reposGetCombinedStatusForRef(_ input: Operations.ReposGetCombinedStatusForRef.Input) async throws -> Operations.ReposGetCombinedStatusForRef.Output
    /// List commit statuses for a reference
    ///
    /// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.
    ///
    /// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/statuses/get(repos/list-commit-statuses-for-ref)`.
    func reposListCommitStatusesForRef(_ input: Operations.ReposListCommitStatusesForRef.Input) async throws -> Operations.ReposListCommitStatusesForRef.Output
    /// Get community profile metrics
    ///
    /// Returns all community profile metrics for a repository. The repository cannot be a fork.
    ///
    /// The returned metrics include an overall health score, the repository description, the presence of documentation, the
    /// detected code of conduct, the detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
    /// README, and CONTRIBUTING files.
    ///
    /// The `health_percentage` score is defined as a percentage of how many of
    /// the recommended community health files are present. For more information, see
    /// "[About community profiles for public repositories](https://docs.github.com/communities/setting-up-your-project-for-healthy-contributions/about-community-profiles-for-public-repositories)."
    ///
    /// `content_reports_enabled` is only returned for organization-owned repositories.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/community/profile`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/community/profile/get(repos/get-community-profile-metrics)`.
    func reposGetCommunityProfileMetrics(_ input: Operations.ReposGetCommunityProfileMetrics.Input) async throws -> Operations.ReposGetCommunityProfileMetrics.Output
    /// Compare two commits
    ///
    /// Compares two commits against one another. You can compare refs (branches or tags) and commit SHAs in the same repository, or you can compare refs and commit SHAs that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
    ///
    /// This endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.diff`**: Returns the diff of the commit.
    /// - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property.
    ///
    /// The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
    ///
    /// When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.
    ///
    /// **Working with large comparisons**
    ///
    /// To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:
    ///
    /// - The list of changed files is only shown on the first page of results, and it includes up to 300 changed files for the entire comparison.
    /// - The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.
    ///
    /// For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/compare/{basehead}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)`.
    func reposCompareCommits(_ input: Operations.ReposCompareCommits.Input) async throws -> Operations.ReposCompareCommits.Output
    /// Get repository content
    ///
    /// Gets the contents of a file or directory in a repository. Specify the file path or directory with the `path` parameter. If you omit the `path` parameter, you will receive the contents of the repository's root directory.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents for files and symlinks.
    /// - **`application/vnd.github.html+json`**: Returns the file contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    /// - **`application/vnd.github.object+json`**: Returns the contents in a consistent object format regardless of the content type. For example, instead of an array of objects for a directory, the response will be an object with an `entries` attribute containing the array of objects.
    ///
    /// If the content is a directory, the response will be an array of objects, one object for each item in the directory. When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value _should_ be "submodule". This behavior exists [for backwards compatibility purposes](https://git.io/v1YCW). In the next major version of the API, the type will be returned as "submodule".
    ///
    /// If the content is a symlink and the symlink's target is a normal file in the repository, then the API responds with the content of the file. Otherwise, the API responds with an object describing the symlink itself.
    ///
    /// If the content is a submodule, the `submodule_git_url` field identifies the location of the submodule repository, and the `sha` identifies a specific commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out the submodule at that specific commit. If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the github.com URLs (`html_url` and `_links["html"]`) will have null values.
    ///
    /// **Notes**:
    ///
    /// - To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/git/trees#get-a-tree).
    /// - This API has an upper limit of 1,000 files for a directory. If you need to retrieve
    /// more files, use the [Git Trees API](https://docs.github.com/rest/git/trees#get-a-tree).
    /// - Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
    /// - If the requested file's size is:
    ///   - 1 MB or smaller: All features of this endpoint are supported.
    ///   - Between 1-100 MB: Only the `raw` or `object` custom media types are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty
    /// string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
    ///   - Greater than 100 MB: This endpoint is not supported.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)`.
    func reposGetContent(_ input: Operations.ReposGetContent.Input) async throws -> Operations.ReposGetContent.Output
    /// Create or update file contents
    ///
    /// Creates a new file or replaces an existing file in a repository.
    ///
    /// > [!NOTE]
    /// > If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/repos/contents/#delete-a-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The `workflow` scope is also required in order to modify files in the `.github/workflows` directory.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)`.
    func reposCreateOrUpdateFileContents(_ input: Operations.ReposCreateOrUpdateFileContents.Input) async throws -> Operations.ReposCreateOrUpdateFileContents.Output
    /// Delete a file
    ///
    /// Deletes a file in a repository.
    ///
    /// You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
    ///
    /// The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
    ///
    /// You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
    ///
    /// > [!NOTE]
    /// > If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/repos/contents/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)`.
    func reposDeleteFile(_ input: Operations.ReposDeleteFile.Input) async throws -> Operations.ReposDeleteFile.Output
    /// List repository contributors
    ///
    /// Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
    ///
    /// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)`.
    func reposListContributors(_ input: Operations.ReposListContributors.Input) async throws -> Operations.ReposListContributors.Output
    /// List deployments
    ///
    /// Simple filtering of deployments is available via query parameters:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/get(repos/list-deployments)`.
    func reposListDeployments(_ input: Operations.ReposListDeployments.Input) async throws -> Operations.ReposListDeployments.Output
    /// Create a deployment
    ///
    /// Deployments offer a few configurable parameters with certain defaults.
    ///
    /// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
    /// before we merge a pull request.
    ///
    /// The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
    /// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
    /// makes it easier to track which environments have requested deployments. The default environment is `production`.
    ///
    /// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
    /// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
    /// the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
    /// return a failure response.
    ///
    /// By default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a `success`
    /// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
    /// specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
    /// not require any contexts or create any commit statuses, the deployment will always succeed.
    ///
    /// The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
    /// field that will be passed on when a deployment event is dispatched.
    ///
    /// The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
    /// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
    /// application with debugging enabled.
    ///
    /// Merged branch response:
    ///
    /// You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
    /// a deployment. This auto-merge happens when:
    /// *   Auto-merge option is enabled in the repository
    /// *   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
    /// *   There are no merge conflicts
    ///
    /// If there are no new commits in the base branch, a new request to create a deployment should give a successful
    /// response.
    ///
    /// Merge conflict response:
    ///
    /// This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
    /// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.
    ///
    /// Failed commit status checks:
    ///
    /// This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
    /// status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)`.
    func reposCreateDeployment(_ input: Operations.ReposCreateDeployment.Input) async throws -> Operations.ReposCreateDeployment.Output
    /// Get a deployment
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/get(repos/get-deployment)`.
    func reposGetDeployment(_ input: Operations.ReposGetDeployment.Input) async throws -> Operations.ReposGetDeployment.Output
    /// Delete a deployment
    ///
    /// If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment.
    ///
    /// To set a deployment as inactive, you must:
    ///
    /// *   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
    /// *   Mark the active deployment as inactive by adding any non-successful deployment status.
    ///
    /// For more information, see "[Create a deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/deployments/statuses#create-a-deployment-status)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/deployments/{deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/delete(repos/delete-deployment)`.
    func reposDeleteDeployment(_ input: Operations.ReposDeleteDeployment.Input) async throws -> Operations.ReposDeleteDeployment.Output
    /// List deployment statuses
    ///
    /// Users with pull access can view deployment statuses for a deployment:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/get(repos/list-deployment-statuses)`.
    func reposListDeploymentStatuses(_ input: Operations.ReposListDeploymentStatuses.Input) async throws -> Operations.ReposListDeploymentStatuses.Output
    /// Create a deployment status
    ///
    /// Users with `push` access can create deployment statuses for a given deployment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/post(repos/create-deployment-status)`.
    func reposCreateDeploymentStatus(_ input: Operations.ReposCreateDeploymentStatus.Input) async throws -> Operations.ReposCreateDeploymentStatus.Output
    /// Get a deployment status
    ///
    /// Users with pull access can view a deployment status for a deployment:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/get(repos/get-deployment-status)`.
    func reposGetDeploymentStatus(_ input: Operations.ReposGetDeploymentStatus.Input) async throws -> Operations.ReposGetDeploymentStatus.Output
    /// Create a repository dispatch event
    ///
    /// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
    ///
    /// The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
    ///
    /// This input example shows how you can use the `client_payload` as a test to debug your workflow.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/dispatches`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/dispatches/post(repos/create-dispatch-event)`.
    func reposCreateDispatchEvent(_ input: Operations.ReposCreateDispatchEvent.Input) async throws -> Operations.ReposCreateDispatchEvent.Output
    /// List environments
    ///
    /// Lists the environments for a repository.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/get(repos/get-all-environments)`.
    func reposGetAllEnvironments(_ input: Operations.ReposGetAllEnvironments.Input) async throws -> Operations.ReposGetAllEnvironments.Output
    /// Get an environment
    ///
    /// > [!NOTE]
    /// > To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/get(repos/get-environment)`.
    func reposGetEnvironment(_ input: Operations.ReposGetEnvironment.Input) async throws -> Operations.ReposGetEnvironment.Output
    /// Create or update an environment
    ///
    /// Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."
    ///
    /// > [!NOTE]
    /// > To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."
    ///
    /// > [!NOTE]
    /// > To create or update secrets for an environment, see "[GitHub Actions secrets](/rest/actions/secrets)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/put(repos/create-or-update-environment)`.
    func reposCreateOrUpdateEnvironment(_ input: Operations.ReposCreateOrUpdateEnvironment.Input) async throws -> Operations.ReposCreateOrUpdateEnvironment.Output
    /// Delete an environment
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/delete(repos/delete-an-environment)`.
    func reposDeleteAnEnvironment(_ input: Operations.ReposDeleteAnEnvironment.Input) async throws -> Operations.ReposDeleteAnEnvironment.Output
    /// List deployment branch policies
    ///
    /// Lists the deployment branch policies for an environment.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/get(repos/list-deployment-branch-policies)`.
    func reposListDeploymentBranchPolicies(_ input: Operations.ReposListDeploymentBranchPolicies.Input) async throws -> Operations.ReposListDeploymentBranchPolicies.Output
    /// Create a deployment branch policy
    ///
    /// Creates a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)`.
    func reposCreateDeploymentBranchPolicy(_ input: Operations.ReposCreateDeploymentBranchPolicy.Input) async throws -> Operations.ReposCreateDeploymentBranchPolicy.Output
    /// Get a deployment branch policy
    ///
    /// Gets a deployment branch or tag policy for an environment.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/get(repos/get-deployment-branch-policy)`.
    func reposGetDeploymentBranchPolicy(_ input: Operations.ReposGetDeploymentBranchPolicy.Input) async throws -> Operations.ReposGetDeploymentBranchPolicy.Output
    /// Update a deployment branch policy
    ///
    /// Updates a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/put(repos/update-deployment-branch-policy)`.
    func reposUpdateDeploymentBranchPolicy(_ input: Operations.ReposUpdateDeploymentBranchPolicy.Input) async throws -> Operations.ReposUpdateDeploymentBranchPolicy.Output
    /// Delete a deployment branch policy
    ///
    /// Deletes a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/delete(repos/delete-deployment-branch-policy)`.
    func reposDeleteDeploymentBranchPolicy(_ input: Operations.ReposDeleteDeploymentBranchPolicy.Input) async throws -> Operations.ReposDeleteDeploymentBranchPolicy.Output
    /// Get all deployment protection rules for an environment
    ///
    /// Gets all custom deployment protection rules that are enabled for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/get(repos/get-all-deployment-protection-rules)`.
    func reposGetAllDeploymentProtectionRules(_ input: Operations.ReposGetAllDeploymentProtectionRules.Input) async throws -> Operations.ReposGetAllDeploymentProtectionRules.Output
    /// Create a custom deployment protection rule on an environment
    ///
    /// Enable a custom deployment protection rule for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app), as well as the [guide to creating custom deployment protection rules](https://docs.github.com/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/post(repos/create-deployment-protection-rule)`.
    func reposCreateDeploymentProtectionRule(_ input: Operations.ReposCreateDeploymentProtectionRule.Input) async throws -> Operations.ReposCreateDeploymentProtectionRule.Output
    /// List custom deployment rule integrations available for an environment
    ///
    /// Gets all custom deployment protection rule integrations that are available for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see "[GET an app](https://docs.github.com/rest/apps/apps#get-an-app)".
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/get(repos/list-custom-deployment-rule-integrations)`.
    func reposListCustomDeploymentRuleIntegrations(_ input: Operations.ReposListCustomDeploymentRuleIntegrations.Input) async throws -> Operations.ReposListCustomDeploymentRuleIntegrations.Output
    /// Get a custom deployment protection rule
    ///
    /// Gets an enabled custom deployment protection rule for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see [`GET /apps/{app_slug}`](https://docs.github.com/rest/apps/apps#get-an-app).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/get(repos/get-custom-deployment-protection-rule)`.
    func reposGetCustomDeploymentProtectionRule(_ input: Operations.ReposGetCustomDeploymentProtectionRule.Input) async throws -> Operations.ReposGetCustomDeploymentProtectionRule.Output
    /// Disable a custom protection rule for an environment
    ///
    /// Disables a custom deployment protection rule for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/delete(repos/disable-deployment-protection-rule)`.
    func reposDisableDeploymentProtectionRule(_ input: Operations.ReposDisableDeploymentProtectionRule.Input) async throws -> Operations.ReposDisableDeploymentProtectionRule.Output
    /// List forks
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/forks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/get(repos/list-forks)`.
    func reposListForks(_ input: Operations.ReposListForks.Input) async throws -> Operations.ReposListForks.Output
    /// Create a fork
    ///
    /// Create a fork for the authenticated user.
    ///
    /// > [!NOTE]
    /// > Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
    ///
    /// > [!NOTE]
    /// > Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/forks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)`.
    func reposCreateFork(_ input: Operations.ReposCreateFork.Input) async throws -> Operations.ReposCreateFork.Output
    /// List repository webhooks
    ///
    /// Lists webhooks for a repository. `last response` may return null if there have not been any deliveries within 30 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/get(repos/list-webhooks)`.
    func reposListWebhooks(_ input: Operations.ReposListWebhooks.Input) async throws -> Operations.ReposListWebhooks.Output
    /// Create a repository webhook
    ///
    /// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
    /// share the same `config` as long as those webhooks do not have any `events` that overlap.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/post(repos/create-webhook)`.
    func reposCreateWebhook(_ input: Operations.ReposCreateWebhook.Input) async throws -> Operations.ReposCreateWebhook.Output
    /// Get a repository webhook
    ///
    /// Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/webhooks/repo-config#get-a-webhook-configuration-for-a-repository)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/get(repos/get-webhook)`.
    func reposGetWebhook(_ input: Operations.ReposGetWebhook.Input) async throws -> Operations.ReposGetWebhook.Output
    /// Update a repository webhook
    ///
    /// Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/webhooks/repo-config#update-a-webhook-configuration-for-a-repository)."
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/patch(repos/update-webhook)`.
    func reposUpdateWebhook(_ input: Operations.ReposUpdateWebhook.Input) async throws -> Operations.ReposUpdateWebhook.Output
    /// Delete a repository webhook
    ///
    /// Delete a webhook for an organization.
    ///
    /// The authenticated user must be a repository owner, or have admin access in the repository, to delete the webhook.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/delete(repos/delete-webhook)`.
    func reposDeleteWebhook(_ input: Operations.ReposDeleteWebhook.Input) async throws -> Operations.ReposDeleteWebhook.Output
    /// Get a webhook configuration for a repository
    ///
    /// Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/webhooks/repos#get-a-repository-webhook)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `read:repo_hook` or `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/config`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/get(repos/get-webhook-config-for-repo)`.
    func reposGetWebhookConfigForRepo(_ input: Operations.ReposGetWebhookConfigForRepo.Input) async throws -> Operations.ReposGetWebhookConfigForRepo.Output
    /// Update a webhook configuration for a repository
    ///
    /// Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/webhooks/repos#update-a-repository-webhook)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `write:repo_hook` or `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/patch(repos/update-webhook-config-for-repo)`.
    func reposUpdateWebhookConfigForRepo(_ input: Operations.ReposUpdateWebhookConfigForRepo.Input) async throws -> Operations.ReposUpdateWebhookConfigForRepo.Output
    /// List deliveries for a repository webhook
    ///
    /// Returns a list of webhook deliveries for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/get(repos/list-webhook-deliveries)`.
    func reposListWebhookDeliveries(_ input: Operations.ReposListWebhookDeliveries.Input) async throws -> Operations.ReposListWebhookDeliveries.Output
    /// Get a delivery for a repository webhook
    ///
    /// Returns a delivery for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/get(repos/get-webhook-delivery)`.
    func reposGetWebhookDelivery(_ input: Operations.ReposGetWebhookDelivery.Input) async throws -> Operations.ReposGetWebhookDelivery.Output
    /// Redeliver a delivery for a repository webhook
    ///
    /// Redeliver a webhook delivery for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/post(repos/redeliver-webhook-delivery)`.
    func reposRedeliverWebhookDelivery(_ input: Operations.ReposRedeliverWebhookDelivery.Input) async throws -> Operations.ReposRedeliverWebhookDelivery.Output
    /// Ping a repository webhook
    ///
    /// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/pings`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/pings/post(repos/ping-webhook)`.
    func reposPingWebhook(_ input: Operations.ReposPingWebhook.Input) async throws -> Operations.ReposPingWebhook.Output
    /// Test the push repository webhook
    ///
    /// This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.
    ///
    /// > [!NOTE]
    /// > Previously `/repos/:owner/:repo/hooks/:hook_id/test`
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/tests`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/tests/post(repos/test-push-webhook)`.
    func reposTestPushWebhook(_ input: Operations.ReposTestPushWebhook.Input) async throws -> Operations.ReposTestPushWebhook.Output
    /// List repository invitations
    ///
    /// When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/invitations`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/get(repos/list-invitations)`.
    func reposListInvitations(_ input: Operations.ReposListInvitations.Input) async throws -> Operations.ReposListInvitations.Output
    /// Update a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/patch(repos/update-invitation)`.
    func reposUpdateInvitation(_ input: Operations.ReposUpdateInvitation.Input) async throws -> Operations.ReposUpdateInvitation.Output
    /// Delete a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/delete(repos/delete-invitation)`.
    func reposDeleteInvitation(_ input: Operations.ReposDeleteInvitation.Input) async throws -> Operations.ReposDeleteInvitation.Output
    /// List deploy keys
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/keys`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/get(repos/list-deploy-keys)`.
    func reposListDeployKeys(_ input: Operations.ReposListDeployKeys.Input) async throws -> Operations.ReposListDeployKeys.Output
    /// Create a deploy key
    ///
    /// You can create a read-only deploy key.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/keys`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/post(repos/create-deploy-key)`.
    func reposCreateDeployKey(_ input: Operations.ReposCreateDeployKey.Input) async throws -> Operations.ReposCreateDeployKey.Output
    /// Get a deploy key
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/keys/{key_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/get(repos/get-deploy-key)`.
    func reposGetDeployKey(_ input: Operations.ReposGetDeployKey.Input) async throws -> Operations.ReposGetDeployKey.Output
    /// Delete a deploy key
    ///
    /// Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/keys/{key_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/delete(repos/delete-deploy-key)`.
    func reposDeleteDeployKey(_ input: Operations.ReposDeleteDeployKey.Input) async throws -> Operations.ReposDeleteDeployKey.Output
    /// List repository languages
    ///
    /// Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/languages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/languages/get(repos/list-languages)`.
    func reposListLanguages(_ input: Operations.ReposListLanguages.Input) async throws -> Operations.ReposListLanguages.Output
    /// Sync a fork branch with the upstream repository
    ///
    /// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/merge-upstream`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)`.
    func reposMergeUpstream(_ input: Operations.ReposMergeUpstream.Input) async throws -> Operations.ReposMergeUpstream.Output
    /// Merge a branch
    ///
    ///
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/merges`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)`.
    func reposMerge(_ input: Operations.ReposMerge.Input) async throws -> Operations.ReposMerge.Output
    /// Get a GitHub Pages site
    ///
    /// Gets information about a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/get(repos/get-pages)`.
    func reposGetPages(_ input: Operations.ReposGetPages.Input) async throws -> Operations.ReposGetPages.Output
    /// Create a GitHub Pages site
    ///
    /// Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/post(repos/create-pages-site)`.
    func reposCreatePagesSite(_ input: Operations.ReposCreatePagesSite.Input) async throws -> Operations.ReposCreatePagesSite.Output
    /// Update information about a GitHub Pages site
    ///
    /// Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)`.
    func reposUpdateInformationAboutPagesSite(_ input: Operations.ReposUpdateInformationAboutPagesSite.Input) async throws -> Operations.ReposUpdateInformationAboutPagesSite.Output
    /// Delete a GitHub Pages site
    ///
    /// Deletes a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)`.
    func reposDeletePagesSite(_ input: Operations.ReposDeletePagesSite.Input) async throws -> Operations.ReposDeletePagesSite.Output
    /// List GitHub Pages builds
    ///
    /// Lists builts of a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/get(repos/list-pages-builds)`.
    func reposListPagesBuilds(_ input: Operations.ReposListPagesBuilds.Input) async throws -> Operations.ReposListPagesBuilds.Output
    /// Request a GitHub Pages build
    ///
    /// You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
    ///
    /// Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/builds`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/post(repos/request-pages-build)`.
    func reposRequestPagesBuild(_ input: Operations.ReposRequestPagesBuild.Input) async throws -> Operations.ReposRequestPagesBuild.Output
    /// Get latest Pages build
    ///
    /// Gets information about the single most recent build of a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/latest/get(repos/get-latest-pages-build)`.
    func reposGetLatestPagesBuild(_ input: Operations.ReposGetLatestPagesBuild.Input) async throws -> Operations.ReposGetLatestPagesBuild.Output
    /// Get GitHub Pages build
    ///
    /// Gets information about a GitHub Pages build.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds/{build_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/{build_id}/get(repos/get-pages-build)`.
    func reposGetPagesBuild(_ input: Operations.ReposGetPagesBuild.Input) async throws -> Operations.ReposGetPagesBuild.Output
    /// Create a GitHub Pages deployment
    ///
    /// Create a GitHub Pages deployment for a repository.
    ///
    /// The authenticated user must have write permission to the repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/post(repos/create-pages-deployment)`.
    func reposCreatePagesDeployment(_ input: Operations.ReposCreatePagesDeployment.Input) async throws -> Operations.ReposCreatePagesDeployment.Output
    /// Get the status of a GitHub Pages deployment
    ///
    /// Gets the current status of a GitHub Pages deployment.
    ///
    /// The authenticated user must have read permission for the GitHub Pages site.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/get(repos/get-pages-deployment)`.
    func reposGetPagesDeployment(_ input: Operations.ReposGetPagesDeployment.Input) async throws -> Operations.ReposGetPagesDeployment.Output
    /// Cancel a GitHub Pages deployment
    ///
    /// Cancels a GitHub Pages deployment.
    ///
    /// The authenticated user must have write permissions for the GitHub Pages site.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/post(repos/cancel-pages-deployment)`.
    func reposCancelPagesDeployment(_ input: Operations.ReposCancelPagesDeployment.Input) async throws -> Operations.ReposCancelPagesDeployment.Output
    /// Get a DNS health check for GitHub Pages
    ///
    /// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.
    ///
    /// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/health`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)`.
    func reposGetPagesHealthCheck(_ input: Operations.ReposGetPagesHealthCheck.Input) async throws -> Operations.ReposGetPagesHealthCheck.Output
    /// Check if private vulnerability reporting is enabled for a repository
    ///
    /// Returns a boolean indicating whether or not private vulnerability reporting is enabled for the repository. For more information, see "[Evaluating the security settings of a repository](https://docs.github.com/code-security/security-advisories/working-with-repository-security-advisories/evaluating-the-security-settings-of-a-repository)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/get(repos/check-private-vulnerability-reporting)`.
    func reposCheckPrivateVulnerabilityReporting(_ input: Operations.ReposCheckPrivateVulnerabilityReporting.Input) async throws -> Operations.ReposCheckPrivateVulnerabilityReporting.Output
    /// Enable private vulnerability reporting for a repository
    ///
    /// Enables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)."
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/put(repos/enable-private-vulnerability-reporting)`.
    func reposEnablePrivateVulnerabilityReporting(_ input: Operations.ReposEnablePrivateVulnerabilityReporting.Input) async throws -> Operations.ReposEnablePrivateVulnerabilityReporting.Output
    /// Disable private vulnerability reporting for a repository
    ///
    /// Disables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/delete(repos/disable-private-vulnerability-reporting)`.
    func reposDisablePrivateVulnerabilityReporting(_ input: Operations.ReposDisablePrivateVulnerabilityReporting.Input) async throws -> Operations.ReposDisablePrivateVulnerabilityReporting.Output
    /// Get all custom property values for a repository
    ///
    /// Gets all custom property values that are set for a repository.
    /// Users with read access to the repository can use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/properties/values`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/get(repos/get-custom-properties-values)`.
    func reposGetCustomPropertiesValues(_ input: Operations.ReposGetCustomPropertiesValues.Input) async throws -> Operations.ReposGetCustomPropertiesValues.Output
    /// Create or update custom property values for a repository
    ///
    /// Create new or update existing custom property values for a repository.
    /// Using a value of `null` for a custom property will remove or 'unset' the property value from the repository.
    ///
    /// Repository admins and other users with the repository-level "edit custom property values" fine-grained permission can use this endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/properties/values`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)`.
    func reposCreateOrUpdateCustomPropertiesValues(_ input: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input) async throws -> Operations.ReposCreateOrUpdateCustomPropertiesValues.Output
    /// Get a repository README
    ///
    /// Gets the preferred README for a repository.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
    /// - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/readme`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)`.
    func reposGetReadme(_ input: Operations.ReposGetReadme.Input) async throws -> Operations.ReposGetReadme.Output
    /// Get a repository README for a directory
    ///
    /// Gets the README from a repository directory.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
    /// - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/readme/{dir}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/{dir}/get(repos/get-readme-in-directory)`.
    func reposGetReadmeInDirectory(_ input: Operations.ReposGetReadmeInDirectory.Input) async throws -> Operations.ReposGetReadmeInDirectory.Output
    /// List releases
    ///
    /// This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).
    ///
    /// Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)`.
    func reposListReleases(_ input: Operations.ReposListReleases.Input) async throws -> Operations.ReposListReleases.Output
    /// Create a release
    ///
    /// Users with push access to the repository can create a release.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)`.
    func reposCreateRelease(_ input: Operations.ReposCreateRelease.Input) async throws -> Operations.ReposCreateRelease.Output
    /// Get a release asset
    ///
    /// To download the asset's binary content:
    ///
    /// - If within a browser, fetch the location specified in the `browser_download_url` key provided in the response.
    /// - Alternatively, set the `Accept` header of the request to 
    ///   [`application/octet-stream`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types). 
    ///   The API will either redirect the client to the location, or stream it directly if possible.
    ///   API clients should handle both a `200` or `302` response.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/get(repos/get-release-asset)`.
    func reposGetReleaseAsset(_ input: Operations.ReposGetReleaseAsset.Input) async throws -> Operations.ReposGetReleaseAsset.Output
    /// Update a release asset
    ///
    /// Users with push access to the repository can edit a release asset.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/patch(repos/update-release-asset)`.
    func reposUpdateReleaseAsset(_ input: Operations.ReposUpdateReleaseAsset.Input) async throws -> Operations.ReposUpdateReleaseAsset.Output
    /// Delete a release asset
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/delete(repos/delete-release-asset)`.
    func reposDeleteReleaseAsset(_ input: Operations.ReposDeleteReleaseAsset.Input) async throws -> Operations.ReposDeleteReleaseAsset.Output
    /// Generate release notes content for a release
    ///
    /// Generate a name and body describing a [release](https://docs.github.com/rest/releases/releases#get-a-release). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases/generate-notes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/generate-notes/post(repos/generate-release-notes)`.
    func reposGenerateReleaseNotes(_ input: Operations.ReposGenerateReleaseNotes.Input) async throws -> Operations.ReposGenerateReleaseNotes.Output
    /// Get the latest release
    ///
    /// View the latest published full release for the repository.
    ///
    /// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)`.
    func reposGetLatestRelease(_ input: Operations.ReposGetLatestRelease.Input) async throws -> Operations.ReposGetLatestRelease.Output
    /// Get a release by tag name
    ///
    /// Get a published release with the specified tag.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/tags/{tag}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/tags/{tag}/get(repos/get-release-by-tag)`.
    func reposGetReleaseByTag(_ input: Operations.ReposGetReleaseByTag.Input) async throws -> Operations.ReposGetReleaseByTag.Output
    /// Get a release
    ///
    /// Gets a public release with the specified release ID.
    ///
    /// > [!NOTE]
    /// > This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/get(repos/get-release)`.
    func reposGetRelease(_ input: Operations.ReposGetRelease.Input) async throws -> Operations.ReposGetRelease.Output
    /// Update a release
    ///
    /// Users with push access to the repository can edit a release.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/patch(repos/update-release)`.
    func reposUpdateRelease(_ input: Operations.ReposUpdateRelease.Input) async throws -> Operations.ReposUpdateRelease.Output
    /// Delete a release
    ///
    /// Users with push access to the repository can delete a release.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/delete(repos/delete-release)`.
    func reposDeleteRelease(_ input: Operations.ReposDeleteRelease.Input) async throws -> Operations.ReposDeleteRelease.Output
    /// List release assets
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/{release_id}/assets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/get(repos/list-release-assets)`.
    func reposListReleaseAssets(_ input: Operations.ReposListReleaseAssets.Input) async throws -> Operations.ReposListReleaseAssets.Output
    /// Upload a release asset
    ///
    /// This endpoint makes use of a [Hypermedia relation](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
    /// the response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload a release asset.
    ///
    /// You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
    ///
    /// Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example: 
    ///
    /// `application/zip`
    ///
    /// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
    /// you'll still need to pass your authentication to be able to upload an asset.
    ///
    /// When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.
    ///
    /// **Notes:**
    /// *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List release assets](https://docs.github.com/rest/releases/assets#list-release-assets)"
    /// endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
    /// *   To find the `release_id` query the [`GET /repos/{owner}/{repo}/releases/latest` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release). 
    /// *   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases/{release_id}/assets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/post(repos/upload-release-asset)`.
    func reposUploadReleaseAsset(_ input: Operations.ReposUploadReleaseAsset.Input) async throws -> Operations.ReposUploadReleaseAsset.Output
    /// Get rules for a branch
    ///
    /// Returns all active rules that apply to the specified branch. The branch does not need to exist; rules that would apply
    /// to a branch with that name will be returned. All active rules that apply will be returned, regardless of the level
    /// at which they are configured (e.g. repository or organization). Rules in rulesets with "evaluate" or "disabled"
    /// enforcement statuses are not returned.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rules/branches/{branch}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rules/branches/{branch}/get(repos/get-branch-rules)`.
    func reposGetBranchRules(_ input: Operations.ReposGetBranchRules.Input) async throws -> Operations.ReposGetBranchRules.Output
    /// Get all repository rulesets
    ///
    /// Get all the rulesets for a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/get(repos/get-repo-rulesets)`.
    func reposGetRepoRulesets(_ input: Operations.ReposGetRepoRulesets.Input) async throws -> Operations.ReposGetRepoRulesets.Output
    /// Create a repository ruleset
    ///
    /// Create a ruleset for a repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/rulesets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/post(repos/create-repo-ruleset)`.
    func reposCreateRepoRuleset(_ input: Operations.ReposCreateRepoRuleset.Input) async throws -> Operations.ReposCreateRepoRuleset.Output
    /// List repository rule suites
    ///
    /// Lists suites of rule evaluations at the repository level.
    /// For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/rule-suites`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/get(repos/get-repo-rule-suites)`.
    func reposGetRepoRuleSuites(_ input: Operations.ReposGetRepoRuleSuites.Input) async throws -> Operations.ReposGetRepoRuleSuites.Output
    /// Get a repository rule suite
    ///
    /// Gets information about a suite of rule evaluations from within a repository.
    /// For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-repo-rule-suite)`.
    func reposGetRepoRuleSuite(_ input: Operations.ReposGetRepoRuleSuite.Input) async throws -> Operations.ReposGetRepoRuleSuite.Output
    /// Get a repository ruleset
    ///
    /// Get a ruleset for a repository.
    ///
    /// **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
    /// making the API request has write access to the ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/get(repos/get-repo-ruleset)`.
    func reposGetRepoRuleset(_ input: Operations.ReposGetRepoRuleset.Input) async throws -> Operations.ReposGetRepoRuleset.Output
    /// Update a repository ruleset
    ///
    /// Update a ruleset for a repository.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/put(repos/update-repo-ruleset)`.
    func reposUpdateRepoRuleset(_ input: Operations.ReposUpdateRepoRuleset.Input) async throws -> Operations.ReposUpdateRepoRuleset.Output
    /// Delete a repository ruleset
    ///
    /// Delete a ruleset for a repository.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/delete(repos/delete-repo-ruleset)`.
    func reposDeleteRepoRuleset(_ input: Operations.ReposDeleteRepoRuleset.Input) async throws -> Operations.ReposDeleteRepoRuleset.Output
    /// Get repository ruleset history
    ///
    /// Get the history of a repository ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/get(repos/get-repo-ruleset-history)`.
    func reposGetRepoRulesetHistory(_ input: Operations.ReposGetRepoRulesetHistory.Input) async throws -> Operations.ReposGetRepoRulesetHistory.Output
    /// Get repository ruleset version
    ///
    /// Get a version of a repository ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/get(repos/get-repo-ruleset-version)`.
    func reposGetRepoRulesetVersion(_ input: Operations.ReposGetRepoRulesetVersion.Input) async throws -> Operations.ReposGetRepoRulesetVersion.Output
    /// Get the weekly commit activity
    ///
    /// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
    ///
    /// > [!NOTE]
    /// > This endpoint can only be used for repositories with fewer than 10,000 commits. If the repository contains 10,000 or more commits, a 422 status code will be returned.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/code_frequency`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)`.
    func reposGetCodeFrequencyStats(_ input: Operations.ReposGetCodeFrequencyStats.Input) async throws -> Operations.ReposGetCodeFrequencyStats.Output
    /// Get the last year of commit activity
    ///
    /// Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/commit_activity`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/commit_activity/get(repos/get-commit-activity-stats)`.
    func reposGetCommitActivityStats(_ input: Operations.ReposGetCommitActivityStats.Input) async throws -> Operations.ReposGetCommitActivityStats.Output
    /// Get all contributor commit activity
    ///
    ///
    /// Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:
    ///
    /// *   `w` - Start of the week, given as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
    /// *   `a` - Number of additions
    /// *   `d` - Number of deletions
    /// *   `c` - Number of commits
    ///
    /// > [!NOTE]
    /// > This endpoint will return `0` values for all addition and deletion counts in repositories with 10,000 or more commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/contributors/get(repos/get-contributors-stats)`.
    func reposGetContributorsStats(_ input: Operations.ReposGetContributorsStats.Input) async throws -> Operations.ReposGetContributorsStats.Output
    /// Get the weekly commit count
    ///
    /// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.
    ///
    /// The array order is oldest week (index 0) to most recent week.
    ///
    /// The most recent week is seven days ago at UTC midnight to today at UTC midnight.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/participation`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/participation/get(repos/get-participation-stats)`.
    func reposGetParticipationStats(_ input: Operations.ReposGetParticipationStats.Input) async throws -> Operations.ReposGetParticipationStats.Output
    /// Get the hourly commit count for each day
    ///
    /// Each array contains the day number, hour number, and number of commits:
    ///
    /// *   `0-6`: Sunday - Saturday
    /// *   `0-23`: Hour of day
    /// *   Number of commits
    ///
    /// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/punch_card`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/punch_card/get(repos/get-punch-card-stats)`.
    func reposGetPunchCardStats(_ input: Operations.ReposGetPunchCardStats.Input) async throws -> Operations.ReposGetPunchCardStats.Output
    /// Create a commit status
    ///
    /// Users with push access in a repository can create commit statuses for a given SHA.
    ///
    /// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/statuses/{sha}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/statuses/{sha}/post(repos/create-commit-status)`.
    func reposCreateCommitStatus(_ input: Operations.ReposCreateCommitStatus.Input) async throws -> Operations.ReposCreateCommitStatus.Output
    /// List repository tags
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/get(repos/list-tags)`.
    func reposListTags(_ input: Operations.ReposListTags.Input) async throws -> Operations.ReposListTags.Output
    /// Closing down - List tag protection states for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#get-all-repository-rulesets)" endpoint instead.
    ///
    /// This returns the tag protection states of a repository.
    ///
    /// This information is only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/get(repos/list-tag-protection)`.
    @available(*, deprecated)
    func reposListTagProtection(_ input: Operations.ReposListTagProtection.Input) async throws -> Operations.ReposListTagProtection.Output
    /// Closing down - Create a tag protection state for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#create-a-repository-ruleset)" endpoint instead.
    ///
    /// This creates a tag protection state for a repository.
    /// This endpoint is only available to repository administrators.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/tags/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/post(repos/create-tag-protection)`.
    @available(*, deprecated)
    func reposCreateTagProtection(_ input: Operations.ReposCreateTagProtection.Input) async throws -> Operations.ReposCreateTagProtection.Output
    /// Closing down - Delete a tag protection state for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#delete-a-repository-ruleset)" endpoint instead.
    ///
    /// This deletes a tag protection state for a repository.
    /// This endpoint is only available to repository administrators.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/{tag_protection_id}/delete(repos/delete-tag-protection)`.
    @available(*, deprecated)
    func reposDeleteTagProtection(_ input: Operations.ReposDeleteTagProtection.Input) async throws -> Operations.ReposDeleteTagProtection.Output
    /// Download a repository archive (tar)
    ///
    /// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repositorys default branch (usually
    /// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    /// the `Location` header to make a second `GET` request.
    ///
    /// > [!NOTE]
    /// > For private repositories, these links are temporary and expire after five minutes.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tarball/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tarball/{ref}/get(repos/download-tarball-archive)`.
    func reposDownloadTarballArchive(_ input: Operations.ReposDownloadTarballArchive.Input) async throws -> Operations.ReposDownloadTarballArchive.Output
    /// List repository teams
    ///
    /// Lists the teams that have access to the specified repository and that are also visible to the authenticated user.
    ///
    /// For a public repository, a team is listed only if that team added the public repository explicitly.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to use this endpoint with a public repository, and `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/teams/get(repos/list-teams)`.
    func reposListTeams(_ input: Operations.ReposListTeams.Input) async throws -> Operations.ReposListTeams.Output
    /// Get all repository topics
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/topics`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/get(repos/get-all-topics)`.
    func reposGetAllTopics(_ input: Operations.ReposGetAllTopics.Input) async throws -> Operations.ReposGetAllTopics.Output
    /// Replace all repository topics
    ///
    ///
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/topics`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/put(repos/replace-all-topics)`.
    func reposReplaceAllTopics(_ input: Operations.ReposReplaceAllTopics.Input) async throws -> Operations.ReposReplaceAllTopics.Output
    /// Get repository clones
    ///
    /// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/clones`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/clones/get(repos/get-clones)`.
    func reposGetClones(_ input: Operations.ReposGetClones.Input) async throws -> Operations.ReposGetClones.Output
    /// Get top referral paths
    ///
    /// Get the top 10 popular contents over the last 14 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/popular/paths`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/paths/get(repos/get-top-paths)`.
    func reposGetTopPaths(_ input: Operations.ReposGetTopPaths.Input) async throws -> Operations.ReposGetTopPaths.Output
    /// Get top referral sources
    ///
    /// Get the top 10 referrers over the last 14 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/popular/referrers`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/referrers/get(repos/get-top-referrers)`.
    func reposGetTopReferrers(_ input: Operations.ReposGetTopReferrers.Input) async throws -> Operations.ReposGetTopReferrers.Output
    /// Get page views
    ///
    /// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/views`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/views/get(repos/get-views)`.
    func reposGetViews(_ input: Operations.ReposGetViews.Input) async throws -> Operations.ReposGetViews.Output
    /// Transfer a repository
    ///
    /// A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/transfer`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/transfer/post(repos/transfer)`.
    func reposTransfer(_ input: Operations.ReposTransfer.Input) async throws -> Operations.ReposTransfer.Output
    /// Check if vulnerability alerts are enabled for a repository
    ///
    /// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/get(repos/check-vulnerability-alerts)`.
    func reposCheckVulnerabilityAlerts(_ input: Operations.ReposCheckVulnerabilityAlerts.Input) async throws -> Operations.ReposCheckVulnerabilityAlerts.Output
    /// Enable vulnerability alerts
    ///
    /// Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/put(repos/enable-vulnerability-alerts)`.
    func reposEnableVulnerabilityAlerts(_ input: Operations.ReposEnableVulnerabilityAlerts.Input) async throws -> Operations.ReposEnableVulnerabilityAlerts.Output
    /// Disable vulnerability alerts
    ///
    /// Disables dependency alerts and the dependency graph for a repository.
    /// The authenticated user must have admin access to the repository. For more information,
    /// see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/delete(repos/disable-vulnerability-alerts)`.
    func reposDisableVulnerabilityAlerts(_ input: Operations.ReposDisableVulnerabilityAlerts.Input) async throws -> Operations.ReposDisableVulnerabilityAlerts.Output
    /// Download a repository archive (zip)
    ///
    /// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repositorys default branch (usually
    /// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    /// the `Location` header to make a second `GET` request.
    ///
    /// > [!NOTE]
    /// > For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you will receive a 404 when you follow the redirect.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/zipball/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/zipball/{ref}/get(repos/download-zipball-archive)`.
    func reposDownloadZipballArchive(_ input: Operations.ReposDownloadZipballArchive.Input) async throws -> Operations.ReposDownloadZipballArchive.Output
    /// Create a repository using a template
    ///
    /// Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/repos/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /repos/{template_owner}/{template_repo}/generate`.
    /// - Remark: Generated from `#/paths//repos/{template_owner}/{template_repo}/generate/post(repos/create-using-template)`.
    func reposCreateUsingTemplate(_ input: Operations.ReposCreateUsingTemplate.Input) async throws -> Operations.ReposCreateUsingTemplate.Output
    /// List public repositories
    ///
    /// Lists all public repositories in the order that they were created.
    ///
    /// Note:
    /// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
    /// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of repositories.
    ///
    /// - Remark: HTTP `GET /repositories`.
    /// - Remark: Generated from `#/paths//repositories/get(repos/list-public)`.
    func reposListPublic(_ input: Operations.ReposListPublic.Input) async throws -> Operations.ReposListPublic.Output
    /// List repositories for the authenticated user
    ///
    /// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
    ///
    /// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
    ///
    /// - Remark: HTTP `GET /user/repos`.
    /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)`.
    func reposListForAuthenticatedUser(_ input: Operations.ReposListForAuthenticatedUser.Input) async throws -> Operations.ReposListForAuthenticatedUser.Output
    /// Create a repository for the authenticated user
    ///
    /// Creates a new repository for the authenticated user.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /user/repos`.
    /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)`.
    func reposCreateForAuthenticatedUser(_ input: Operations.ReposCreateForAuthenticatedUser.Input) async throws -> Operations.ReposCreateForAuthenticatedUser.Output
    /// List repository invitations for the authenticated user
    ///
    /// When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
    ///
    /// - Remark: HTTP `GET /user/repository_invitations`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)`.
    func reposListInvitationsForAuthenticatedUser(_ input: Operations.ReposListInvitationsForAuthenticatedUser.Input) async throws -> Operations.ReposListInvitationsForAuthenticatedUser.Output
    /// Accept a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `PATCH /user/repository_invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)`.
    func reposAcceptInvitationForAuthenticatedUser(_ input: Operations.ReposAcceptInvitationForAuthenticatedUser.Input) async throws -> Operations.ReposAcceptInvitationForAuthenticatedUser.Output
    /// Decline a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /user/repository_invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)`.
    func reposDeclineInvitationForAuthenticatedUser(_ input: Operations.ReposDeclineInvitationForAuthenticatedUser.Input) async throws -> Operations.ReposDeclineInvitationForAuthenticatedUser.Output
    /// List repositories for a user
    ///
    /// Lists public repositories for the specified user.
    ///
    /// - Remark: HTTP `GET /users/{username}/repos`.
    /// - Remark: Generated from `#/paths//users/{username}/repos/get(repos/list-for-user)`.
    func reposListForUser(_ input: Operations.ReposListForUser.Input) async throws -> Operations.ReposListForUser.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// List organization repositories
    ///
    /// Lists repositories for the specified organization.
    ///
    /// > [!NOTE]
    /// > In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/repos`.
    /// - Remark: Generated from `#/paths//orgs/{org}/repos/get(repos/list-for-org)`.
    public func reposListForOrg(
        path: Operations.ReposListForOrg.Input.Path,
        query: Operations.ReposListForOrg.Input.Query = .init(),
        headers: Operations.ReposListForOrg.Input.Headers = .init()
    ) async throws -> Operations.ReposListForOrg.Output {
        try await reposListForOrg(Operations.ReposListForOrg.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create an organization repository
    ///
    /// Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /orgs/{org}/repos`.
    /// - Remark: Generated from `#/paths//orgs/{org}/repos/post(repos/create-in-org)`.
    public func reposCreateInOrg(
        path: Operations.ReposCreateInOrg.Input.Path,
        headers: Operations.ReposCreateInOrg.Input.Headers = .init(),
        body: Operations.ReposCreateInOrg.Input.Body
    ) async throws -> Operations.ReposCreateInOrg.Output {
        try await reposCreateInOrg(Operations.ReposCreateInOrg.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get all organization repository rulesets
    ///
    /// Get all the repository rulesets for an organization.
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/get(repos/get-org-rulesets)`.
    public func reposGetOrgRulesets(
        path: Operations.ReposGetOrgRulesets.Input.Path,
        query: Operations.ReposGetOrgRulesets.Input.Query = .init(),
        headers: Operations.ReposGetOrgRulesets.Input.Headers = .init()
    ) async throws -> Operations.ReposGetOrgRulesets.Output {
        try await reposGetOrgRulesets(Operations.ReposGetOrgRulesets.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create an organization repository ruleset
    ///
    /// Create a repository ruleset for an organization.
    ///
    /// - Remark: HTTP `POST /orgs/{org}/rulesets`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/post(repos/create-org-ruleset)`.
    public func reposCreateOrgRuleset(
        path: Operations.ReposCreateOrgRuleset.Input.Path,
        headers: Operations.ReposCreateOrgRuleset.Input.Headers = .init(),
        body: Operations.ReposCreateOrgRuleset.Input.Body
    ) async throws -> Operations.ReposCreateOrgRuleset.Output {
        try await reposCreateOrgRuleset(Operations.ReposCreateOrgRuleset.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List organization rule suites
    ///
    /// Lists suites of rule evaluations at the organization level.
    /// For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/rule-suites`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/get(repos/get-org-rule-suites)`.
    public func reposGetOrgRuleSuites(
        path: Operations.ReposGetOrgRuleSuites.Input.Path,
        query: Operations.ReposGetOrgRuleSuites.Input.Query = .init(),
        headers: Operations.ReposGetOrgRuleSuites.Input.Headers = .init()
    ) async throws -> Operations.ReposGetOrgRuleSuites.Output {
        try await reposGetOrgRuleSuites(Operations.ReposGetOrgRuleSuites.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get an organization rule suite
    ///
    /// Gets information about a suite of rule evaluations from within an organization.
    /// For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-org-rule-suite)`.
    public func reposGetOrgRuleSuite(
        path: Operations.ReposGetOrgRuleSuite.Input.Path,
        headers: Operations.ReposGetOrgRuleSuite.Input.Headers = .init()
    ) async throws -> Operations.ReposGetOrgRuleSuite.Output {
        try await reposGetOrgRuleSuite(Operations.ReposGetOrgRuleSuite.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get an organization repository ruleset
    ///
    /// Get a repository ruleset for an organization.
    ///
    /// **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
    /// making the API request has write access to the ruleset.
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/get(repos/get-org-ruleset)`.
    public func reposGetOrgRuleset(
        path: Operations.ReposGetOrgRuleset.Input.Path,
        headers: Operations.ReposGetOrgRuleset.Input.Headers = .init()
    ) async throws -> Operations.ReposGetOrgRuleset.Output {
        try await reposGetOrgRuleset(Operations.ReposGetOrgRuleset.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update an organization repository ruleset
    ///
    /// Update a ruleset for an organization.
    ///
    /// - Remark: HTTP `PUT /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/put(repos/update-org-ruleset)`.
    public func reposUpdateOrgRuleset(
        path: Operations.ReposUpdateOrgRuleset.Input.Path,
        headers: Operations.ReposUpdateOrgRuleset.Input.Headers = .init(),
        body: Operations.ReposUpdateOrgRuleset.Input.Body? = nil
    ) async throws -> Operations.ReposUpdateOrgRuleset.Output {
        try await reposUpdateOrgRuleset(Operations.ReposUpdateOrgRuleset.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete an organization repository ruleset
    ///
    /// Delete a ruleset for an organization.
    ///
    /// - Remark: HTTP `DELETE /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/delete(repos/delete-org-ruleset)`.
    public func reposDeleteOrgRuleset(
        path: Operations.ReposDeleteOrgRuleset.Input.Path,
        headers: Operations.ReposDeleteOrgRuleset.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteOrgRuleset.Output {
        try await reposDeleteOrgRuleset(Operations.ReposDeleteOrgRuleset.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get a repository
    ///
    /// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    ///
    /// > [!NOTE]
    /// > In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)`.
    public func reposGet(
        path: Operations.ReposGet.Input.Path,
        headers: Operations.ReposGet.Input.Headers = .init()
    ) async throws -> Operations.ReposGet.Output {
        try await reposGet(Operations.ReposGet.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update a repository
    ///
    /// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics) endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)`.
    public func reposUpdate(
        path: Operations.ReposUpdate.Input.Path,
        headers: Operations.ReposUpdate.Input.Headers = .init(),
        body: Operations.ReposUpdate.Input.Body? = nil
    ) async throws -> Operations.ReposUpdate.Output {
        try await reposUpdate(Operations.ReposUpdate.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a repository
    ///
    /// Deleting a repository requires admin access.
    ///
    /// If an organization owner has configured the organization to prevent members from deleting organization-owned
    /// repositories, you will get a `403 Forbidden` response.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `delete_repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)`.
    public func reposDelete(
        path: Operations.ReposDelete.Input.Path,
        headers: Operations.ReposDelete.Input.Headers = .init()
    ) async throws -> Operations.ReposDelete.Output {
        try await reposDelete(Operations.ReposDelete.Input(
            path: path,
            headers: headers
        ))
    }
    /// List repository activities
    ///
    /// Lists a detailed history of changes to a repository, such as pushes, merges, force pushes, and branch changes, and associates these changes with commits and users.
    ///
    /// For more information about viewing repository activity,
    /// see "[Viewing activity and data for your repository](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/activity`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/activity/get(repos/list-activities)`.
    public func reposListActivities(
        path: Operations.ReposListActivities.Input.Path,
        query: Operations.ReposListActivities.Input.Query = .init(),
        headers: Operations.ReposListActivities.Input.Headers = .init()
    ) async throws -> Operations.ReposListActivities.Output {
        try await reposListActivities(Operations.ReposListActivities.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create an attestation
    ///
    /// Store an artifact attestation and associate it with a repository.
    ///
    /// The authenticated user must have write permission to the repository and, if using a fine-grained access token, the `attestations:write` permission is required.
    ///
    /// Artifact attestations are meant to be created using the [attest action](https://github.com/actions/attest). For more information, see our guide on [using artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/attestations`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/post(repos/create-attestation)`.
    public func reposCreateAttestation(
        path: Operations.ReposCreateAttestation.Input.Path,
        headers: Operations.ReposCreateAttestation.Input.Headers = .init(),
        body: Operations.ReposCreateAttestation.Input.Body
    ) async throws -> Operations.ReposCreateAttestation.Output {
        try await reposCreateAttestation(Operations.ReposCreateAttestation.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List attestations
    ///
    /// List a collection of artifact attestations with a given subject digest that are associated with a repository.
    ///
    /// The authenticated user making the request must have read access to the repository. In addition, when using a fine-grained access token the `attestations:read` permission is required.
    ///
    /// **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/attestations/{subject_digest}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/{subject_digest}/get(repos/list-attestations)`.
    public func reposListAttestations(
        path: Operations.ReposListAttestations.Input.Path,
        query: Operations.ReposListAttestations.Input.Query = .init(),
        headers: Operations.ReposListAttestations.Input.Headers = .init()
    ) async throws -> Operations.ReposListAttestations.Output {
        try await reposListAttestations(Operations.ReposListAttestations.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get all autolinks of a repository
    ///
    /// Gets all autolinks that are configured for a repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/autolinks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/get(repos/list-autolinks)`.
    public func reposListAutolinks(
        path: Operations.ReposListAutolinks.Input.Path,
        headers: Operations.ReposListAutolinks.Input.Headers = .init()
    ) async throws -> Operations.ReposListAutolinks.Output {
        try await reposListAutolinks(Operations.ReposListAutolinks.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create an autolink reference for a repository
    ///
    /// Users with admin access to the repository can create an autolink.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/autolinks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/post(repos/create-autolink)`.
    public func reposCreateAutolink(
        path: Operations.ReposCreateAutolink.Input.Path,
        headers: Operations.ReposCreateAutolink.Input.Headers = .init(),
        body: Operations.ReposCreateAutolink.Input.Body
    ) async throws -> Operations.ReposCreateAutolink.Output {
        try await reposCreateAutolink(Operations.ReposCreateAutolink.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get an autolink reference of a repository
    ///
    /// This returns a single autolink reference by ID that was configured for the given repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/autolinks/{autolink_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/get(repos/get-autolink)`.
    public func reposGetAutolink(
        path: Operations.ReposGetAutolink.Input.Path,
        headers: Operations.ReposGetAutolink.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAutolink.Output {
        try await reposGetAutolink(Operations.ReposGetAutolink.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete an autolink reference from a repository
    ///
    /// This deletes a single autolink reference by ID that was configured for the given repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/delete(repos/delete-autolink)`.
    public func reposDeleteAutolink(
        path: Operations.ReposDeleteAutolink.Input.Path,
        headers: Operations.ReposDeleteAutolink.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteAutolink.Output {
        try await reposDeleteAutolink(Operations.ReposDeleteAutolink.Input(
            path: path,
            headers: headers
        ))
    }
    /// Check if Dependabot security updates are enabled for a repository
    ///
    /// Shows whether Dependabot security updates are enabled, disabled or paused for a repository. The authenticated user must have admin read access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/get(repos/check-automated-security-fixes)`.
    public func reposCheckAutomatedSecurityFixes(
        path: Operations.ReposCheckAutomatedSecurityFixes.Input.Path,
        headers: Operations.ReposCheckAutomatedSecurityFixes.Input.Headers = .init()
    ) async throws -> Operations.ReposCheckAutomatedSecurityFixes.Output {
        try await reposCheckAutomatedSecurityFixes(Operations.ReposCheckAutomatedSecurityFixes.Input(
            path: path,
            headers: headers
        ))
    }
    /// Enable Dependabot security updates
    ///
    /// Enables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/put(repos/enable-automated-security-fixes)`.
    public func reposEnableAutomatedSecurityFixes(path: Operations.ReposEnableAutomatedSecurityFixes.Input.Path) async throws -> Operations.ReposEnableAutomatedSecurityFixes.Output {
        try await reposEnableAutomatedSecurityFixes(Operations.ReposEnableAutomatedSecurityFixes.Input(path: path))
    }
    /// Disable Dependabot security updates
    ///
    /// Disables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/delete(repos/disable-automated-security-fixes)`.
    public func reposDisableAutomatedSecurityFixes(path: Operations.ReposDisableAutomatedSecurityFixes.Input.Path) async throws -> Operations.ReposDisableAutomatedSecurityFixes.Output {
        try await reposDisableAutomatedSecurityFixes(Operations.ReposDisableAutomatedSecurityFixes.Input(path: path))
    }
    /// List branches
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/get(repos/list-branches)`.
    public func reposListBranches(
        path: Operations.ReposListBranches.Input.Path,
        query: Operations.ReposListBranches.Input.Query = .init(),
        headers: Operations.ReposListBranches.Input.Headers = .init()
    ) async throws -> Operations.ReposListBranches.Output {
        try await reposListBranches(Operations.ReposListBranches.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get a branch
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/get(repos/get-branch)`.
    public func reposGetBranch(
        path: Operations.ReposGetBranch.Input.Path,
        headers: Operations.ReposGetBranch.Input.Headers = .init()
    ) async throws -> Operations.ReposGetBranch.Output {
        try await reposGetBranch(Operations.ReposGetBranch.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/get(repos/get-branch-protection)`.
    public func reposGetBranchProtection(
        path: Operations.ReposGetBranchProtection.Input.Path,
        headers: Operations.ReposGetBranchProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposGetBranchProtection.Output {
        try await reposGetBranchProtection(Operations.ReposGetBranchProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Protecting a branch requires admin or owner permissions to the repository.
    ///
    /// > [!NOTE]
    /// > Passing new arrays of `users` and `teams` replaces their previous values.
    ///
    /// > [!NOTE]
    /// > The list of users, apps, and teams in total is limited to 100 items.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/put(repos/update-branch-protection)`.
    public func reposUpdateBranchProtection(
        path: Operations.ReposUpdateBranchProtection.Input.Path,
        headers: Operations.ReposUpdateBranchProtection.Input.Headers = .init(),
        body: Operations.ReposUpdateBranchProtection.Input.Body
    ) async throws -> Operations.ReposUpdateBranchProtection.Output {
        try await reposUpdateBranchProtection(Operations.ReposUpdateBranchProtection.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/delete(repos/delete-branch-protection)`.
    public func reposDeleteBranchProtection(
        path: Operations.ReposDeleteBranchProtection.Input.Path,
        headers: Operations.ReposDeleteBranchProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteBranchProtection.Output {
        try await reposDeleteBranchProtection(Operations.ReposDeleteBranchProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/get(repos/get-admin-branch-protection)`.
    public func reposGetAdminBranchProtection(
        path: Operations.ReposGetAdminBranchProtection.Input.Path,
        headers: Operations.ReposGetAdminBranchProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAdminBranchProtection.Output {
        try await reposGetAdminBranchProtection(Operations.ReposGetAdminBranchProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Set admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/post(repos/set-admin-branch-protection)`.
    public func reposSetAdminBranchProtection(
        path: Operations.ReposSetAdminBranchProtection.Input.Path,
        headers: Operations.ReposSetAdminBranchProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposSetAdminBranchProtection.Output {
        try await reposSetAdminBranchProtection(Operations.ReposSetAdminBranchProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/delete(repos/delete-admin-branch-protection)`.
    public func reposDeleteAdminBranchProtection(
        path: Operations.ReposDeleteAdminBranchProtection.Input.Path,
        headers: Operations.ReposDeleteAdminBranchProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteAdminBranchProtection.Output {
        try await reposDeleteAdminBranchProtection(Operations.ReposDeleteAdminBranchProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/get(repos/get-pull-request-review-protection)`.
    public func reposGetPullRequestReviewProtection(
        path: Operations.ReposGetPullRequestReviewProtection.Input.Path,
        headers: Operations.ReposGetPullRequestReviewProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposGetPullRequestReviewProtection.Output {
        try await reposGetPullRequestReviewProtection(Operations.ReposGetPullRequestReviewProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// > [!NOTE]
    /// > Passing new arrays of `users` and `teams` replaces their previous values.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/patch(repos/update-pull-request-review-protection)`.
    public func reposUpdatePullRequestReviewProtection(
        path: Operations.ReposUpdatePullRequestReviewProtection.Input.Path,
        headers: Operations.ReposUpdatePullRequestReviewProtection.Input.Headers = .init(),
        body: Operations.ReposUpdatePullRequestReviewProtection.Input.Body? = nil
    ) async throws -> Operations.ReposUpdatePullRequestReviewProtection.Output {
        try await reposUpdatePullRequestReviewProtection(Operations.ReposUpdatePullRequestReviewProtection.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/delete(repos/delete-pull-request-review-protection)`.
    public func reposDeletePullRequestReviewProtection(
        path: Operations.ReposDeletePullRequestReviewProtection.Input.Path,
        headers: Operations.ReposDeletePullRequestReviewProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposDeletePullRequestReviewProtection.Output {
        try await reposDeletePullRequestReviewProtection(Operations.ReposDeletePullRequestReviewProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.
    ///
    /// > [!NOTE]
    /// > You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/get(repos/get-commit-signature-protection)`.
    public func reposGetCommitSignatureProtection(
        path: Operations.ReposGetCommitSignatureProtection.Input.Path,
        headers: Operations.ReposGetCommitSignatureProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCommitSignatureProtection.Output {
        try await reposGetCommitSignatureProtection(Operations.ReposGetCommitSignatureProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/post(repos/create-commit-signature-protection)`.
    public func reposCreateCommitSignatureProtection(
        path: Operations.ReposCreateCommitSignatureProtection.Input.Path,
        headers: Operations.ReposCreateCommitSignatureProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposCreateCommitSignatureProtection.Output {
        try await reposCreateCommitSignatureProtection(Operations.ReposCreateCommitSignatureProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/delete(repos/delete-commit-signature-protection)`.
    public func reposDeleteCommitSignatureProtection(
        path: Operations.ReposDeleteCommitSignatureProtection.Input.Path,
        headers: Operations.ReposDeleteCommitSignatureProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteCommitSignatureProtection.Output {
        try await reposDeleteCommitSignatureProtection(Operations.ReposDeleteCommitSignatureProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get status checks protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/get(repos/get-status-checks-protection)`.
    public func reposGetStatusChecksProtection(
        path: Operations.ReposGetStatusChecksProtection.Input.Path,
        headers: Operations.ReposGetStatusChecksProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposGetStatusChecksProtection.Output {
        try await reposGetStatusChecksProtection(Operations.ReposGetStatusChecksProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update status check protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/patch(repos/update-status-check-protection)`.
    public func reposUpdateStatusCheckProtection(
        path: Operations.ReposUpdateStatusCheckProtection.Input.Path,
        headers: Operations.ReposUpdateStatusCheckProtection.Input.Headers = .init(),
        body: Operations.ReposUpdateStatusCheckProtection.Input.Body? = nil
    ) async throws -> Operations.ReposUpdateStatusCheckProtection.Output {
        try await reposUpdateStatusCheckProtection(Operations.ReposUpdateStatusCheckProtection.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Remove status check protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/delete(repos/remove-status-check-protection)`.
    public func reposRemoveStatusCheckProtection(path: Operations.ReposRemoveStatusCheckProtection.Input.Path) async throws -> Operations.ReposRemoveStatusCheckProtection.Output {
        try await reposRemoveStatusCheckProtection(Operations.ReposRemoveStatusCheckProtection.Input(path: path))
    }
    /// Get all status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/get(repos/get-all-status-check-contexts)`.
    public func reposGetAllStatusCheckContexts(
        path: Operations.ReposGetAllStatusCheckContexts.Input.Path,
        headers: Operations.ReposGetAllStatusCheckContexts.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAllStatusCheckContexts.Output {
        try await reposGetAllStatusCheckContexts(Operations.ReposGetAllStatusCheckContexts.Input(
            path: path,
            headers: headers
        ))
    }
    /// Add status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/post(repos/add-status-check-contexts)`.
    public func reposAddStatusCheckContexts(
        path: Operations.ReposAddStatusCheckContexts.Input.Path,
        headers: Operations.ReposAddStatusCheckContexts.Input.Headers = .init(),
        body: Operations.ReposAddStatusCheckContexts.Input.Body? = nil
    ) async throws -> Operations.ReposAddStatusCheckContexts.Output {
        try await reposAddStatusCheckContexts(Operations.ReposAddStatusCheckContexts.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Set status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/put(repos/set-status-check-contexts)`.
    public func reposSetStatusCheckContexts(
        path: Operations.ReposSetStatusCheckContexts.Input.Path,
        headers: Operations.ReposSetStatusCheckContexts.Input.Headers = .init(),
        body: Operations.ReposSetStatusCheckContexts.Input.Body? = nil
    ) async throws -> Operations.ReposSetStatusCheckContexts.Output {
        try await reposSetStatusCheckContexts(Operations.ReposSetStatusCheckContexts.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Remove status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/delete(repos/remove-status-check-contexts)`.
    public func reposRemoveStatusCheckContexts(
        path: Operations.ReposRemoveStatusCheckContexts.Input.Path,
        headers: Operations.ReposRemoveStatusCheckContexts.Input.Headers = .init(),
        body: Operations.ReposRemoveStatusCheckContexts.Input.Body? = nil
    ) async throws -> Operations.ReposRemoveStatusCheckContexts.Output {
        try await reposRemoveStatusCheckContexts(Operations.ReposRemoveStatusCheckContexts.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists who has access to this protected branch.
    ///
    /// > [!NOTE]
    /// > Users, apps, and teams `restrictions` are only available for organization-owned repositories.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/get(repos/get-access-restrictions)`.
    public func reposGetAccessRestrictions(
        path: Operations.ReposGetAccessRestrictions.Input.Path,
        headers: Operations.ReposGetAccessRestrictions.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAccessRestrictions.Output {
        try await reposGetAccessRestrictions(Operations.ReposGetAccessRestrictions.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Disables the ability to restrict who can push to this branch.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/delete(repos/delete-access-restrictions)`.
    public func reposDeleteAccessRestrictions(path: Operations.ReposDeleteAccessRestrictions.Input.Path) async throws -> Operations.ReposDeleteAccessRestrictions.Output {
        try await reposDeleteAccessRestrictions(Operations.ReposDeleteAccessRestrictions.Input(path: path))
    }
    /// Get apps with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the GitHub Apps that have push access to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/get(repos/get-apps-with-access-to-protected-branch)`.
    public func reposGetAppsWithAccessToProtectedBranch(
        path: Operations.ReposGetAppsWithAccessToProtectedBranch.Input.Path,
        headers: Operations.ReposGetAppsWithAccessToProtectedBranch.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAppsWithAccessToProtectedBranch.Output {
        try await reposGetAppsWithAccessToProtectedBranch(Operations.ReposGetAppsWithAccessToProtectedBranch.Input(
            path: path,
            headers: headers
        ))
    }
    /// Add app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified apps push access for this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/post(repos/add-app-access-restrictions)`.
    public func reposAddAppAccessRestrictions(
        path: Operations.ReposAddAppAccessRestrictions.Input.Path,
        headers: Operations.ReposAddAppAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposAddAppAccessRestrictions.Input.Body
    ) async throws -> Operations.ReposAddAppAccessRestrictions.Output {
        try await reposAddAppAccessRestrictions(Operations.ReposAddAppAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Set app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/put(repos/set-app-access-restrictions)`.
    public func reposSetAppAccessRestrictions(
        path: Operations.ReposSetAppAccessRestrictions.Input.Path,
        headers: Operations.ReposSetAppAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposSetAppAccessRestrictions.Input.Body
    ) async throws -> Operations.ReposSetAppAccessRestrictions.Output {
        try await reposSetAppAccessRestrictions(Operations.ReposSetAppAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Remove app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of an app to push to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/delete(repos/remove-app-access-restrictions)`.
    public func reposRemoveAppAccessRestrictions(
        path: Operations.ReposRemoveAppAccessRestrictions.Input.Path,
        headers: Operations.ReposRemoveAppAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposRemoveAppAccessRestrictions.Input.Body
    ) async throws -> Operations.ReposRemoveAppAccessRestrictions.Output {
        try await reposRemoveAppAccessRestrictions(Operations.ReposRemoveAppAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get teams with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the teams who have push access to this branch. The list includes child teams.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/get(repos/get-teams-with-access-to-protected-branch)`.
    public func reposGetTeamsWithAccessToProtectedBranch(
        path: Operations.ReposGetTeamsWithAccessToProtectedBranch.Input.Path,
        headers: Operations.ReposGetTeamsWithAccessToProtectedBranch.Input.Headers = .init()
    ) async throws -> Operations.ReposGetTeamsWithAccessToProtectedBranch.Output {
        try await reposGetTeamsWithAccessToProtectedBranch(Operations.ReposGetTeamsWithAccessToProtectedBranch.Input(
            path: path,
            headers: headers
        ))
    }
    /// Add team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified teams push access for this branch. You can also give push access to child teams.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/post(repos/add-team-access-restrictions)`.
    public func reposAddTeamAccessRestrictions(
        path: Operations.ReposAddTeamAccessRestrictions.Input.Path,
        headers: Operations.ReposAddTeamAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposAddTeamAccessRestrictions.Input.Body? = nil
    ) async throws -> Operations.ReposAddTeamAccessRestrictions.Output {
        try await reposAddTeamAccessRestrictions(Operations.ReposAddTeamAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Set team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/put(repos/set-team-access-restrictions)`.
    public func reposSetTeamAccessRestrictions(
        path: Operations.ReposSetTeamAccessRestrictions.Input.Path,
        headers: Operations.ReposSetTeamAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposSetTeamAccessRestrictions.Input.Body? = nil
    ) async throws -> Operations.ReposSetTeamAccessRestrictions.Output {
        try await reposSetTeamAccessRestrictions(Operations.ReposSetTeamAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Remove team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of a team to push to this branch. You can also remove push access for child teams.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/delete(repos/remove-team-access-restrictions)`.
    public func reposRemoveTeamAccessRestrictions(
        path: Operations.ReposRemoveTeamAccessRestrictions.Input.Path,
        headers: Operations.ReposRemoveTeamAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposRemoveTeamAccessRestrictions.Input.Body? = nil
    ) async throws -> Operations.ReposRemoveTeamAccessRestrictions.Output {
        try await reposRemoveTeamAccessRestrictions(Operations.ReposRemoveTeamAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get users with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the people who have push access to this branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/get(repos/get-users-with-access-to-protected-branch)`.
    public func reposGetUsersWithAccessToProtectedBranch(
        path: Operations.ReposGetUsersWithAccessToProtectedBranch.Input.Path,
        headers: Operations.ReposGetUsersWithAccessToProtectedBranch.Input.Headers = .init()
    ) async throws -> Operations.ReposGetUsersWithAccessToProtectedBranch.Output {
        try await reposGetUsersWithAccessToProtectedBranch(Operations.ReposGetUsersWithAccessToProtectedBranch.Input(
            path: path,
            headers: headers
        ))
    }
    /// Add user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified people push access for this branch.
    ///
    /// | Type    | Description                                                                                                                   |
    /// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/post(repos/add-user-access-restrictions)`.
    public func reposAddUserAccessRestrictions(
        path: Operations.ReposAddUserAccessRestrictions.Input.Path,
        headers: Operations.ReposAddUserAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposAddUserAccessRestrictions.Input.Body
    ) async throws -> Operations.ReposAddUserAccessRestrictions.Output {
        try await reposAddUserAccessRestrictions(Operations.ReposAddUserAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Set user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.
    ///
    /// | Type    | Description                                                                                                                   |
    /// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/put(repos/set-user-access-restrictions)`.
    public func reposSetUserAccessRestrictions(
        path: Operations.ReposSetUserAccessRestrictions.Input.Path,
        headers: Operations.ReposSetUserAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposSetUserAccessRestrictions.Input.Body
    ) async throws -> Operations.ReposSetUserAccessRestrictions.Output {
        try await reposSetUserAccessRestrictions(Operations.ReposSetUserAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Remove user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of a user to push to this branch.
    ///
    /// | Type    | Description                                                                                                                                   |
    /// | ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/delete(repos/remove-user-access-restrictions)`.
    public func reposRemoveUserAccessRestrictions(
        path: Operations.ReposRemoveUserAccessRestrictions.Input.Path,
        headers: Operations.ReposRemoveUserAccessRestrictions.Input.Headers = .init(),
        body: Operations.ReposRemoveUserAccessRestrictions.Input.Body
    ) async throws -> Operations.ReposRemoveUserAccessRestrictions.Output {
        try await reposRemoveUserAccessRestrictions(Operations.ReposRemoveUserAccessRestrictions.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Rename a branch
    ///
    /// Renames a branch in a repository.
    ///
    /// > [!NOTE]
    /// > Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".
    ///
    /// The authenticated user must have push access to the branch. If the branch is the default branch, the authenticated user must also have admin or owner permissions.
    ///
    /// In order to rename the default branch, fine-grained access tokens also need the `administration:write` repository permission.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/rename`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/rename/post(repos/rename-branch)`.
    public func reposRenameBranch(
        path: Operations.ReposRenameBranch.Input.Path,
        headers: Operations.ReposRenameBranch.Input.Headers = .init(),
        body: Operations.ReposRenameBranch.Input.Body
    ) async throws -> Operations.ReposRenameBranch.Output {
        try await reposRenameBranch(Operations.ReposRenameBranch.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List CODEOWNERS errors
    ///
    /// List any syntax errors that are detected in the CODEOWNERS
    /// file.
    ///
    /// For more information about the correct CODEOWNERS syntax,
    /// see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/codeowners/errors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/codeowners/errors/get(repos/codeowners-errors)`.
    public func reposCodeownersErrors(
        path: Operations.ReposCodeownersErrors.Input.Path,
        query: Operations.ReposCodeownersErrors.Input.Query = .init(),
        headers: Operations.ReposCodeownersErrors.Input.Headers = .init()
    ) async throws -> Operations.ReposCodeownersErrors.Output {
        try await reposCodeownersErrors(Operations.ReposCodeownersErrors.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// List repository collaborators
    ///
    /// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    /// The `permissions` hash returned in the response contains the base role permissions of the collaborator. The `role_name` is the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
    /// There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
    ///
    /// Team members will include the members of child teams.
    ///
    /// The authenticated user must have write, maintain, or admin privileges on the repository to use this endpoint. For organization-owned repositories, the authenticated user needs to be a member of the organization.
    /// OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/get(repos/list-collaborators)`.
    public func reposListCollaborators(
        path: Operations.ReposListCollaborators.Input.Path,
        query: Operations.ReposListCollaborators.Input.Query = .init(),
        headers: Operations.ReposListCollaborators.Input.Headers = .init()
    ) async throws -> Operations.ReposListCollaborators.Output {
        try await reposListCollaborators(Operations.ReposListCollaborators.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Check if a user is a repository collaborator
    ///
    /// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    ///
    /// Team members will include the members of child teams.
    ///
    /// The authenticated user must have push access to the repository to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/get(repos/check-collaborator)`.
    public func reposCheckCollaborator(path: Operations.ReposCheckCollaborator.Input.Path) async throws -> Operations.ReposCheckCollaborator.Output {
        try await reposCheckCollaborator(Operations.ReposCheckCollaborator.Input(path: path))
    }
    /// Add a repository collaborator
    ///
    /// Add a user to a repository with a specified level of access. If the repository is owned by an organization, this API does not add the user to the organization - a user that has repository access without being an organization member is called an "outside collaborator" (if they are not an Enterprise Managed User) or a "repository collaborator" if they are an Enterprise Managed User. These users are exempt from some organization policies - see "[Adding outside collaborators to repositories](https://docs.github.com/organizations/managing-user-access-to-your-organizations-repositories/managing-outside-collaborators/adding-outside-collaborators-to-repositories-in-your-organization)" to learn more about these collaborator types.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    ///
    /// Adding an outside collaborator may be restricted by enterprise and organization administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)" and "[Setting permissions for adding outside collaborators](https://docs.github.com/organizations/managing-organization-settings/setting-permissions-for-adding-outside-collaborators)" for organization settings.
    ///
    /// For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the role being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:
    ///
    /// ```
    /// Cannot assign {member} permission of {role name}
    /// ```
    ///
    /// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [API](https://docs.github.com/rest/collaborators/invitations).
    ///
    /// For Enterprise Managed Users, this endpoint does not send invitations - these users are automatically added to organizations and repositories. Enterprise Managed Users can only be added to organizations and repositories within their enterprise.
    ///
    /// **Updating an existing collaborator's permission level**
    ///
    /// The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.
    ///
    /// **Rate limits**
    ///
    /// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)`.
    public func reposAddCollaborator(
        path: Operations.ReposAddCollaborator.Input.Path,
        headers: Operations.ReposAddCollaborator.Input.Headers = .init(),
        body: Operations.ReposAddCollaborator.Input.Body? = nil
    ) async throws -> Operations.ReposAddCollaborator.Output {
        try await reposAddCollaborator(Operations.ReposAddCollaborator.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Remove a repository collaborator
    ///
    /// Removes a collaborator from a repository.
    ///
    /// To use this endpoint, the authenticated user must either be an administrator of the repository or target themselves for removal.
    ///
    /// This endpoint also:
    /// - Cancels any outstanding invitations sent by the collaborator
    /// - Unassigns the user from any issues
    /// - Removes access to organization projects if the user is not an organization member and is not a collaborator on any other organization repositories.
    /// - Unstars the repository
    /// - Updates access permissions to packages
    ///
    /// Removing a user as a collaborator has the following effects on forks:
    ///  - If the user had access to a fork through their membership to this repository, the user will also be removed from the fork.
    ///  - If the user had their own fork of the repository, the fork will be deleted.
    ///  - If the user still has read access to the repository, open pull requests by this user from a fork will be denied.
    ///
    /// > [!NOTE]
    /// > A user can still have access to the repository through organization permissions like base repository permissions.
    ///
    /// Although the API responds immediately, the additional permission updates might take some extra time to complete in the background.
    ///
    /// For more information on fork permissions, see "[About permissions and visibility of forks](https://docs.github.com/pull-requests/collaborating-with-pull-requests/working-with-forks/about-permissions-and-visibility-of-forks)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/delete(repos/remove-collaborator)`.
    public func reposRemoveCollaborator(
        path: Operations.ReposRemoveCollaborator.Input.Path,
        headers: Operations.ReposRemoveCollaborator.Input.Headers = .init()
    ) async throws -> Operations.ReposRemoveCollaborator.Output {
        try await reposRemoveCollaborator(Operations.ReposRemoveCollaborator.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get repository permissions for a user
    ///
    /// Checks the repository permission and role of a collaborator.
    ///
    /// The `permission` attribute provides the legacy base roles of `admin`, `write`, `read`, and `none`, where the
    /// `maintain` role is mapped to `write` and the `triage` role is mapped to `read`.
    /// The `role_name` attribute provides the name of the assigned role, including custom roles. The
    /// `permission` can also be used to determine which base level of access the collaborator has to the repository.
    ///
    /// The calculated permissions are the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
    /// There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators/{username}/permission`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/permission/get(repos/get-collaborator-permission-level)`.
    public func reposGetCollaboratorPermissionLevel(
        path: Operations.ReposGetCollaboratorPermissionLevel.Input.Path,
        headers: Operations.ReposGetCollaboratorPermissionLevel.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCollaboratorPermissionLevel.Output {
        try await reposGetCollaboratorPermissionLevel(Operations.ReposGetCollaboratorPermissionLevel.Input(
            path: path,
            headers: headers
        ))
    }
    /// List commit comments for a repository
    ///
    /// Lists the commit comments for a specified repository. Comments are ordered by ascending ID.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/get(repos/list-commit-comments-for-repo)`.
    public func reposListCommitCommentsForRepo(
        path: Operations.ReposListCommitCommentsForRepo.Input.Path,
        query: Operations.ReposListCommitCommentsForRepo.Input.Query = .init(),
        headers: Operations.ReposListCommitCommentsForRepo.Input.Headers = .init()
    ) async throws -> Operations.ReposListCommitCommentsForRepo.Output {
        try await reposListCommitCommentsForRepo(Operations.ReposListCommitCommentsForRepo.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get a commit comment
    ///
    /// Gets a specified commit comment.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/get(repos/get-commit-comment)`.
    public func reposGetCommitComment(
        path: Operations.ReposGetCommitComment.Input.Path,
        headers: Operations.ReposGetCommitComment.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCommitComment.Output {
        try await reposGetCommitComment(Operations.ReposGetCommitComment.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update a commit comment
    ///
    /// Updates the contents of a specified commit comment.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/patch(repos/update-commit-comment)`.
    public func reposUpdateCommitComment(
        path: Operations.ReposUpdateCommitComment.Input.Path,
        headers: Operations.ReposUpdateCommitComment.Input.Headers = .init(),
        body: Operations.ReposUpdateCommitComment.Input.Body
    ) async throws -> Operations.ReposUpdateCommitComment.Output {
        try await reposUpdateCommitComment(Operations.ReposUpdateCommitComment.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a commit comment
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/delete(repos/delete-commit-comment)`.
    public func reposDeleteCommitComment(
        path: Operations.ReposDeleteCommitComment.Input.Path,
        headers: Operations.ReposDeleteCommitComment.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteCommitComment.Output {
        try await reposDeleteCommitComment(Operations.ReposDeleteCommitComment.Input(
            path: path,
            headers: headers
        ))
    }
    /// List commits
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)`.
    public func reposListCommits(
        path: Operations.ReposListCommits.Input.Path,
        query: Operations.ReposListCommits.Input.Query = .init(),
        headers: Operations.ReposListCommits.Input.Headers = .init()
    ) async throws -> Operations.ReposListCommits.Output {
        try await reposListCommits(Operations.ReposListCommits.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// List branches for HEAD commit
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/get(repos/list-branches-for-head-commit)`.
    public func reposListBranchesForHeadCommit(
        path: Operations.ReposListBranchesForHeadCommit.Input.Path,
        headers: Operations.ReposListBranchesForHeadCommit.Input.Headers = .init()
    ) async throws -> Operations.ReposListBranchesForHeadCommit.Output {
        try await reposListBranchesForHeadCommit(Operations.ReposListBranchesForHeadCommit.Input(
            path: path,
            headers: headers
        ))
    }
    /// List commit comments
    ///
    /// Lists the comments for a specified commit.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/get(repos/list-comments-for-commit)`.
    public func reposListCommentsForCommit(
        path: Operations.ReposListCommentsForCommit.Input.Path,
        query: Operations.ReposListCommentsForCommit.Input.Query = .init(),
        headers: Operations.ReposListCommentsForCommit.Input.Headers = .init()
    ) async throws -> Operations.ReposListCommentsForCommit.Output {
        try await reposListCommentsForCommit(Operations.ReposListCommentsForCommit.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a commit comment
    ///
    /// Create a comment for a commit using its `:commit_sha`.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/commits/{commit_sha}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/post(repos/create-commit-comment)`.
    public func reposCreateCommitComment(
        path: Operations.ReposCreateCommitComment.Input.Path,
        headers: Operations.ReposCreateCommitComment.Input.Headers = .init(),
        body: Operations.ReposCreateCommitComment.Input.Body
    ) async throws -> Operations.ReposCreateCommitComment.Output {
        try await reposCreateCommitComment(Operations.ReposCreateCommitComment.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List pull requests associated with a commit
    ///
    /// Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, it will return merged and open pull requests associated with the commit.
    ///
    /// To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter to the branch name.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/pulls/get(repos/list-pull-requests-associated-with-commit)`.
    public func reposListPullRequestsAssociatedWithCommit(
        path: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Path,
        query: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Query = .init(),
        headers: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Headers = .init()
    ) async throws -> Operations.ReposListPullRequestsAssociatedWithCommit.Output {
        try await reposListPullRequestsAssociatedWithCommit(Operations.ReposListPullRequestsAssociatedWithCommit.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get a commit
    ///
    /// Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.
    ///
    /// > [!NOTE]
    /// > If there are more than 300 files in the commit diff and the default JSON media type is requested, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)." Pagination query parameters are not supported for these media types.
    ///
    /// - **`application/vnd.github.diff`**: Returns the diff of the commit. Larger diffs may time out and return a 5xx status code.
    /// - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property. Larger diffs may time out and return a 5xx status code.
    /// - **`application/vnd.github.sha`**: Returns the commit's SHA-1 hash. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)`.
    public func reposGetCommit(
        path: Operations.ReposGetCommit.Input.Path,
        query: Operations.ReposGetCommit.Input.Query = .init(),
        headers: Operations.ReposGetCommit.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCommit.Output {
        try await reposGetCommit(Operations.ReposGetCommit.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get the combined status for a specific reference
    ///
    /// Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
    ///
    ///
    /// Additionally, a combined `state` is returned. The `state` is one of:
    ///
    /// *   **failure** if any of the contexts report as `error` or `failure`
    /// *   **pending** if there are no statuses or a context is `pending`
    /// *   **success** if the latest status for all contexts is `success`
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}/status`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/status/get(repos/get-combined-status-for-ref)`.
    public func reposGetCombinedStatusForRef(
        path: Operations.ReposGetCombinedStatusForRef.Input.Path,
        query: Operations.ReposGetCombinedStatusForRef.Input.Query = .init(),
        headers: Operations.ReposGetCombinedStatusForRef.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCombinedStatusForRef.Output {
        try await reposGetCombinedStatusForRef(Operations.ReposGetCombinedStatusForRef.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// List commit statuses for a reference
    ///
    /// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.
    ///
    /// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/statuses/get(repos/list-commit-statuses-for-ref)`.
    public func reposListCommitStatusesForRef(
        path: Operations.ReposListCommitStatusesForRef.Input.Path,
        query: Operations.ReposListCommitStatusesForRef.Input.Query = .init(),
        headers: Operations.ReposListCommitStatusesForRef.Input.Headers = .init()
    ) async throws -> Operations.ReposListCommitStatusesForRef.Output {
        try await reposListCommitStatusesForRef(Operations.ReposListCommitStatusesForRef.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get community profile metrics
    ///
    /// Returns all community profile metrics for a repository. The repository cannot be a fork.
    ///
    /// The returned metrics include an overall health score, the repository description, the presence of documentation, the
    /// detected code of conduct, the detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
    /// README, and CONTRIBUTING files.
    ///
    /// The `health_percentage` score is defined as a percentage of how many of
    /// the recommended community health files are present. For more information, see
    /// "[About community profiles for public repositories](https://docs.github.com/communities/setting-up-your-project-for-healthy-contributions/about-community-profiles-for-public-repositories)."
    ///
    /// `content_reports_enabled` is only returned for organization-owned repositories.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/community/profile`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/community/profile/get(repos/get-community-profile-metrics)`.
    public func reposGetCommunityProfileMetrics(
        path: Operations.ReposGetCommunityProfileMetrics.Input.Path,
        headers: Operations.ReposGetCommunityProfileMetrics.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCommunityProfileMetrics.Output {
        try await reposGetCommunityProfileMetrics(Operations.ReposGetCommunityProfileMetrics.Input(
            path: path,
            headers: headers
        ))
    }
    /// Compare two commits
    ///
    /// Compares two commits against one another. You can compare refs (branches or tags) and commit SHAs in the same repository, or you can compare refs and commit SHAs that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
    ///
    /// This endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.diff`**: Returns the diff of the commit.
    /// - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property.
    ///
    /// The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
    ///
    /// When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.
    ///
    /// **Working with large comparisons**
    ///
    /// To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:
    ///
    /// - The list of changed files is only shown on the first page of results, and it includes up to 300 changed files for the entire comparison.
    /// - The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.
    ///
    /// For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/compare/{basehead}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)`.
    public func reposCompareCommits(
        path: Operations.ReposCompareCommits.Input.Path,
        query: Operations.ReposCompareCommits.Input.Query = .init(),
        headers: Operations.ReposCompareCommits.Input.Headers = .init()
    ) async throws -> Operations.ReposCompareCommits.Output {
        try await reposCompareCommits(Operations.ReposCompareCommits.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get repository content
    ///
    /// Gets the contents of a file or directory in a repository. Specify the file path or directory with the `path` parameter. If you omit the `path` parameter, you will receive the contents of the repository's root directory.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents for files and symlinks.
    /// - **`application/vnd.github.html+json`**: Returns the file contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    /// - **`application/vnd.github.object+json`**: Returns the contents in a consistent object format regardless of the content type. For example, instead of an array of objects for a directory, the response will be an object with an `entries` attribute containing the array of objects.
    ///
    /// If the content is a directory, the response will be an array of objects, one object for each item in the directory. When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value _should_ be "submodule". This behavior exists [for backwards compatibility purposes](https://git.io/v1YCW). In the next major version of the API, the type will be returned as "submodule".
    ///
    /// If the content is a symlink and the symlink's target is a normal file in the repository, then the API responds with the content of the file. Otherwise, the API responds with an object describing the symlink itself.
    ///
    /// If the content is a submodule, the `submodule_git_url` field identifies the location of the submodule repository, and the `sha` identifies a specific commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out the submodule at that specific commit. If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the github.com URLs (`html_url` and `_links["html"]`) will have null values.
    ///
    /// **Notes**:
    ///
    /// - To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/git/trees#get-a-tree).
    /// - This API has an upper limit of 1,000 files for a directory. If you need to retrieve
    /// more files, use the [Git Trees API](https://docs.github.com/rest/git/trees#get-a-tree).
    /// - Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
    /// - If the requested file's size is:
    ///   - 1 MB or smaller: All features of this endpoint are supported.
    ///   - Between 1-100 MB: Only the `raw` or `object` custom media types are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty
    /// string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
    ///   - Greater than 100 MB: This endpoint is not supported.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)`.
    public func reposGetContent(
        path: Operations.ReposGetContent.Input.Path,
        query: Operations.ReposGetContent.Input.Query = .init(),
        headers: Operations.ReposGetContent.Input.Headers = .init()
    ) async throws -> Operations.ReposGetContent.Output {
        try await reposGetContent(Operations.ReposGetContent.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create or update file contents
    ///
    /// Creates a new file or replaces an existing file in a repository.
    ///
    /// > [!NOTE]
    /// > If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/repos/contents/#delete-a-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The `workflow` scope is also required in order to modify files in the `.github/workflows` directory.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)`.
    public func reposCreateOrUpdateFileContents(
        path: Operations.ReposCreateOrUpdateFileContents.Input.Path,
        headers: Operations.ReposCreateOrUpdateFileContents.Input.Headers = .init(),
        body: Operations.ReposCreateOrUpdateFileContents.Input.Body
    ) async throws -> Operations.ReposCreateOrUpdateFileContents.Output {
        try await reposCreateOrUpdateFileContents(Operations.ReposCreateOrUpdateFileContents.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a file
    ///
    /// Deletes a file in a repository.
    ///
    /// You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
    ///
    /// The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
    ///
    /// You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
    ///
    /// > [!NOTE]
    /// > If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/repos/contents/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)`.
    public func reposDeleteFile(
        path: Operations.ReposDeleteFile.Input.Path,
        headers: Operations.ReposDeleteFile.Input.Headers = .init(),
        body: Operations.ReposDeleteFile.Input.Body
    ) async throws -> Operations.ReposDeleteFile.Output {
        try await reposDeleteFile(Operations.ReposDeleteFile.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List repository contributors
    ///
    /// Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
    ///
    /// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)`.
    public func reposListContributors(
        path: Operations.ReposListContributors.Input.Path,
        query: Operations.ReposListContributors.Input.Query = .init(),
        headers: Operations.ReposListContributors.Input.Headers = .init()
    ) async throws -> Operations.ReposListContributors.Output {
        try await reposListContributors(Operations.ReposListContributors.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// List deployments
    ///
    /// Simple filtering of deployments is available via query parameters:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/get(repos/list-deployments)`.
    public func reposListDeployments(
        path: Operations.ReposListDeployments.Input.Path,
        query: Operations.ReposListDeployments.Input.Query = .init(),
        headers: Operations.ReposListDeployments.Input.Headers = .init()
    ) async throws -> Operations.ReposListDeployments.Output {
        try await reposListDeployments(Operations.ReposListDeployments.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a deployment
    ///
    /// Deployments offer a few configurable parameters with certain defaults.
    ///
    /// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
    /// before we merge a pull request.
    ///
    /// The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
    /// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
    /// makes it easier to track which environments have requested deployments. The default environment is `production`.
    ///
    /// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
    /// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
    /// the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
    /// return a failure response.
    ///
    /// By default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a `success`
    /// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
    /// specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
    /// not require any contexts or create any commit statuses, the deployment will always succeed.
    ///
    /// The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
    /// field that will be passed on when a deployment event is dispatched.
    ///
    /// The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
    /// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
    /// application with debugging enabled.
    ///
    /// Merged branch response:
    ///
    /// You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
    /// a deployment. This auto-merge happens when:
    /// *   Auto-merge option is enabled in the repository
    /// *   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
    /// *   There are no merge conflicts
    ///
    /// If there are no new commits in the base branch, a new request to create a deployment should give a successful
    /// response.
    ///
    /// Merge conflict response:
    ///
    /// This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
    /// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.
    ///
    /// Failed commit status checks:
    ///
    /// This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
    /// status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)`.
    public func reposCreateDeployment(
        path: Operations.ReposCreateDeployment.Input.Path,
        headers: Operations.ReposCreateDeployment.Input.Headers = .init(),
        body: Operations.ReposCreateDeployment.Input.Body
    ) async throws -> Operations.ReposCreateDeployment.Output {
        try await reposCreateDeployment(Operations.ReposCreateDeployment.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a deployment
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/get(repos/get-deployment)`.
    public func reposGetDeployment(
        path: Operations.ReposGetDeployment.Input.Path,
        headers: Operations.ReposGetDeployment.Input.Headers = .init()
    ) async throws -> Operations.ReposGetDeployment.Output {
        try await reposGetDeployment(Operations.ReposGetDeployment.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete a deployment
    ///
    /// If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment.
    ///
    /// To set a deployment as inactive, you must:
    ///
    /// *   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
    /// *   Mark the active deployment as inactive by adding any non-successful deployment status.
    ///
    /// For more information, see "[Create a deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/deployments/statuses#create-a-deployment-status)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/deployments/{deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/delete(repos/delete-deployment)`.
    public func reposDeleteDeployment(
        path: Operations.ReposDeleteDeployment.Input.Path,
        headers: Operations.ReposDeleteDeployment.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteDeployment.Output {
        try await reposDeleteDeployment(Operations.ReposDeleteDeployment.Input(
            path: path,
            headers: headers
        ))
    }
    /// List deployment statuses
    ///
    /// Users with pull access can view deployment statuses for a deployment:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/get(repos/list-deployment-statuses)`.
    public func reposListDeploymentStatuses(
        path: Operations.ReposListDeploymentStatuses.Input.Path,
        query: Operations.ReposListDeploymentStatuses.Input.Query = .init(),
        headers: Operations.ReposListDeploymentStatuses.Input.Headers = .init()
    ) async throws -> Operations.ReposListDeploymentStatuses.Output {
        try await reposListDeploymentStatuses(Operations.ReposListDeploymentStatuses.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a deployment status
    ///
    /// Users with `push` access can create deployment statuses for a given deployment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/post(repos/create-deployment-status)`.
    public func reposCreateDeploymentStatus(
        path: Operations.ReposCreateDeploymentStatus.Input.Path,
        headers: Operations.ReposCreateDeploymentStatus.Input.Headers = .init(),
        body: Operations.ReposCreateDeploymentStatus.Input.Body
    ) async throws -> Operations.ReposCreateDeploymentStatus.Output {
        try await reposCreateDeploymentStatus(Operations.ReposCreateDeploymentStatus.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a deployment status
    ///
    /// Users with pull access can view a deployment status for a deployment:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/get(repos/get-deployment-status)`.
    public func reposGetDeploymentStatus(
        path: Operations.ReposGetDeploymentStatus.Input.Path,
        headers: Operations.ReposGetDeploymentStatus.Input.Headers = .init()
    ) async throws -> Operations.ReposGetDeploymentStatus.Output {
        try await reposGetDeploymentStatus(Operations.ReposGetDeploymentStatus.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create a repository dispatch event
    ///
    /// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
    ///
    /// The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
    ///
    /// This input example shows how you can use the `client_payload` as a test to debug your workflow.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/dispatches`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/dispatches/post(repos/create-dispatch-event)`.
    public func reposCreateDispatchEvent(
        path: Operations.ReposCreateDispatchEvent.Input.Path,
        headers: Operations.ReposCreateDispatchEvent.Input.Headers = .init(),
        body: Operations.ReposCreateDispatchEvent.Input.Body
    ) async throws -> Operations.ReposCreateDispatchEvent.Output {
        try await reposCreateDispatchEvent(Operations.ReposCreateDispatchEvent.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List environments
    ///
    /// Lists the environments for a repository.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/get(repos/get-all-environments)`.
    public func reposGetAllEnvironments(
        path: Operations.ReposGetAllEnvironments.Input.Path,
        query: Operations.ReposGetAllEnvironments.Input.Query = .init(),
        headers: Operations.ReposGetAllEnvironments.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAllEnvironments.Output {
        try await reposGetAllEnvironments(Operations.ReposGetAllEnvironments.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get an environment
    ///
    /// > [!NOTE]
    /// > To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/get(repos/get-environment)`.
    public func reposGetEnvironment(
        path: Operations.ReposGetEnvironment.Input.Path,
        headers: Operations.ReposGetEnvironment.Input.Headers = .init()
    ) async throws -> Operations.ReposGetEnvironment.Output {
        try await reposGetEnvironment(Operations.ReposGetEnvironment.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create or update an environment
    ///
    /// Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."
    ///
    /// > [!NOTE]
    /// > To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."
    ///
    /// > [!NOTE]
    /// > To create or update secrets for an environment, see "[GitHub Actions secrets](/rest/actions/secrets)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/put(repos/create-or-update-environment)`.
    public func reposCreateOrUpdateEnvironment(
        path: Operations.ReposCreateOrUpdateEnvironment.Input.Path,
        headers: Operations.ReposCreateOrUpdateEnvironment.Input.Headers = .init(),
        body: Operations.ReposCreateOrUpdateEnvironment.Input.Body? = nil
    ) async throws -> Operations.ReposCreateOrUpdateEnvironment.Output {
        try await reposCreateOrUpdateEnvironment(Operations.ReposCreateOrUpdateEnvironment.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete an environment
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/delete(repos/delete-an-environment)`.
    public func reposDeleteAnEnvironment(path: Operations.ReposDeleteAnEnvironment.Input.Path) async throws -> Operations.ReposDeleteAnEnvironment.Output {
        try await reposDeleteAnEnvironment(Operations.ReposDeleteAnEnvironment.Input(path: path))
    }
    /// List deployment branch policies
    ///
    /// Lists the deployment branch policies for an environment.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/get(repos/list-deployment-branch-policies)`.
    public func reposListDeploymentBranchPolicies(
        path: Operations.ReposListDeploymentBranchPolicies.Input.Path,
        query: Operations.ReposListDeploymentBranchPolicies.Input.Query = .init(),
        headers: Operations.ReposListDeploymentBranchPolicies.Input.Headers = .init()
    ) async throws -> Operations.ReposListDeploymentBranchPolicies.Output {
        try await reposListDeploymentBranchPolicies(Operations.ReposListDeploymentBranchPolicies.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a deployment branch policy
    ///
    /// Creates a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)`.
    public func reposCreateDeploymentBranchPolicy(
        path: Operations.ReposCreateDeploymentBranchPolicy.Input.Path,
        headers: Operations.ReposCreateDeploymentBranchPolicy.Input.Headers = .init(),
        body: Operations.ReposCreateDeploymentBranchPolicy.Input.Body
    ) async throws -> Operations.ReposCreateDeploymentBranchPolicy.Output {
        try await reposCreateDeploymentBranchPolicy(Operations.ReposCreateDeploymentBranchPolicy.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a deployment branch policy
    ///
    /// Gets a deployment branch or tag policy for an environment.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/get(repos/get-deployment-branch-policy)`.
    public func reposGetDeploymentBranchPolicy(
        path: Operations.ReposGetDeploymentBranchPolicy.Input.Path,
        headers: Operations.ReposGetDeploymentBranchPolicy.Input.Headers = .init()
    ) async throws -> Operations.ReposGetDeploymentBranchPolicy.Output {
        try await reposGetDeploymentBranchPolicy(Operations.ReposGetDeploymentBranchPolicy.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update a deployment branch policy
    ///
    /// Updates a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/put(repos/update-deployment-branch-policy)`.
    public func reposUpdateDeploymentBranchPolicy(
        path: Operations.ReposUpdateDeploymentBranchPolicy.Input.Path,
        headers: Operations.ReposUpdateDeploymentBranchPolicy.Input.Headers = .init(),
        body: Operations.ReposUpdateDeploymentBranchPolicy.Input.Body
    ) async throws -> Operations.ReposUpdateDeploymentBranchPolicy.Output {
        try await reposUpdateDeploymentBranchPolicy(Operations.ReposUpdateDeploymentBranchPolicy.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a deployment branch policy
    ///
    /// Deletes a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/delete(repos/delete-deployment-branch-policy)`.
    public func reposDeleteDeploymentBranchPolicy(path: Operations.ReposDeleteDeploymentBranchPolicy.Input.Path) async throws -> Operations.ReposDeleteDeploymentBranchPolicy.Output {
        try await reposDeleteDeploymentBranchPolicy(Operations.ReposDeleteDeploymentBranchPolicy.Input(path: path))
    }
    /// Get all deployment protection rules for an environment
    ///
    /// Gets all custom deployment protection rules that are enabled for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/get(repos/get-all-deployment-protection-rules)`.
    public func reposGetAllDeploymentProtectionRules(
        path: Operations.ReposGetAllDeploymentProtectionRules.Input.Path,
        headers: Operations.ReposGetAllDeploymentProtectionRules.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAllDeploymentProtectionRules.Output {
        try await reposGetAllDeploymentProtectionRules(Operations.ReposGetAllDeploymentProtectionRules.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create a custom deployment protection rule on an environment
    ///
    /// Enable a custom deployment protection rule for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app), as well as the [guide to creating custom deployment protection rules](https://docs.github.com/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/post(repos/create-deployment-protection-rule)`.
    public func reposCreateDeploymentProtectionRule(
        path: Operations.ReposCreateDeploymentProtectionRule.Input.Path,
        headers: Operations.ReposCreateDeploymentProtectionRule.Input.Headers = .init(),
        body: Operations.ReposCreateDeploymentProtectionRule.Input.Body
    ) async throws -> Operations.ReposCreateDeploymentProtectionRule.Output {
        try await reposCreateDeploymentProtectionRule(Operations.ReposCreateDeploymentProtectionRule.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List custom deployment rule integrations available for an environment
    ///
    /// Gets all custom deployment protection rule integrations that are available for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see "[GET an app](https://docs.github.com/rest/apps/apps#get-an-app)".
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/get(repos/list-custom-deployment-rule-integrations)`.
    public func reposListCustomDeploymentRuleIntegrations(
        path: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Path,
        query: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Query = .init(),
        headers: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Headers = .init()
    ) async throws -> Operations.ReposListCustomDeploymentRuleIntegrations.Output {
        try await reposListCustomDeploymentRuleIntegrations(Operations.ReposListCustomDeploymentRuleIntegrations.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get a custom deployment protection rule
    ///
    /// Gets an enabled custom deployment protection rule for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see [`GET /apps/{app_slug}`](https://docs.github.com/rest/apps/apps#get-an-app).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/get(repos/get-custom-deployment-protection-rule)`.
    public func reposGetCustomDeploymentProtectionRule(
        path: Operations.ReposGetCustomDeploymentProtectionRule.Input.Path,
        headers: Operations.ReposGetCustomDeploymentProtectionRule.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCustomDeploymentProtectionRule.Output {
        try await reposGetCustomDeploymentProtectionRule(Operations.ReposGetCustomDeploymentProtectionRule.Input(
            path: path,
            headers: headers
        ))
    }
    /// Disable a custom protection rule for an environment
    ///
    /// Disables a custom deployment protection rule for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/delete(repos/disable-deployment-protection-rule)`.
    public func reposDisableDeploymentProtectionRule(path: Operations.ReposDisableDeploymentProtectionRule.Input.Path) async throws -> Operations.ReposDisableDeploymentProtectionRule.Output {
        try await reposDisableDeploymentProtectionRule(Operations.ReposDisableDeploymentProtectionRule.Input(path: path))
    }
    /// List forks
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/forks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/get(repos/list-forks)`.
    public func reposListForks(
        path: Operations.ReposListForks.Input.Path,
        query: Operations.ReposListForks.Input.Query = .init(),
        headers: Operations.ReposListForks.Input.Headers = .init()
    ) async throws -> Operations.ReposListForks.Output {
        try await reposListForks(Operations.ReposListForks.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a fork
    ///
    /// Create a fork for the authenticated user.
    ///
    /// > [!NOTE]
    /// > Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
    ///
    /// > [!NOTE]
    /// > Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/forks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)`.
    public func reposCreateFork(
        path: Operations.ReposCreateFork.Input.Path,
        headers: Operations.ReposCreateFork.Input.Headers = .init(),
        body: Operations.ReposCreateFork.Input.Body? = nil
    ) async throws -> Operations.ReposCreateFork.Output {
        try await reposCreateFork(Operations.ReposCreateFork.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List repository webhooks
    ///
    /// Lists webhooks for a repository. `last response` may return null if there have not been any deliveries within 30 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/get(repos/list-webhooks)`.
    public func reposListWebhooks(
        path: Operations.ReposListWebhooks.Input.Path,
        query: Operations.ReposListWebhooks.Input.Query = .init(),
        headers: Operations.ReposListWebhooks.Input.Headers = .init()
    ) async throws -> Operations.ReposListWebhooks.Output {
        try await reposListWebhooks(Operations.ReposListWebhooks.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a repository webhook
    ///
    /// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
    /// share the same `config` as long as those webhooks do not have any `events` that overlap.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/post(repos/create-webhook)`.
    public func reposCreateWebhook(
        path: Operations.ReposCreateWebhook.Input.Path,
        headers: Operations.ReposCreateWebhook.Input.Headers = .init(),
        body: Operations.ReposCreateWebhook.Input.Body? = nil
    ) async throws -> Operations.ReposCreateWebhook.Output {
        try await reposCreateWebhook(Operations.ReposCreateWebhook.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a repository webhook
    ///
    /// Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/webhooks/repo-config#get-a-webhook-configuration-for-a-repository)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/get(repos/get-webhook)`.
    public func reposGetWebhook(
        path: Operations.ReposGetWebhook.Input.Path,
        headers: Operations.ReposGetWebhook.Input.Headers = .init()
    ) async throws -> Operations.ReposGetWebhook.Output {
        try await reposGetWebhook(Operations.ReposGetWebhook.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update a repository webhook
    ///
    /// Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/webhooks/repo-config#update-a-webhook-configuration-for-a-repository)."
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/patch(repos/update-webhook)`.
    public func reposUpdateWebhook(
        path: Operations.ReposUpdateWebhook.Input.Path,
        headers: Operations.ReposUpdateWebhook.Input.Headers = .init(),
        body: Operations.ReposUpdateWebhook.Input.Body
    ) async throws -> Operations.ReposUpdateWebhook.Output {
        try await reposUpdateWebhook(Operations.ReposUpdateWebhook.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a repository webhook
    ///
    /// Delete a webhook for an organization.
    ///
    /// The authenticated user must be a repository owner, or have admin access in the repository, to delete the webhook.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/delete(repos/delete-webhook)`.
    public func reposDeleteWebhook(
        path: Operations.ReposDeleteWebhook.Input.Path,
        headers: Operations.ReposDeleteWebhook.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteWebhook.Output {
        try await reposDeleteWebhook(Operations.ReposDeleteWebhook.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get a webhook configuration for a repository
    ///
    /// Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/webhooks/repos#get-a-repository-webhook)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `read:repo_hook` or `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/config`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/get(repos/get-webhook-config-for-repo)`.
    public func reposGetWebhookConfigForRepo(
        path: Operations.ReposGetWebhookConfigForRepo.Input.Path,
        headers: Operations.ReposGetWebhookConfigForRepo.Input.Headers = .init()
    ) async throws -> Operations.ReposGetWebhookConfigForRepo.Output {
        try await reposGetWebhookConfigForRepo(Operations.ReposGetWebhookConfigForRepo.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update a webhook configuration for a repository
    ///
    /// Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/webhooks/repos#update-a-repository-webhook)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `write:repo_hook` or `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/patch(repos/update-webhook-config-for-repo)`.
    public func reposUpdateWebhookConfigForRepo(
        path: Operations.ReposUpdateWebhookConfigForRepo.Input.Path,
        headers: Operations.ReposUpdateWebhookConfigForRepo.Input.Headers = .init(),
        body: Operations.ReposUpdateWebhookConfigForRepo.Input.Body? = nil
    ) async throws -> Operations.ReposUpdateWebhookConfigForRepo.Output {
        try await reposUpdateWebhookConfigForRepo(Operations.ReposUpdateWebhookConfigForRepo.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List deliveries for a repository webhook
    ///
    /// Returns a list of webhook deliveries for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/get(repos/list-webhook-deliveries)`.
    public func reposListWebhookDeliveries(
        path: Operations.ReposListWebhookDeliveries.Input.Path,
        query: Operations.ReposListWebhookDeliveries.Input.Query = .init(),
        headers: Operations.ReposListWebhookDeliveries.Input.Headers = .init()
    ) async throws -> Operations.ReposListWebhookDeliveries.Output {
        try await reposListWebhookDeliveries(Operations.ReposListWebhookDeliveries.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get a delivery for a repository webhook
    ///
    /// Returns a delivery for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/get(repos/get-webhook-delivery)`.
    public func reposGetWebhookDelivery(
        path: Operations.ReposGetWebhookDelivery.Input.Path,
        headers: Operations.ReposGetWebhookDelivery.Input.Headers = .init()
    ) async throws -> Operations.ReposGetWebhookDelivery.Output {
        try await reposGetWebhookDelivery(Operations.ReposGetWebhookDelivery.Input(
            path: path,
            headers: headers
        ))
    }
    /// Redeliver a delivery for a repository webhook
    ///
    /// Redeliver a webhook delivery for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/post(repos/redeliver-webhook-delivery)`.
    public func reposRedeliverWebhookDelivery(
        path: Operations.ReposRedeliverWebhookDelivery.Input.Path,
        headers: Operations.ReposRedeliverWebhookDelivery.Input.Headers = .init()
    ) async throws -> Operations.ReposRedeliverWebhookDelivery.Output {
        try await reposRedeliverWebhookDelivery(Operations.ReposRedeliverWebhookDelivery.Input(
            path: path,
            headers: headers
        ))
    }
    /// Ping a repository webhook
    ///
    /// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/pings`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/pings/post(repos/ping-webhook)`.
    public func reposPingWebhook(
        path: Operations.ReposPingWebhook.Input.Path,
        headers: Operations.ReposPingWebhook.Input.Headers = .init()
    ) async throws -> Operations.ReposPingWebhook.Output {
        try await reposPingWebhook(Operations.ReposPingWebhook.Input(
            path: path,
            headers: headers
        ))
    }
    /// Test the push repository webhook
    ///
    /// This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.
    ///
    /// > [!NOTE]
    /// > Previously `/repos/:owner/:repo/hooks/:hook_id/test`
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/tests`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/tests/post(repos/test-push-webhook)`.
    public func reposTestPushWebhook(
        path: Operations.ReposTestPushWebhook.Input.Path,
        headers: Operations.ReposTestPushWebhook.Input.Headers = .init()
    ) async throws -> Operations.ReposTestPushWebhook.Output {
        try await reposTestPushWebhook(Operations.ReposTestPushWebhook.Input(
            path: path,
            headers: headers
        ))
    }
    /// List repository invitations
    ///
    /// When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/invitations`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/get(repos/list-invitations)`.
    public func reposListInvitations(
        path: Operations.ReposListInvitations.Input.Path,
        query: Operations.ReposListInvitations.Input.Query = .init(),
        headers: Operations.ReposListInvitations.Input.Headers = .init()
    ) async throws -> Operations.ReposListInvitations.Output {
        try await reposListInvitations(Operations.ReposListInvitations.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Update a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/patch(repos/update-invitation)`.
    public func reposUpdateInvitation(
        path: Operations.ReposUpdateInvitation.Input.Path,
        headers: Operations.ReposUpdateInvitation.Input.Headers = .init(),
        body: Operations.ReposUpdateInvitation.Input.Body? = nil
    ) async throws -> Operations.ReposUpdateInvitation.Output {
        try await reposUpdateInvitation(Operations.ReposUpdateInvitation.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/delete(repos/delete-invitation)`.
    public func reposDeleteInvitation(path: Operations.ReposDeleteInvitation.Input.Path) async throws -> Operations.ReposDeleteInvitation.Output {
        try await reposDeleteInvitation(Operations.ReposDeleteInvitation.Input(path: path))
    }
    /// List deploy keys
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/keys`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/get(repos/list-deploy-keys)`.
    public func reposListDeployKeys(
        path: Operations.ReposListDeployKeys.Input.Path,
        query: Operations.ReposListDeployKeys.Input.Query = .init(),
        headers: Operations.ReposListDeployKeys.Input.Headers = .init()
    ) async throws -> Operations.ReposListDeployKeys.Output {
        try await reposListDeployKeys(Operations.ReposListDeployKeys.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a deploy key
    ///
    /// You can create a read-only deploy key.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/keys`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/post(repos/create-deploy-key)`.
    public func reposCreateDeployKey(
        path: Operations.ReposCreateDeployKey.Input.Path,
        headers: Operations.ReposCreateDeployKey.Input.Headers = .init(),
        body: Operations.ReposCreateDeployKey.Input.Body
    ) async throws -> Operations.ReposCreateDeployKey.Output {
        try await reposCreateDeployKey(Operations.ReposCreateDeployKey.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a deploy key
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/keys/{key_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/get(repos/get-deploy-key)`.
    public func reposGetDeployKey(
        path: Operations.ReposGetDeployKey.Input.Path,
        headers: Operations.ReposGetDeployKey.Input.Headers = .init()
    ) async throws -> Operations.ReposGetDeployKey.Output {
        try await reposGetDeployKey(Operations.ReposGetDeployKey.Input(
            path: path,
            headers: headers
        ))
    }
    /// Delete a deploy key
    ///
    /// Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/keys/{key_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/delete(repos/delete-deploy-key)`.
    public func reposDeleteDeployKey(path: Operations.ReposDeleteDeployKey.Input.Path) async throws -> Operations.ReposDeleteDeployKey.Output {
        try await reposDeleteDeployKey(Operations.ReposDeleteDeployKey.Input(path: path))
    }
    /// List repository languages
    ///
    /// Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/languages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/languages/get(repos/list-languages)`.
    public func reposListLanguages(
        path: Operations.ReposListLanguages.Input.Path,
        headers: Operations.ReposListLanguages.Input.Headers = .init()
    ) async throws -> Operations.ReposListLanguages.Output {
        try await reposListLanguages(Operations.ReposListLanguages.Input(
            path: path,
            headers: headers
        ))
    }
    /// Sync a fork branch with the upstream repository
    ///
    /// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/merge-upstream`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)`.
    public func reposMergeUpstream(
        path: Operations.ReposMergeUpstream.Input.Path,
        headers: Operations.ReposMergeUpstream.Input.Headers = .init(),
        body: Operations.ReposMergeUpstream.Input.Body
    ) async throws -> Operations.ReposMergeUpstream.Output {
        try await reposMergeUpstream(Operations.ReposMergeUpstream.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Merge a branch
    ///
    ///
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/merges`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)`.
    public func reposMerge(
        path: Operations.ReposMerge.Input.Path,
        headers: Operations.ReposMerge.Input.Headers = .init(),
        body: Operations.ReposMerge.Input.Body
    ) async throws -> Operations.ReposMerge.Output {
        try await reposMerge(Operations.ReposMerge.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a GitHub Pages site
    ///
    /// Gets information about a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/get(repos/get-pages)`.
    public func reposGetPages(
        path: Operations.ReposGetPages.Input.Path,
        headers: Operations.ReposGetPages.Input.Headers = .init()
    ) async throws -> Operations.ReposGetPages.Output {
        try await reposGetPages(Operations.ReposGetPages.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create a GitHub Pages site
    ///
    /// Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/post(repos/create-pages-site)`.
    public func reposCreatePagesSite(
        path: Operations.ReposCreatePagesSite.Input.Path,
        headers: Operations.ReposCreatePagesSite.Input.Headers = .init(),
        body: Operations.ReposCreatePagesSite.Input.Body
    ) async throws -> Operations.ReposCreatePagesSite.Output {
        try await reposCreatePagesSite(Operations.ReposCreatePagesSite.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Update information about a GitHub Pages site
    ///
    /// Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)`.
    public func reposUpdateInformationAboutPagesSite(
        path: Operations.ReposUpdateInformationAboutPagesSite.Input.Path,
        headers: Operations.ReposUpdateInformationAboutPagesSite.Input.Headers = .init(),
        body: Operations.ReposUpdateInformationAboutPagesSite.Input.Body
    ) async throws -> Operations.ReposUpdateInformationAboutPagesSite.Output {
        try await reposUpdateInformationAboutPagesSite(Operations.ReposUpdateInformationAboutPagesSite.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a GitHub Pages site
    ///
    /// Deletes a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)`.
    public func reposDeletePagesSite(
        path: Operations.ReposDeletePagesSite.Input.Path,
        headers: Operations.ReposDeletePagesSite.Input.Headers = .init()
    ) async throws -> Operations.ReposDeletePagesSite.Output {
        try await reposDeletePagesSite(Operations.ReposDeletePagesSite.Input(
            path: path,
            headers: headers
        ))
    }
    /// List GitHub Pages builds
    ///
    /// Lists builts of a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/get(repos/list-pages-builds)`.
    public func reposListPagesBuilds(
        path: Operations.ReposListPagesBuilds.Input.Path,
        query: Operations.ReposListPagesBuilds.Input.Query = .init(),
        headers: Operations.ReposListPagesBuilds.Input.Headers = .init()
    ) async throws -> Operations.ReposListPagesBuilds.Output {
        try await reposListPagesBuilds(Operations.ReposListPagesBuilds.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Request a GitHub Pages build
    ///
    /// You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
    ///
    /// Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/builds`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/post(repos/request-pages-build)`.
    public func reposRequestPagesBuild(
        path: Operations.ReposRequestPagesBuild.Input.Path,
        headers: Operations.ReposRequestPagesBuild.Input.Headers = .init()
    ) async throws -> Operations.ReposRequestPagesBuild.Output {
        try await reposRequestPagesBuild(Operations.ReposRequestPagesBuild.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get latest Pages build
    ///
    /// Gets information about the single most recent build of a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/latest/get(repos/get-latest-pages-build)`.
    public func reposGetLatestPagesBuild(
        path: Operations.ReposGetLatestPagesBuild.Input.Path,
        headers: Operations.ReposGetLatestPagesBuild.Input.Headers = .init()
    ) async throws -> Operations.ReposGetLatestPagesBuild.Output {
        try await reposGetLatestPagesBuild(Operations.ReposGetLatestPagesBuild.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get GitHub Pages build
    ///
    /// Gets information about a GitHub Pages build.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds/{build_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/{build_id}/get(repos/get-pages-build)`.
    public func reposGetPagesBuild(
        path: Operations.ReposGetPagesBuild.Input.Path,
        headers: Operations.ReposGetPagesBuild.Input.Headers = .init()
    ) async throws -> Operations.ReposGetPagesBuild.Output {
        try await reposGetPagesBuild(Operations.ReposGetPagesBuild.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create a GitHub Pages deployment
    ///
    /// Create a GitHub Pages deployment for a repository.
    ///
    /// The authenticated user must have write permission to the repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/post(repos/create-pages-deployment)`.
    public func reposCreatePagesDeployment(
        path: Operations.ReposCreatePagesDeployment.Input.Path,
        headers: Operations.ReposCreatePagesDeployment.Input.Headers = .init(),
        body: Operations.ReposCreatePagesDeployment.Input.Body
    ) async throws -> Operations.ReposCreatePagesDeployment.Output {
        try await reposCreatePagesDeployment(Operations.ReposCreatePagesDeployment.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get the status of a GitHub Pages deployment
    ///
    /// Gets the current status of a GitHub Pages deployment.
    ///
    /// The authenticated user must have read permission for the GitHub Pages site.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/get(repos/get-pages-deployment)`.
    public func reposGetPagesDeployment(
        path: Operations.ReposGetPagesDeployment.Input.Path,
        headers: Operations.ReposGetPagesDeployment.Input.Headers = .init()
    ) async throws -> Operations.ReposGetPagesDeployment.Output {
        try await reposGetPagesDeployment(Operations.ReposGetPagesDeployment.Input(
            path: path,
            headers: headers
        ))
    }
    /// Cancel a GitHub Pages deployment
    ///
    /// Cancels a GitHub Pages deployment.
    ///
    /// The authenticated user must have write permissions for the GitHub Pages site.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/post(repos/cancel-pages-deployment)`.
    public func reposCancelPagesDeployment(
        path: Operations.ReposCancelPagesDeployment.Input.Path,
        headers: Operations.ReposCancelPagesDeployment.Input.Headers = .init()
    ) async throws -> Operations.ReposCancelPagesDeployment.Output {
        try await reposCancelPagesDeployment(Operations.ReposCancelPagesDeployment.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get a DNS health check for GitHub Pages
    ///
    /// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.
    ///
    /// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/health`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)`.
    public func reposGetPagesHealthCheck(
        path: Operations.ReposGetPagesHealthCheck.Input.Path,
        headers: Operations.ReposGetPagesHealthCheck.Input.Headers = .init()
    ) async throws -> Operations.ReposGetPagesHealthCheck.Output {
        try await reposGetPagesHealthCheck(Operations.ReposGetPagesHealthCheck.Input(
            path: path,
            headers: headers
        ))
    }
    /// Check if private vulnerability reporting is enabled for a repository
    ///
    /// Returns a boolean indicating whether or not private vulnerability reporting is enabled for the repository. For more information, see "[Evaluating the security settings of a repository](https://docs.github.com/code-security/security-advisories/working-with-repository-security-advisories/evaluating-the-security-settings-of-a-repository)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/get(repos/check-private-vulnerability-reporting)`.
    public func reposCheckPrivateVulnerabilityReporting(
        path: Operations.ReposCheckPrivateVulnerabilityReporting.Input.Path,
        headers: Operations.ReposCheckPrivateVulnerabilityReporting.Input.Headers = .init()
    ) async throws -> Operations.ReposCheckPrivateVulnerabilityReporting.Output {
        try await reposCheckPrivateVulnerabilityReporting(Operations.ReposCheckPrivateVulnerabilityReporting.Input(
            path: path,
            headers: headers
        ))
    }
    /// Enable private vulnerability reporting for a repository
    ///
    /// Enables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)."
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/put(repos/enable-private-vulnerability-reporting)`.
    public func reposEnablePrivateVulnerabilityReporting(
        path: Operations.ReposEnablePrivateVulnerabilityReporting.Input.Path,
        headers: Operations.ReposEnablePrivateVulnerabilityReporting.Input.Headers = .init()
    ) async throws -> Operations.ReposEnablePrivateVulnerabilityReporting.Output {
        try await reposEnablePrivateVulnerabilityReporting(Operations.ReposEnablePrivateVulnerabilityReporting.Input(
            path: path,
            headers: headers
        ))
    }
    /// Disable private vulnerability reporting for a repository
    ///
    /// Disables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/delete(repos/disable-private-vulnerability-reporting)`.
    public func reposDisablePrivateVulnerabilityReporting(
        path: Operations.ReposDisablePrivateVulnerabilityReporting.Input.Path,
        headers: Operations.ReposDisablePrivateVulnerabilityReporting.Input.Headers = .init()
    ) async throws -> Operations.ReposDisablePrivateVulnerabilityReporting.Output {
        try await reposDisablePrivateVulnerabilityReporting(Operations.ReposDisablePrivateVulnerabilityReporting.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get all custom property values for a repository
    ///
    /// Gets all custom property values that are set for a repository.
    /// Users with read access to the repository can use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/properties/values`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/get(repos/get-custom-properties-values)`.
    public func reposGetCustomPropertiesValues(
        path: Operations.ReposGetCustomPropertiesValues.Input.Path,
        headers: Operations.ReposGetCustomPropertiesValues.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCustomPropertiesValues.Output {
        try await reposGetCustomPropertiesValues(Operations.ReposGetCustomPropertiesValues.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create or update custom property values for a repository
    ///
    /// Create new or update existing custom property values for a repository.
    /// Using a value of `null` for a custom property will remove or 'unset' the property value from the repository.
    ///
    /// Repository admins and other users with the repository-level "edit custom property values" fine-grained permission can use this endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/properties/values`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)`.
    public func reposCreateOrUpdateCustomPropertiesValues(
        path: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Path,
        headers: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Headers = .init(),
        body: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Body
    ) async throws -> Operations.ReposCreateOrUpdateCustomPropertiesValues.Output {
        try await reposCreateOrUpdateCustomPropertiesValues(Operations.ReposCreateOrUpdateCustomPropertiesValues.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a repository README
    ///
    /// Gets the preferred README for a repository.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
    /// - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/readme`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)`.
    public func reposGetReadme(
        path: Operations.ReposGetReadme.Input.Path,
        query: Operations.ReposGetReadme.Input.Query = .init(),
        headers: Operations.ReposGetReadme.Input.Headers = .init()
    ) async throws -> Operations.ReposGetReadme.Output {
        try await reposGetReadme(Operations.ReposGetReadme.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get a repository README for a directory
    ///
    /// Gets the README from a repository directory.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
    /// - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/readme/{dir}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/{dir}/get(repos/get-readme-in-directory)`.
    public func reposGetReadmeInDirectory(
        path: Operations.ReposGetReadmeInDirectory.Input.Path,
        query: Operations.ReposGetReadmeInDirectory.Input.Query = .init(),
        headers: Operations.ReposGetReadmeInDirectory.Input.Headers = .init()
    ) async throws -> Operations.ReposGetReadmeInDirectory.Output {
        try await reposGetReadmeInDirectory(Operations.ReposGetReadmeInDirectory.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// List releases
    ///
    /// This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).
    ///
    /// Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)`.
    public func reposListReleases(
        path: Operations.ReposListReleases.Input.Path,
        query: Operations.ReposListReleases.Input.Query = .init(),
        headers: Operations.ReposListReleases.Input.Headers = .init()
    ) async throws -> Operations.ReposListReleases.Output {
        try await reposListReleases(Operations.ReposListReleases.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a release
    ///
    /// Users with push access to the repository can create a release.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)`.
    public func reposCreateRelease(
        path: Operations.ReposCreateRelease.Input.Path,
        headers: Operations.ReposCreateRelease.Input.Headers = .init(),
        body: Operations.ReposCreateRelease.Input.Body
    ) async throws -> Operations.ReposCreateRelease.Output {
        try await reposCreateRelease(Operations.ReposCreateRelease.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get a release asset
    ///
    /// To download the asset's binary content:
    ///
    /// - If within a browser, fetch the location specified in the `browser_download_url` key provided in the response.
    /// - Alternatively, set the `Accept` header of the request to 
    ///   [`application/octet-stream`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types). 
    ///   The API will either redirect the client to the location, or stream it directly if possible.
    ///   API clients should handle both a `200` or `302` response.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/get(repos/get-release-asset)`.
    public func reposGetReleaseAsset(
        path: Operations.ReposGetReleaseAsset.Input.Path,
        headers: Operations.ReposGetReleaseAsset.Input.Headers = .init()
    ) async throws -> Operations.ReposGetReleaseAsset.Output {
        try await reposGetReleaseAsset(Operations.ReposGetReleaseAsset.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update a release asset
    ///
    /// Users with push access to the repository can edit a release asset.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/patch(repos/update-release-asset)`.
    public func reposUpdateReleaseAsset(
        path: Operations.ReposUpdateReleaseAsset.Input.Path,
        headers: Operations.ReposUpdateReleaseAsset.Input.Headers = .init(),
        body: Operations.ReposUpdateReleaseAsset.Input.Body? = nil
    ) async throws -> Operations.ReposUpdateReleaseAsset.Output {
        try await reposUpdateReleaseAsset(Operations.ReposUpdateReleaseAsset.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a release asset
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/delete(repos/delete-release-asset)`.
    public func reposDeleteReleaseAsset(path: Operations.ReposDeleteReleaseAsset.Input.Path) async throws -> Operations.ReposDeleteReleaseAsset.Output {
        try await reposDeleteReleaseAsset(Operations.ReposDeleteReleaseAsset.Input(path: path))
    }
    /// Generate release notes content for a release
    ///
    /// Generate a name and body describing a [release](https://docs.github.com/rest/releases/releases#get-a-release). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases/generate-notes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/generate-notes/post(repos/generate-release-notes)`.
    public func reposGenerateReleaseNotes(
        path: Operations.ReposGenerateReleaseNotes.Input.Path,
        headers: Operations.ReposGenerateReleaseNotes.Input.Headers = .init(),
        body: Operations.ReposGenerateReleaseNotes.Input.Body
    ) async throws -> Operations.ReposGenerateReleaseNotes.Output {
        try await reposGenerateReleaseNotes(Operations.ReposGenerateReleaseNotes.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get the latest release
    ///
    /// View the latest published full release for the repository.
    ///
    /// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)`.
    public func reposGetLatestRelease(
        path: Operations.ReposGetLatestRelease.Input.Path,
        headers: Operations.ReposGetLatestRelease.Input.Headers = .init()
    ) async throws -> Operations.ReposGetLatestRelease.Output {
        try await reposGetLatestRelease(Operations.ReposGetLatestRelease.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get a release by tag name
    ///
    /// Get a published release with the specified tag.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/tags/{tag}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/tags/{tag}/get(repos/get-release-by-tag)`.
    public func reposGetReleaseByTag(
        path: Operations.ReposGetReleaseByTag.Input.Path,
        headers: Operations.ReposGetReleaseByTag.Input.Headers = .init()
    ) async throws -> Operations.ReposGetReleaseByTag.Output {
        try await reposGetReleaseByTag(Operations.ReposGetReleaseByTag.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get a release
    ///
    /// Gets a public release with the specified release ID.
    ///
    /// > [!NOTE]
    /// > This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/get(repos/get-release)`.
    public func reposGetRelease(
        path: Operations.ReposGetRelease.Input.Path,
        headers: Operations.ReposGetRelease.Input.Headers = .init()
    ) async throws -> Operations.ReposGetRelease.Output {
        try await reposGetRelease(Operations.ReposGetRelease.Input(
            path: path,
            headers: headers
        ))
    }
    /// Update a release
    ///
    /// Users with push access to the repository can edit a release.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/patch(repos/update-release)`.
    public func reposUpdateRelease(
        path: Operations.ReposUpdateRelease.Input.Path,
        headers: Operations.ReposUpdateRelease.Input.Headers = .init(),
        body: Operations.ReposUpdateRelease.Input.Body? = nil
    ) async throws -> Operations.ReposUpdateRelease.Output {
        try await reposUpdateRelease(Operations.ReposUpdateRelease.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a release
    ///
    /// Users with push access to the repository can delete a release.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/delete(repos/delete-release)`.
    public func reposDeleteRelease(path: Operations.ReposDeleteRelease.Input.Path) async throws -> Operations.ReposDeleteRelease.Output {
        try await reposDeleteRelease(Operations.ReposDeleteRelease.Input(path: path))
    }
    /// List release assets
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/{release_id}/assets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/get(repos/list-release-assets)`.
    public func reposListReleaseAssets(
        path: Operations.ReposListReleaseAssets.Input.Path,
        query: Operations.ReposListReleaseAssets.Input.Query = .init(),
        headers: Operations.ReposListReleaseAssets.Input.Headers = .init()
    ) async throws -> Operations.ReposListReleaseAssets.Output {
        try await reposListReleaseAssets(Operations.ReposListReleaseAssets.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Upload a release asset
    ///
    /// This endpoint makes use of a [Hypermedia relation](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
    /// the response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload a release asset.
    ///
    /// You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
    ///
    /// Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example: 
    ///
    /// `application/zip`
    ///
    /// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
    /// you'll still need to pass your authentication to be able to upload an asset.
    ///
    /// When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.
    ///
    /// **Notes:**
    /// *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List release assets](https://docs.github.com/rest/releases/assets#list-release-assets)"
    /// endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
    /// *   To find the `release_id` query the [`GET /repos/{owner}/{repo}/releases/latest` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release). 
    /// *   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases/{release_id}/assets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/post(repos/upload-release-asset)`.
    public func reposUploadReleaseAsset(
        path: Operations.ReposUploadReleaseAsset.Input.Path,
        query: Operations.ReposUploadReleaseAsset.Input.Query,
        headers: Operations.ReposUploadReleaseAsset.Input.Headers = .init(),
        body: Operations.ReposUploadReleaseAsset.Input.Body? = nil
    ) async throws -> Operations.ReposUploadReleaseAsset.Output {
        try await reposUploadReleaseAsset(Operations.ReposUploadReleaseAsset.Input(
            path: path,
            query: query,
            headers: headers,
            body: body
        ))
    }
    /// Get rules for a branch
    ///
    /// Returns all active rules that apply to the specified branch. The branch does not need to exist; rules that would apply
    /// to a branch with that name will be returned. All active rules that apply will be returned, regardless of the level
    /// at which they are configured (e.g. repository or organization). Rules in rulesets with "evaluate" or "disabled"
    /// enforcement statuses are not returned.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rules/branches/{branch}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rules/branches/{branch}/get(repos/get-branch-rules)`.
    public func reposGetBranchRules(
        path: Operations.ReposGetBranchRules.Input.Path,
        query: Operations.ReposGetBranchRules.Input.Query = .init(),
        headers: Operations.ReposGetBranchRules.Input.Headers = .init()
    ) async throws -> Operations.ReposGetBranchRules.Output {
        try await reposGetBranchRules(Operations.ReposGetBranchRules.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get all repository rulesets
    ///
    /// Get all the rulesets for a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/get(repos/get-repo-rulesets)`.
    public func reposGetRepoRulesets(
        path: Operations.ReposGetRepoRulesets.Input.Path,
        query: Operations.ReposGetRepoRulesets.Input.Query = .init(),
        headers: Operations.ReposGetRepoRulesets.Input.Headers = .init()
    ) async throws -> Operations.ReposGetRepoRulesets.Output {
        try await reposGetRepoRulesets(Operations.ReposGetRepoRulesets.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Create a repository ruleset
    ///
    /// Create a ruleset for a repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/rulesets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/post(repos/create-repo-ruleset)`.
    public func reposCreateRepoRuleset(
        path: Operations.ReposCreateRepoRuleset.Input.Path,
        headers: Operations.ReposCreateRepoRuleset.Input.Headers = .init(),
        body: Operations.ReposCreateRepoRuleset.Input.Body
    ) async throws -> Operations.ReposCreateRepoRuleset.Output {
        try await reposCreateRepoRuleset(Operations.ReposCreateRepoRuleset.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List repository rule suites
    ///
    /// Lists suites of rule evaluations at the repository level.
    /// For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/rule-suites`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/get(repos/get-repo-rule-suites)`.
    public func reposGetRepoRuleSuites(
        path: Operations.ReposGetRepoRuleSuites.Input.Path,
        query: Operations.ReposGetRepoRuleSuites.Input.Query = .init(),
        headers: Operations.ReposGetRepoRuleSuites.Input.Headers = .init()
    ) async throws -> Operations.ReposGetRepoRuleSuites.Output {
        try await reposGetRepoRuleSuites(Operations.ReposGetRepoRuleSuites.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get a repository rule suite
    ///
    /// Gets information about a suite of rule evaluations from within a repository.
    /// For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-repo-rule-suite)`.
    public func reposGetRepoRuleSuite(
        path: Operations.ReposGetRepoRuleSuite.Input.Path,
        headers: Operations.ReposGetRepoRuleSuite.Input.Headers = .init()
    ) async throws -> Operations.ReposGetRepoRuleSuite.Output {
        try await reposGetRepoRuleSuite(Operations.ReposGetRepoRuleSuite.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get a repository ruleset
    ///
    /// Get a ruleset for a repository.
    ///
    /// **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
    /// making the API request has write access to the ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/get(repos/get-repo-ruleset)`.
    public func reposGetRepoRuleset(
        path: Operations.ReposGetRepoRuleset.Input.Path,
        query: Operations.ReposGetRepoRuleset.Input.Query = .init(),
        headers: Operations.ReposGetRepoRuleset.Input.Headers = .init()
    ) async throws -> Operations.ReposGetRepoRuleset.Output {
        try await reposGetRepoRuleset(Operations.ReposGetRepoRuleset.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Update a repository ruleset
    ///
    /// Update a ruleset for a repository.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/put(repos/update-repo-ruleset)`.
    public func reposUpdateRepoRuleset(
        path: Operations.ReposUpdateRepoRuleset.Input.Path,
        headers: Operations.ReposUpdateRepoRuleset.Input.Headers = .init(),
        body: Operations.ReposUpdateRepoRuleset.Input.Body? = nil
    ) async throws -> Operations.ReposUpdateRepoRuleset.Output {
        try await reposUpdateRepoRuleset(Operations.ReposUpdateRepoRuleset.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Delete a repository ruleset
    ///
    /// Delete a ruleset for a repository.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/delete(repos/delete-repo-ruleset)`.
    public func reposDeleteRepoRuleset(
        path: Operations.ReposDeleteRepoRuleset.Input.Path,
        headers: Operations.ReposDeleteRepoRuleset.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteRepoRuleset.Output {
        try await reposDeleteRepoRuleset(Operations.ReposDeleteRepoRuleset.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get repository ruleset history
    ///
    /// Get the history of a repository ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/get(repos/get-repo-ruleset-history)`.
    public func reposGetRepoRulesetHistory(
        path: Operations.ReposGetRepoRulesetHistory.Input.Path,
        query: Operations.ReposGetRepoRulesetHistory.Input.Query = .init(),
        headers: Operations.ReposGetRepoRulesetHistory.Input.Headers = .init()
    ) async throws -> Operations.ReposGetRepoRulesetHistory.Output {
        try await reposGetRepoRulesetHistory(Operations.ReposGetRepoRulesetHistory.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get repository ruleset version
    ///
    /// Get a version of a repository ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/get(repos/get-repo-ruleset-version)`.
    public func reposGetRepoRulesetVersion(
        path: Operations.ReposGetRepoRulesetVersion.Input.Path,
        headers: Operations.ReposGetRepoRulesetVersion.Input.Headers = .init()
    ) async throws -> Operations.ReposGetRepoRulesetVersion.Output {
        try await reposGetRepoRulesetVersion(Operations.ReposGetRepoRulesetVersion.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get the weekly commit activity
    ///
    /// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
    ///
    /// > [!NOTE]
    /// > This endpoint can only be used for repositories with fewer than 10,000 commits. If the repository contains 10,000 or more commits, a 422 status code will be returned.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/code_frequency`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)`.
    public func reposGetCodeFrequencyStats(
        path: Operations.ReposGetCodeFrequencyStats.Input.Path,
        headers: Operations.ReposGetCodeFrequencyStats.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCodeFrequencyStats.Output {
        try await reposGetCodeFrequencyStats(Operations.ReposGetCodeFrequencyStats.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get the last year of commit activity
    ///
    /// Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/commit_activity`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/commit_activity/get(repos/get-commit-activity-stats)`.
    public func reposGetCommitActivityStats(
        path: Operations.ReposGetCommitActivityStats.Input.Path,
        headers: Operations.ReposGetCommitActivityStats.Input.Headers = .init()
    ) async throws -> Operations.ReposGetCommitActivityStats.Output {
        try await reposGetCommitActivityStats(Operations.ReposGetCommitActivityStats.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get all contributor commit activity
    ///
    ///
    /// Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:
    ///
    /// *   `w` - Start of the week, given as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
    /// *   `a` - Number of additions
    /// *   `d` - Number of deletions
    /// *   `c` - Number of commits
    ///
    /// > [!NOTE]
    /// > This endpoint will return `0` values for all addition and deletion counts in repositories with 10,000 or more commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/contributors/get(repos/get-contributors-stats)`.
    public func reposGetContributorsStats(
        path: Operations.ReposGetContributorsStats.Input.Path,
        headers: Operations.ReposGetContributorsStats.Input.Headers = .init()
    ) async throws -> Operations.ReposGetContributorsStats.Output {
        try await reposGetContributorsStats(Operations.ReposGetContributorsStats.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get the weekly commit count
    ///
    /// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.
    ///
    /// The array order is oldest week (index 0) to most recent week.
    ///
    /// The most recent week is seven days ago at UTC midnight to today at UTC midnight.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/participation`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/participation/get(repos/get-participation-stats)`.
    public func reposGetParticipationStats(
        path: Operations.ReposGetParticipationStats.Input.Path,
        headers: Operations.ReposGetParticipationStats.Input.Headers = .init()
    ) async throws -> Operations.ReposGetParticipationStats.Output {
        try await reposGetParticipationStats(Operations.ReposGetParticipationStats.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get the hourly commit count for each day
    ///
    /// Each array contains the day number, hour number, and number of commits:
    ///
    /// *   `0-6`: Sunday - Saturday
    /// *   `0-23`: Hour of day
    /// *   Number of commits
    ///
    /// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/punch_card`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/punch_card/get(repos/get-punch-card-stats)`.
    public func reposGetPunchCardStats(
        path: Operations.ReposGetPunchCardStats.Input.Path,
        headers: Operations.ReposGetPunchCardStats.Input.Headers = .init()
    ) async throws -> Operations.ReposGetPunchCardStats.Output {
        try await reposGetPunchCardStats(Operations.ReposGetPunchCardStats.Input(
            path: path,
            headers: headers
        ))
    }
    /// Create a commit status
    ///
    /// Users with push access in a repository can create commit statuses for a given SHA.
    ///
    /// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/statuses/{sha}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/statuses/{sha}/post(repos/create-commit-status)`.
    public func reposCreateCommitStatus(
        path: Operations.ReposCreateCommitStatus.Input.Path,
        headers: Operations.ReposCreateCommitStatus.Input.Headers = .init(),
        body: Operations.ReposCreateCommitStatus.Input.Body
    ) async throws -> Operations.ReposCreateCommitStatus.Output {
        try await reposCreateCommitStatus(Operations.ReposCreateCommitStatus.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List repository tags
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/get(repos/list-tags)`.
    public func reposListTags(
        path: Operations.ReposListTags.Input.Path,
        query: Operations.ReposListTags.Input.Query = .init(),
        headers: Operations.ReposListTags.Input.Headers = .init()
    ) async throws -> Operations.ReposListTags.Output {
        try await reposListTags(Operations.ReposListTags.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Closing down - List tag protection states for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#get-all-repository-rulesets)" endpoint instead.
    ///
    /// This returns the tag protection states of a repository.
    ///
    /// This information is only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/get(repos/list-tag-protection)`.
    @available(*, deprecated)
    public func reposListTagProtection(
        path: Operations.ReposListTagProtection.Input.Path,
        headers: Operations.ReposListTagProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposListTagProtection.Output {
        try await reposListTagProtection(Operations.ReposListTagProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Closing down - Create a tag protection state for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#create-a-repository-ruleset)" endpoint instead.
    ///
    /// This creates a tag protection state for a repository.
    /// This endpoint is only available to repository administrators.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/tags/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/post(repos/create-tag-protection)`.
    @available(*, deprecated)
    public func reposCreateTagProtection(
        path: Operations.ReposCreateTagProtection.Input.Path,
        headers: Operations.ReposCreateTagProtection.Input.Headers = .init(),
        body: Operations.ReposCreateTagProtection.Input.Body
    ) async throws -> Operations.ReposCreateTagProtection.Output {
        try await reposCreateTagProtection(Operations.ReposCreateTagProtection.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Closing down - Delete a tag protection state for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#delete-a-repository-ruleset)" endpoint instead.
    ///
    /// This deletes a tag protection state for a repository.
    /// This endpoint is only available to repository administrators.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/{tag_protection_id}/delete(repos/delete-tag-protection)`.
    @available(*, deprecated)
    public func reposDeleteTagProtection(
        path: Operations.ReposDeleteTagProtection.Input.Path,
        headers: Operations.ReposDeleteTagProtection.Input.Headers = .init()
    ) async throws -> Operations.ReposDeleteTagProtection.Output {
        try await reposDeleteTagProtection(Operations.ReposDeleteTagProtection.Input(
            path: path,
            headers: headers
        ))
    }
    /// Download a repository archive (tar)
    ///
    /// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repositorys default branch (usually
    /// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    /// the `Location` header to make a second `GET` request.
    ///
    /// > [!NOTE]
    /// > For private repositories, these links are temporary and expire after five minutes.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tarball/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tarball/{ref}/get(repos/download-tarball-archive)`.
    public func reposDownloadTarballArchive(path: Operations.ReposDownloadTarballArchive.Input.Path) async throws -> Operations.ReposDownloadTarballArchive.Output {
        try await reposDownloadTarballArchive(Operations.ReposDownloadTarballArchive.Input(path: path))
    }
    /// List repository teams
    ///
    /// Lists the teams that have access to the specified repository and that are also visible to the authenticated user.
    ///
    /// For a public repository, a team is listed only if that team added the public repository explicitly.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to use this endpoint with a public repository, and `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/teams/get(repos/list-teams)`.
    public func reposListTeams(
        path: Operations.ReposListTeams.Input.Path,
        query: Operations.ReposListTeams.Input.Query = .init(),
        headers: Operations.ReposListTeams.Input.Headers = .init()
    ) async throws -> Operations.ReposListTeams.Output {
        try await reposListTeams(Operations.ReposListTeams.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get all repository topics
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/topics`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/get(repos/get-all-topics)`.
    public func reposGetAllTopics(
        path: Operations.ReposGetAllTopics.Input.Path,
        query: Operations.ReposGetAllTopics.Input.Query = .init(),
        headers: Operations.ReposGetAllTopics.Input.Headers = .init()
    ) async throws -> Operations.ReposGetAllTopics.Output {
        try await reposGetAllTopics(Operations.ReposGetAllTopics.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Replace all repository topics
    ///
    ///
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/topics`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/put(repos/replace-all-topics)`.
    public func reposReplaceAllTopics(
        path: Operations.ReposReplaceAllTopics.Input.Path,
        headers: Operations.ReposReplaceAllTopics.Input.Headers = .init(),
        body: Operations.ReposReplaceAllTopics.Input.Body
    ) async throws -> Operations.ReposReplaceAllTopics.Output {
        try await reposReplaceAllTopics(Operations.ReposReplaceAllTopics.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Get repository clones
    ///
    /// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/clones`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/clones/get(repos/get-clones)`.
    public func reposGetClones(
        path: Operations.ReposGetClones.Input.Path,
        query: Operations.ReposGetClones.Input.Query = .init(),
        headers: Operations.ReposGetClones.Input.Headers = .init()
    ) async throws -> Operations.ReposGetClones.Output {
        try await reposGetClones(Operations.ReposGetClones.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Get top referral paths
    ///
    /// Get the top 10 popular contents over the last 14 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/popular/paths`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/paths/get(repos/get-top-paths)`.
    public func reposGetTopPaths(
        path: Operations.ReposGetTopPaths.Input.Path,
        headers: Operations.ReposGetTopPaths.Input.Headers = .init()
    ) async throws -> Operations.ReposGetTopPaths.Output {
        try await reposGetTopPaths(Operations.ReposGetTopPaths.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get top referral sources
    ///
    /// Get the top 10 referrers over the last 14 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/popular/referrers`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/referrers/get(repos/get-top-referrers)`.
    public func reposGetTopReferrers(
        path: Operations.ReposGetTopReferrers.Input.Path,
        headers: Operations.ReposGetTopReferrers.Input.Headers = .init()
    ) async throws -> Operations.ReposGetTopReferrers.Output {
        try await reposGetTopReferrers(Operations.ReposGetTopReferrers.Input(
            path: path,
            headers: headers
        ))
    }
    /// Get page views
    ///
    /// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/views`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/views/get(repos/get-views)`.
    public func reposGetViews(
        path: Operations.ReposGetViews.Input.Path,
        query: Operations.ReposGetViews.Input.Query = .init(),
        headers: Operations.ReposGetViews.Input.Headers = .init()
    ) async throws -> Operations.ReposGetViews.Output {
        try await reposGetViews(Operations.ReposGetViews.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
    /// Transfer a repository
    ///
    /// A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/transfer`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/transfer/post(repos/transfer)`.
    public func reposTransfer(
        path: Operations.ReposTransfer.Input.Path,
        headers: Operations.ReposTransfer.Input.Headers = .init(),
        body: Operations.ReposTransfer.Input.Body
    ) async throws -> Operations.ReposTransfer.Output {
        try await reposTransfer(Operations.ReposTransfer.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// Check if vulnerability alerts are enabled for a repository
    ///
    /// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/get(repos/check-vulnerability-alerts)`.
    public func reposCheckVulnerabilityAlerts(path: Operations.ReposCheckVulnerabilityAlerts.Input.Path) async throws -> Operations.ReposCheckVulnerabilityAlerts.Output {
        try await reposCheckVulnerabilityAlerts(Operations.ReposCheckVulnerabilityAlerts.Input(path: path))
    }
    /// Enable vulnerability alerts
    ///
    /// Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/put(repos/enable-vulnerability-alerts)`.
    public func reposEnableVulnerabilityAlerts(path: Operations.ReposEnableVulnerabilityAlerts.Input.Path) async throws -> Operations.ReposEnableVulnerabilityAlerts.Output {
        try await reposEnableVulnerabilityAlerts(Operations.ReposEnableVulnerabilityAlerts.Input(path: path))
    }
    /// Disable vulnerability alerts
    ///
    /// Disables dependency alerts and the dependency graph for a repository.
    /// The authenticated user must have admin access to the repository. For more information,
    /// see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/delete(repos/disable-vulnerability-alerts)`.
    public func reposDisableVulnerabilityAlerts(path: Operations.ReposDisableVulnerabilityAlerts.Input.Path) async throws -> Operations.ReposDisableVulnerabilityAlerts.Output {
        try await reposDisableVulnerabilityAlerts(Operations.ReposDisableVulnerabilityAlerts.Input(path: path))
    }
    /// Download a repository archive (zip)
    ///
    /// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repositorys default branch (usually
    /// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    /// the `Location` header to make a second `GET` request.
    ///
    /// > [!NOTE]
    /// > For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you will receive a 404 when you follow the redirect.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/zipball/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/zipball/{ref}/get(repos/download-zipball-archive)`.
    public func reposDownloadZipballArchive(path: Operations.ReposDownloadZipballArchive.Input.Path) async throws -> Operations.ReposDownloadZipballArchive.Output {
        try await reposDownloadZipballArchive(Operations.ReposDownloadZipballArchive.Input(path: path))
    }
    /// Create a repository using a template
    ///
    /// Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/repos/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /repos/{template_owner}/{template_repo}/generate`.
    /// - Remark: Generated from `#/paths//repos/{template_owner}/{template_repo}/generate/post(repos/create-using-template)`.
    public func reposCreateUsingTemplate(
        path: Operations.ReposCreateUsingTemplate.Input.Path,
        headers: Operations.ReposCreateUsingTemplate.Input.Headers = .init(),
        body: Operations.ReposCreateUsingTemplate.Input.Body
    ) async throws -> Operations.ReposCreateUsingTemplate.Output {
        try await reposCreateUsingTemplate(Operations.ReposCreateUsingTemplate.Input(
            path: path,
            headers: headers,
            body: body
        ))
    }
    /// List public repositories
    ///
    /// Lists all public repositories in the order that they were created.
    ///
    /// Note:
    /// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
    /// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of repositories.
    ///
    /// - Remark: HTTP `GET /repositories`.
    /// - Remark: Generated from `#/paths//repositories/get(repos/list-public)`.
    public func reposListPublic(
        query: Operations.ReposListPublic.Input.Query = .init(),
        headers: Operations.ReposListPublic.Input.Headers = .init()
    ) async throws -> Operations.ReposListPublic.Output {
        try await reposListPublic(Operations.ReposListPublic.Input(
            query: query,
            headers: headers
        ))
    }
    /// List repositories for the authenticated user
    ///
    /// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
    ///
    /// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
    ///
    /// - Remark: HTTP `GET /user/repos`.
    /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)`.
    public func reposListForAuthenticatedUser(
        query: Operations.ReposListForAuthenticatedUser.Input.Query = .init(),
        headers: Operations.ReposListForAuthenticatedUser.Input.Headers = .init()
    ) async throws -> Operations.ReposListForAuthenticatedUser.Output {
        try await reposListForAuthenticatedUser(Operations.ReposListForAuthenticatedUser.Input(
            query: query,
            headers: headers
        ))
    }
    /// Create a repository for the authenticated user
    ///
    /// Creates a new repository for the authenticated user.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /user/repos`.
    /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)`.
    public func reposCreateForAuthenticatedUser(
        headers: Operations.ReposCreateForAuthenticatedUser.Input.Headers = .init(),
        body: Operations.ReposCreateForAuthenticatedUser.Input.Body
    ) async throws -> Operations.ReposCreateForAuthenticatedUser.Output {
        try await reposCreateForAuthenticatedUser(Operations.ReposCreateForAuthenticatedUser.Input(
            headers: headers,
            body: body
        ))
    }
    /// List repository invitations for the authenticated user
    ///
    /// When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
    ///
    /// - Remark: HTTP `GET /user/repository_invitations`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)`.
    public func reposListInvitationsForAuthenticatedUser(
        query: Operations.ReposListInvitationsForAuthenticatedUser.Input.Query = .init(),
        headers: Operations.ReposListInvitationsForAuthenticatedUser.Input.Headers = .init()
    ) async throws -> Operations.ReposListInvitationsForAuthenticatedUser.Output {
        try await reposListInvitationsForAuthenticatedUser(Operations.ReposListInvitationsForAuthenticatedUser.Input(
            query: query,
            headers: headers
        ))
    }
    /// Accept a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `PATCH /user/repository_invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)`.
    public func reposAcceptInvitationForAuthenticatedUser(
        path: Operations.ReposAcceptInvitationForAuthenticatedUser.Input.Path,
        headers: Operations.ReposAcceptInvitationForAuthenticatedUser.Input.Headers = .init()
    ) async throws -> Operations.ReposAcceptInvitationForAuthenticatedUser.Output {
        try await reposAcceptInvitationForAuthenticatedUser(Operations.ReposAcceptInvitationForAuthenticatedUser.Input(
            path: path,
            headers: headers
        ))
    }
    /// Decline a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /user/repository_invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)`.
    public func reposDeclineInvitationForAuthenticatedUser(
        path: Operations.ReposDeclineInvitationForAuthenticatedUser.Input.Path,
        headers: Operations.ReposDeclineInvitationForAuthenticatedUser.Input.Headers = .init()
    ) async throws -> Operations.ReposDeclineInvitationForAuthenticatedUser.Output {
        try await reposDeclineInvitationForAuthenticatedUser(Operations.ReposDeclineInvitationForAuthenticatedUser.Input(
            path: path,
            headers: headers
        ))
    }
    /// List repositories for a user
    ///
    /// Lists public repositories for the specified user.
    ///
    /// - Remark: HTTP `GET /users/{username}/repos`.
    /// - Remark: Generated from `#/paths//users/{username}/repos/get(repos/list-for-user)`.
    public func reposListForUser(
        path: Operations.ReposListForUser.Input.Path,
        query: Operations.ReposListForUser.Input.Query = .init(),
        headers: Operations.ReposListForUser.Input.Headers = .init()
    ) async throws -> Operations.ReposListForUser.Output {
        try await reposListForUser(Operations.ReposListForUser.Input(
            path: path,
            query: query,
            headers: headers
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {
    public enum Server1 {
        public static func url() throws -> Foundation.URL {
            try Foundation.URL(
                validatingOpenAPIServerURL: "https://api.github.com",
                variables: []
            )
        }
    }
    @available(*, deprecated, renamed: "Servers.Server1.url")
    public static func server1() throws -> Foundation.URL {
        try Foundation.URL(
            validatingOpenAPIServerURL: "https://api.github.com",
            variables: []
        )
    }
}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// A GitHub user.
        ///
        /// - Remark: Generated from `#/components/schemas/simple-user`.
        public struct SimpleUser: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/simple-user/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/simple-user/email`.
            public var email: Swift.String?
            /// - Remark: Generated from `#/components/schemas/simple-user/login`.
            public var login: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/simple-user/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/avatar_url`.
            public var avatarUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/gravatar_id`.
            public var gravatarId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/simple-user/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/followers_url`.
            public var followersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/following_url`.
            public var followingUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/gists_url`.
            public var gistsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/starred_url`.
            public var starredUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/subscriptions_url`.
            public var subscriptionsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/organizations_url`.
            public var organizationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/repos_url`.
            public var reposUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/received_events_url`.
            public var receivedEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/type`.
            public var _type: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-user/site_admin`.
            public var siteAdmin: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/simple-user/starred_at`.
            public var starredAt: Swift.String?
            /// - Remark: Generated from `#/components/schemas/simple-user/user_view_type`.
            public var userViewType: Swift.String?
            /// Creates a new `SimpleUser`.
            ///
            /// - Parameters:
            ///   - name:
            ///   - email:
            ///   - login:
            ///   - id:
            ///   - nodeId:
            ///   - avatarUrl:
            ///   - gravatarId:
            ///   - url:
            ///   - htmlUrl:
            ///   - followersUrl:
            ///   - followingUrl:
            ///   - gistsUrl:
            ///   - starredUrl:
            ///   - subscriptionsUrl:
            ///   - organizationsUrl:
            ///   - reposUrl:
            ///   - eventsUrl:
            ///   - receivedEventsUrl:
            ///   - _type:
            ///   - siteAdmin:
            ///   - starredAt:
            ///   - userViewType:
            public init(
                name: Swift.String? = nil,
                email: Swift.String? = nil,
                login: Swift.String,
                id: Swift.Int64,
                nodeId: Swift.String,
                avatarUrl: Swift.String,
                gravatarId: Swift.String? = nil,
                url: Swift.String,
                htmlUrl: Swift.String,
                followersUrl: Swift.String,
                followingUrl: Swift.String,
                gistsUrl: Swift.String,
                starredUrl: Swift.String,
                subscriptionsUrl: Swift.String,
                organizationsUrl: Swift.String,
                reposUrl: Swift.String,
                eventsUrl: Swift.String,
                receivedEventsUrl: Swift.String,
                _type: Swift.String,
                siteAdmin: Swift.Bool,
                starredAt: Swift.String? = nil,
                userViewType: Swift.String? = nil
            ) {
                self.name = name
                self.email = email
                self.login = login
                self.id = id
                self.nodeId = nodeId
                self.avatarUrl = avatarUrl
                self.gravatarId = gravatarId
                self.url = url
                self.htmlUrl = htmlUrl
                self.followersUrl = followersUrl
                self.followingUrl = followingUrl
                self.gistsUrl = gistsUrl
                self.starredUrl = starredUrl
                self.subscriptionsUrl = subscriptionsUrl
                self.organizationsUrl = organizationsUrl
                self.reposUrl = reposUrl
                self.eventsUrl = eventsUrl
                self.receivedEventsUrl = receivedEventsUrl
                self._type = _type
                self.siteAdmin = siteAdmin
                self.starredAt = starredAt
                self.userViewType = userViewType
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case email
                case login
                case id
                case nodeId = "node_id"
                case avatarUrl = "avatar_url"
                case gravatarId = "gravatar_id"
                case url
                case htmlUrl = "html_url"
                case followersUrl = "followers_url"
                case followingUrl = "following_url"
                case gistsUrl = "gists_url"
                case starredUrl = "starred_url"
                case subscriptionsUrl = "subscriptions_url"
                case organizationsUrl = "organizations_url"
                case reposUrl = "repos_url"
                case eventsUrl = "events_url"
                case receivedEventsUrl = "received_events_url"
                case _type = "type"
                case siteAdmin = "site_admin"
                case starredAt = "starred_at"
                case userViewType = "user_view_type"
            }
        }
        /// Basic Error
        ///
        /// - Remark: Generated from `#/components/schemas/basic-error`.
        public struct BasicError: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/basic-error/message`.
            public var message: Swift.String?
            /// - Remark: Generated from `#/components/schemas/basic-error/documentation_url`.
            public var documentationUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/basic-error/url`.
            public var url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/basic-error/status`.
            public var status: Swift.String?
            /// Creates a new `BasicError`.
            ///
            /// - Parameters:
            ///   - message:
            ///   - documentationUrl:
            ///   - url:
            ///   - status:
            public init(
                message: Swift.String? = nil,
                documentationUrl: Swift.String? = nil,
                url: Swift.String? = nil,
                status: Swift.String? = nil
            ) {
                self.message = message
                self.documentationUrl = documentationUrl
                self.url = url
                self.status = status
            }
            public enum CodingKeys: String, CodingKey {
                case message
                case documentationUrl = "documentation_url"
                case url
                case status
            }
        }
        /// Validation Error Simple
        ///
        /// - Remark: Generated from `#/components/schemas/validation-error-simple`.
        public struct ValidationErrorSimple: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/validation-error-simple/message`.
            public var message: Swift.String
            /// - Remark: Generated from `#/components/schemas/validation-error-simple/documentation_url`.
            public var documentationUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/validation-error-simple/errors`.
            public var errors: [Swift.String]?
            /// Creates a new `ValidationErrorSimple`.
            ///
            /// - Parameters:
            ///   - message:
            ///   - documentationUrl:
            ///   - errors:
            public init(
                message: Swift.String,
                documentationUrl: Swift.String,
                errors: [Swift.String]? = nil
            ) {
                self.message = message
                self.documentationUrl = documentationUrl
                self.errors = errors
            }
            public enum CodingKeys: String, CodingKey {
                case message
                case documentationUrl = "documentation_url"
                case errors
            }
        }
        /// An enterprise on GitHub.
        ///
        /// - Remark: Generated from `#/components/schemas/enterprise`.
        public struct Enterprise: Codable, Hashable, Sendable {
            /// A short description of the enterprise.
            ///
            /// - Remark: Generated from `#/components/schemas/enterprise/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/enterprise/html_url`.
            public var htmlUrl: Swift.String
            /// The enterprise's website URL.
            ///
            /// - Remark: Generated from `#/components/schemas/enterprise/website_url`.
            public var websiteUrl: Swift.String?
            /// Unique identifier of the enterprise
            ///
            /// - Remark: Generated from `#/components/schemas/enterprise/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/enterprise/node_id`.
            public var nodeId: Swift.String
            /// The name of the enterprise.
            ///
            /// - Remark: Generated from `#/components/schemas/enterprise/name`.
            public var name: Swift.String
            /// The slug url identifier for the enterprise.
            ///
            /// - Remark: Generated from `#/components/schemas/enterprise/slug`.
            public var slug: Swift.String
            /// - Remark: Generated from `#/components/schemas/enterprise/created_at`.
            public var createdAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/enterprise/updated_at`.
            public var updatedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/enterprise/avatar_url`.
            public var avatarUrl: Swift.String
            /// Creates a new `Enterprise`.
            ///
            /// - Parameters:
            ///   - description: A short description of the enterprise.
            ///   - htmlUrl:
            ///   - websiteUrl: The enterprise's website URL.
            ///   - id: Unique identifier of the enterprise
            ///   - nodeId:
            ///   - name: The name of the enterprise.
            ///   - slug: The slug url identifier for the enterprise.
            ///   - createdAt:
            ///   - updatedAt:
            ///   - avatarUrl:
            public init(
                description: Swift.String? = nil,
                htmlUrl: Swift.String,
                websiteUrl: Swift.String? = nil,
                id: Swift.Int,
                nodeId: Swift.String,
                name: Swift.String,
                slug: Swift.String,
                createdAt: Foundation.Date? = nil,
                updatedAt: Foundation.Date? = nil,
                avatarUrl: Swift.String
            ) {
                self.description = description
                self.htmlUrl = htmlUrl
                self.websiteUrl = websiteUrl
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.slug = slug
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.avatarUrl = avatarUrl
            }
            public enum CodingKeys: String, CodingKey {
                case description
                case htmlUrl = "html_url"
                case websiteUrl = "website_url"
                case id
                case nodeId = "node_id"
                case name
                case slug
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case avatarUrl = "avatar_url"
            }
        }
        /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
        ///
        /// - Remark: Generated from `#/components/schemas/integration`.
        public struct Integration: Codable, Hashable, Sendable {
            /// Unique identifier of the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/integration/id`.
            public var id: Swift.Int
            /// The slug name of the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/integration/slug`.
            public var slug: Swift.String?
            /// - Remark: Generated from `#/components/schemas/integration/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/integration/client_id`.
            public var clientId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/integration/owner`.
            @frozen public enum OwnerPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/integration/owner/case1`.
                case SimpleUser(Components.Schemas.SimpleUser)
                /// - Remark: Generated from `#/components/schemas/integration/owner/case2`.
                case Enterprise(Components.Schemas.Enterprise)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .SimpleUser(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .Enterprise(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .SimpleUser(value):
                        try value.encode(to: encoder)
                    case let .Enterprise(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// - Remark: Generated from `#/components/schemas/integration/owner`.
            public var owner: Components.Schemas.Integration.OwnerPayload
            /// The name of the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/integration/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/integration/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/integration/external_url`.
            public var externalUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/integration/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/integration/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/integration/updated_at`.
            public var updatedAt: Foundation.Date
            /// The set of permissions for the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/integration/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/integration/permissions/issues`.
                public var issues: Swift.String?
                /// - Remark: Generated from `#/components/schemas/integration/permissions/checks`.
                public var checks: Swift.String?
                /// - Remark: Generated from `#/components/schemas/integration/permissions/metadata`.
                public var metadata: Swift.String?
                /// - Remark: Generated from `#/components/schemas/integration/permissions/contents`.
                public var contents: Swift.String?
                /// - Remark: Generated from `#/components/schemas/integration/permissions/deployments`.
                public var deployments: Swift.String?
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - issues:
                ///   - checks:
                ///   - metadata:
                ///   - contents:
                ///   - deployments:
                ///   - additionalProperties: A container of undocumented properties.
                public init(
                    issues: Swift.String? = nil,
                    checks: Swift.String? = nil,
                    metadata: Swift.String? = nil,
                    contents: Swift.String? = nil,
                    deployments: Swift.String? = nil,
                    additionalProperties: [String: Swift.String] = .init()
                ) {
                    self.issues = issues
                    self.checks = checks
                    self.metadata = metadata
                    self.contents = contents
                    self.deployments = deployments
                    self.additionalProperties = additionalProperties
                }
                public enum CodingKeys: String, CodingKey {
                    case issues
                    case checks
                    case metadata
                    case contents
                    case deployments
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.issues = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .issues
                    )
                    self.checks = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .checks
                    )
                    self.metadata = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .metadata
                    )
                    self.contents = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .contents
                    )
                    self.deployments = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .deployments
                    )
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                        "issues",
                        "checks",
                        "metadata",
                        "contents",
                        "deployments"
                    ])
                }
                public func encode(to encoder: any Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)
                    try container.encodeIfPresent(
                        self.issues,
                        forKey: .issues
                    )
                    try container.encodeIfPresent(
                        self.checks,
                        forKey: .checks
                    )
                    try container.encodeIfPresent(
                        self.metadata,
                        forKey: .metadata
                    )
                    try container.encodeIfPresent(
                        self.contents,
                        forKey: .contents
                    )
                    try container.encodeIfPresent(
                        self.deployments,
                        forKey: .deployments
                    )
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// The set of permissions for the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/integration/permissions`.
            public var permissions: Components.Schemas.Integration.PermissionsPayload
            /// The list of events for the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/integration/events`.
            public var events: [Swift.String]
            /// The number of installations associated with the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/integration/installations_count`.
            public var installationsCount: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/integration/client_secret`.
            public var clientSecret: Swift.String?
            /// - Remark: Generated from `#/components/schemas/integration/webhook_secret`.
            public var webhookSecret: Swift.String?
            /// - Remark: Generated from `#/components/schemas/integration/pem`.
            public var pem: Swift.String?
            /// Creates a new `Integration`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the GitHub app
            ///   - slug: The slug name of the GitHub app
            ///   - nodeId:
            ///   - clientId:
            ///   - owner:
            ///   - name: The name of the GitHub app
            ///   - description:
            ///   - externalUrl:
            ///   - htmlUrl:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - permissions: The set of permissions for the GitHub app
            ///   - events: The list of events for the GitHub app
            ///   - installationsCount: The number of installations associated with the GitHub app
            ///   - clientSecret:
            ///   - webhookSecret:
            ///   - pem:
            public init(
                id: Swift.Int,
                slug: Swift.String? = nil,
                nodeId: Swift.String,
                clientId: Swift.String? = nil,
                owner: Components.Schemas.Integration.OwnerPayload,
                name: Swift.String,
                description: Swift.String? = nil,
                externalUrl: Swift.String,
                htmlUrl: Swift.String,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                permissions: Components.Schemas.Integration.PermissionsPayload,
                events: [Swift.String],
                installationsCount: Swift.Int? = nil,
                clientSecret: Swift.String? = nil,
                webhookSecret: Swift.String? = nil,
                pem: Swift.String? = nil
            ) {
                self.id = id
                self.slug = slug
                self.nodeId = nodeId
                self.clientId = clientId
                self.owner = owner
                self.name = name
                self.description = description
                self.externalUrl = externalUrl
                self.htmlUrl = htmlUrl
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.permissions = permissions
                self.events = events
                self.installationsCount = installationsCount
                self.clientSecret = clientSecret
                self.webhookSecret = webhookSecret
                self.pem = pem
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case slug
                case nodeId = "node_id"
                case clientId = "client_id"
                case owner
                case name
                case description
                case externalUrl = "external_url"
                case htmlUrl = "html_url"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case permissions
                case events
                case installationsCount = "installations_count"
                case clientSecret = "client_secret"
                case webhookSecret = "webhook_secret"
                case pem
            }
        }
        /// The URL to which the payloads will be delivered.
        ///
        /// - Remark: Generated from `#/components/schemas/webhook-config-url`.
        public typealias WebhookConfigUrl = Swift.String
        /// The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.
        ///
        /// - Remark: Generated from `#/components/schemas/webhook-config-content-type`.
        public typealias WebhookConfigContentType = Swift.String
        /// If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).
        ///
        /// - Remark: Generated from `#/components/schemas/webhook-config-secret`.
        public typealias WebhookConfigSecret = Swift.String
        /// - Remark: Generated from `#/components/schemas/webhook-config-insecure-ssl`.
        @frozen public enum WebhookConfigInsecureSsl: Codable, Hashable, Sendable {
            /// Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**
            ///
            /// - Remark: Generated from `#/components/schemas/webhook-config-insecure-ssl/case1`.
            case case1(Swift.String)
            /// - Remark: Generated from `#/components/schemas/webhook-config-insecure-ssl/case2`.
            case case2(Swift.Double)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .case1(try decoder.decodeFromSingleValueContainer())
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case2(try decoder.decodeFromSingleValueContainer())
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .case1(value):
                    try encoder.encodeToSingleValueContainer(value)
                case let .case2(value):
                    try encoder.encodeToSingleValueContainer(value)
                }
            }
        }
        /// Configuration object of the webhook
        ///
        /// - Remark: Generated from `#/components/schemas/webhook-config`.
        public struct WebhookConfig: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/webhook-config/url`.
            public var url: Components.Schemas.WebhookConfigUrl?
            /// - Remark: Generated from `#/components/schemas/webhook-config/content_type`.
            public var contentType: Components.Schemas.WebhookConfigContentType?
            /// - Remark: Generated from `#/components/schemas/webhook-config/secret`.
            public var secret: Components.Schemas.WebhookConfigSecret?
            /// - Remark: Generated from `#/components/schemas/webhook-config/insecure_ssl`.
            public var insecureSsl: Components.Schemas.WebhookConfigInsecureSsl?
            /// Creates a new `WebhookConfig`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - contentType:
            ///   - secret:
            ///   - insecureSsl:
            public init(
                url: Components.Schemas.WebhookConfigUrl? = nil,
                contentType: Components.Schemas.WebhookConfigContentType? = nil,
                secret: Components.Schemas.WebhookConfigSecret? = nil,
                insecureSsl: Components.Schemas.WebhookConfigInsecureSsl? = nil
            ) {
                self.url = url
                self.contentType = contentType
                self.secret = secret
                self.insecureSsl = insecureSsl
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case contentType = "content_type"
                case secret
                case insecureSsl = "insecure_ssl"
            }
        }
        /// Delivery made by a webhook, without request and response information.
        ///
        /// - Remark: Generated from `#/components/schemas/hook-delivery-item`.
        public struct HookDeliveryItem: Codable, Hashable, Sendable {
            /// Unique identifier of the webhook delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/id`.
            public var id: Swift.Int64
            /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/guid`.
            public var guid: Swift.String
            /// Time when the webhook delivery occurred.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/delivered_at`.
            public var deliveredAt: Foundation.Date
            /// Whether the webhook delivery is a redelivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/redelivery`.
            public var redelivery: Swift.Bool
            /// Time spent delivering.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/duration`.
            public var duration: Swift.Double
            /// Describes the response returned after attempting the delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/status`.
            public var status: Swift.String
            /// Status code received when delivery was made.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/status_code`.
            public var statusCode: Swift.Int
            /// The event that triggered the delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/event`.
            public var event: Swift.String
            /// The type of activity for the event that triggered the delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/action`.
            public var action: Swift.String?
            /// The id of the GitHub App installation associated with this event.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/installation_id`.
            public var installationId: Swift.Int64?
            /// The id of the repository associated with this event.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/repository_id`.
            public var repositoryId: Swift.Int64?
            /// Time when the webhook delivery was throttled.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery-item/throttled_at`.
            public var throttledAt: Foundation.Date?
            /// Creates a new `HookDeliveryItem`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the webhook delivery.
            ///   - guid: Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
            ///   - deliveredAt: Time when the webhook delivery occurred.
            ///   - redelivery: Whether the webhook delivery is a redelivery.
            ///   - duration: Time spent delivering.
            ///   - status: Describes the response returned after attempting the delivery.
            ///   - statusCode: Status code received when delivery was made.
            ///   - event: The event that triggered the delivery.
            ///   - action: The type of activity for the event that triggered the delivery.
            ///   - installationId: The id of the GitHub App installation associated with this event.
            ///   - repositoryId: The id of the repository associated with this event.
            ///   - throttledAt: Time when the webhook delivery was throttled.
            public init(
                id: Swift.Int64,
                guid: Swift.String,
                deliveredAt: Foundation.Date,
                redelivery: Swift.Bool,
                duration: Swift.Double,
                status: Swift.String,
                statusCode: Swift.Int,
                event: Swift.String,
                action: Swift.String? = nil,
                installationId: Swift.Int64? = nil,
                repositoryId: Swift.Int64? = nil,
                throttledAt: Foundation.Date? = nil
            ) {
                self.id = id
                self.guid = guid
                self.deliveredAt = deliveredAt
                self.redelivery = redelivery
                self.duration = duration
                self.status = status
                self.statusCode = statusCode
                self.event = event
                self.action = action
                self.installationId = installationId
                self.repositoryId = repositoryId
                self.throttledAt = throttledAt
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case guid
                case deliveredAt = "delivered_at"
                case redelivery
                case duration
                case status
                case statusCode = "status_code"
                case event
                case action
                case installationId = "installation_id"
                case repositoryId = "repository_id"
                case throttledAt = "throttled_at"
            }
        }
        /// Scim Error
        ///
        /// - Remark: Generated from `#/components/schemas/scim-error`.
        public struct ScimError: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/scim-error/message`.
            public var message: Swift.String?
            /// - Remark: Generated from `#/components/schemas/scim-error/documentation_url`.
            public var documentationUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/scim-error/detail`.
            public var detail: Swift.String?
            /// - Remark: Generated from `#/components/schemas/scim-error/status`.
            public var status: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/scim-error/scimType`.
            public var scimType: Swift.String?
            /// - Remark: Generated from `#/components/schemas/scim-error/schemas`.
            public var schemas: [Swift.String]?
            /// Creates a new `ScimError`.
            ///
            /// - Parameters:
            ///   - message:
            ///   - documentationUrl:
            ///   - detail:
            ///   - status:
            ///   - scimType:
            ///   - schemas:
            public init(
                message: Swift.String? = nil,
                documentationUrl: Swift.String? = nil,
                detail: Swift.String? = nil,
                status: Swift.Int? = nil,
                scimType: Swift.String? = nil,
                schemas: [Swift.String]? = nil
            ) {
                self.message = message
                self.documentationUrl = documentationUrl
                self.detail = detail
                self.status = status
                self.scimType = scimType
                self.schemas = schemas
            }
            public enum CodingKeys: String, CodingKey {
                case message
                case documentationUrl = "documentation_url"
                case detail
                case status
                case scimType
                case schemas
            }
        }
        /// Validation Error
        ///
        /// - Remark: Generated from `#/components/schemas/validation-error`.
        public struct ValidationError: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/validation-error/message`.
            public var message: Swift.String
            /// - Remark: Generated from `#/components/schemas/validation-error/documentation_url`.
            public var documentationUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload`.
            public struct ErrorsPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/resource`.
                public var resource: Swift.String?
                /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/field`.
                public var field: Swift.String?
                /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/message`.
                public var message: Swift.String?
                /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/code`.
                public var code: Swift.String
                /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/index`.
                public var index: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/value`.
                @frozen public enum ValuePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/value/case1`.
                    case case1(Swift.String?)
                    /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/value/case2`.
                    case case2(Swift.Int?)
                    /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/value/case3`.
                    case case3([Swift.String]?)
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case3(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try encoder.encodeToSingleValueContainer(value)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        case let .case3(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// - Remark: Generated from `#/components/schemas/validation-error/ErrorsPayload/value`.
                public var value: Components.Schemas.ValidationError.ErrorsPayloadPayload.ValuePayload?
                /// Creates a new `ErrorsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - resource:
                ///   - field:
                ///   - message:
                ///   - code:
                ///   - index:
                ///   - value:
                public init(
                    resource: Swift.String? = nil,
                    field: Swift.String? = nil,
                    message: Swift.String? = nil,
                    code: Swift.String,
                    index: Swift.Int? = nil,
                    value: Components.Schemas.ValidationError.ErrorsPayloadPayload.ValuePayload? = nil
                ) {
                    self.resource = resource
                    self.field = field
                    self.message = message
                    self.code = code
                    self.index = index
                    self.value = value
                }
                public enum CodingKeys: String, CodingKey {
                    case resource
                    case field
                    case message
                    case code
                    case index
                    case value
                }
            }
            /// - Remark: Generated from `#/components/schemas/validation-error/errors`.
            public typealias ErrorsPayload = [Components.Schemas.ValidationError.ErrorsPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/validation-error/errors`.
            public var errors: Components.Schemas.ValidationError.ErrorsPayload?
            /// Creates a new `ValidationError`.
            ///
            /// - Parameters:
            ///   - message:
            ///   - documentationUrl:
            ///   - errors:
            public init(
                message: Swift.String,
                documentationUrl: Swift.String,
                errors: Components.Schemas.ValidationError.ErrorsPayload? = nil
            ) {
                self.message = message
                self.documentationUrl = documentationUrl
                self.errors = errors
            }
            public enum CodingKeys: String, CodingKey {
                case message
                case documentationUrl = "documentation_url"
                case errors
            }
        }
        /// Delivery made by a webhook.
        ///
        /// - Remark: Generated from `#/components/schemas/hook-delivery`.
        public struct HookDelivery: Codable, Hashable, Sendable {
            /// Unique identifier of the delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/id`.
            public var id: Swift.Int
            /// Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/guid`.
            public var guid: Swift.String
            /// Time when the delivery was delivered.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/delivered_at`.
            public var deliveredAt: Foundation.Date
            /// Whether the delivery is a redelivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/redelivery`.
            public var redelivery: Swift.Bool
            /// Time spent delivering.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/duration`.
            public var duration: Swift.Double
            /// Description of the status of the attempted delivery
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/status`.
            public var status: Swift.String
            /// Status code received when delivery was made.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/status_code`.
            public var statusCode: Swift.Int
            /// The event that triggered the delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/event`.
            public var event: Swift.String
            /// The type of activity for the event that triggered the delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/action`.
            public var action: Swift.String?
            /// The id of the GitHub App installation associated with this event.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/installation_id`.
            public var installationId: Swift.Int?
            /// The id of the repository associated with this event.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/repository_id`.
            public var repositoryId: Swift.Int?
            /// Time when the webhook delivery was throttled.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/throttled_at`.
            public var throttledAt: Foundation.Date?
            /// The URL target of the delivery.
            ///
            /// - Remark: Generated from `#/components/schemas/hook-delivery/url`.
            public var url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/hook-delivery/request`.
            public struct RequestPayload: Codable, Hashable, Sendable {
                /// The request headers sent with the webhook delivery.
                ///
                /// - Remark: Generated from `#/components/schemas/hook-delivery/request/headers`.
                public struct HeadersPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `HeadersPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// The request headers sent with the webhook delivery.
                ///
                /// - Remark: Generated from `#/components/schemas/hook-delivery/request/headers`.
                public var headers: Components.Schemas.HookDelivery.RequestPayload.HeadersPayload?
                /// The webhook payload.
                ///
                /// - Remark: Generated from `#/components/schemas/hook-delivery/request/payload`.
                public struct PayloadPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `PayloadPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// The webhook payload.
                ///
                /// - Remark: Generated from `#/components/schemas/hook-delivery/request/payload`.
                public var payload: Components.Schemas.HookDelivery.RequestPayload.PayloadPayload?
                /// Creates a new `RequestPayload`.
                ///
                /// - Parameters:
                ///   - headers: The request headers sent with the webhook delivery.
                ///   - payload: The webhook payload.
                public init(
                    headers: Components.Schemas.HookDelivery.RequestPayload.HeadersPayload? = nil,
                    payload: Components.Schemas.HookDelivery.RequestPayload.PayloadPayload? = nil
                ) {
                    self.headers = headers
                    self.payload = payload
                }
                public enum CodingKeys: String, CodingKey {
                    case headers
                    case payload
                }
            }
            /// - Remark: Generated from `#/components/schemas/hook-delivery/request`.
            public var request: Components.Schemas.HookDelivery.RequestPayload
            /// - Remark: Generated from `#/components/schemas/hook-delivery/response`.
            public struct ResponsePayload: Codable, Hashable, Sendable {
                /// The response headers received when the delivery was made.
                ///
                /// - Remark: Generated from `#/components/schemas/hook-delivery/response/headers`.
                public struct HeadersPayload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `HeadersPayload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// The response headers received when the delivery was made.
                ///
                /// - Remark: Generated from `#/components/schemas/hook-delivery/response/headers`.
                public var headers: Components.Schemas.HookDelivery.ResponsePayload.HeadersPayload?
                /// The response payload received.
                ///
                /// - Remark: Generated from `#/components/schemas/hook-delivery/response/payload`.
                public var payload: Swift.String?
                /// Creates a new `ResponsePayload`.
                ///
                /// - Parameters:
                ///   - headers: The response headers received when the delivery was made.
                ///   - payload: The response payload received.
                public init(
                    headers: Components.Schemas.HookDelivery.ResponsePayload.HeadersPayload? = nil,
                    payload: Swift.String? = nil
                ) {
                    self.headers = headers
                    self.payload = payload
                }
                public enum CodingKeys: String, CodingKey {
                    case headers
                    case payload
                }
            }
            /// - Remark: Generated from `#/components/schemas/hook-delivery/response`.
            public var response: Components.Schemas.HookDelivery.ResponsePayload
            /// Creates a new `HookDelivery`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the delivery.
            ///   - guid: Unique identifier for the event (shared with all deliveries for all webhooks that subscribe to this event).
            ///   - deliveredAt: Time when the delivery was delivered.
            ///   - redelivery: Whether the delivery is a redelivery.
            ///   - duration: Time spent delivering.
            ///   - status: Description of the status of the attempted delivery
            ///   - statusCode: Status code received when delivery was made.
            ///   - event: The event that triggered the delivery.
            ///   - action: The type of activity for the event that triggered the delivery.
            ///   - installationId: The id of the GitHub App installation associated with this event.
            ///   - repositoryId: The id of the repository associated with this event.
            ///   - throttledAt: Time when the webhook delivery was throttled.
            ///   - url: The URL target of the delivery.
            ///   - request:
            ///   - response:
            public init(
                id: Swift.Int,
                guid: Swift.String,
                deliveredAt: Foundation.Date,
                redelivery: Swift.Bool,
                duration: Swift.Double,
                status: Swift.String,
                statusCode: Swift.Int,
                event: Swift.String,
                action: Swift.String? = nil,
                installationId: Swift.Int? = nil,
                repositoryId: Swift.Int? = nil,
                throttledAt: Foundation.Date? = nil,
                url: Swift.String? = nil,
                request: Components.Schemas.HookDelivery.RequestPayload,
                response: Components.Schemas.HookDelivery.ResponsePayload
            ) {
                self.id = id
                self.guid = guid
                self.deliveredAt = deliveredAt
                self.redelivery = redelivery
                self.duration = duration
                self.status = status
                self.statusCode = statusCode
                self.event = event
                self.action = action
                self.installationId = installationId
                self.repositoryId = repositoryId
                self.throttledAt = throttledAt
                self.url = url
                self.request = request
                self.response = response
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case guid
                case deliveredAt = "delivered_at"
                case redelivery
                case duration
                case status
                case statusCode = "status_code"
                case event
                case action
                case installationId = "installation_id"
                case repositoryId = "repository_id"
                case throttledAt = "throttled_at"
                case url
                case request
                case response
            }
        }
        /// A GitHub user.
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-simple-user`.
        public struct NullableSimpleUser: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/email`.
            public var email: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/login`.
            public var login: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/avatar_url`.
            public var avatarUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/gravatar_id`.
            public var gravatarId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/followers_url`.
            public var followersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/following_url`.
            public var followingUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/gists_url`.
            public var gistsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/starred_url`.
            public var starredUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/subscriptions_url`.
            public var subscriptionsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/organizations_url`.
            public var organizationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/repos_url`.
            public var reposUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/received_events_url`.
            public var receivedEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/type`.
            public var _type: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/site_admin`.
            public var siteAdmin: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/starred_at`.
            public var starredAt: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-simple-user/user_view_type`.
            public var userViewType: Swift.String?
            /// Creates a new `NullableSimpleUser`.
            ///
            /// - Parameters:
            ///   - name:
            ///   - email:
            ///   - login:
            ///   - id:
            ///   - nodeId:
            ///   - avatarUrl:
            ///   - gravatarId:
            ///   - url:
            ///   - htmlUrl:
            ///   - followersUrl:
            ///   - followingUrl:
            ///   - gistsUrl:
            ///   - starredUrl:
            ///   - subscriptionsUrl:
            ///   - organizationsUrl:
            ///   - reposUrl:
            ///   - eventsUrl:
            ///   - receivedEventsUrl:
            ///   - _type:
            ///   - siteAdmin:
            ///   - starredAt:
            ///   - userViewType:
            public init(
                name: Swift.String? = nil,
                email: Swift.String? = nil,
                login: Swift.String,
                id: Swift.Int64,
                nodeId: Swift.String,
                avatarUrl: Swift.String,
                gravatarId: Swift.String? = nil,
                url: Swift.String,
                htmlUrl: Swift.String,
                followersUrl: Swift.String,
                followingUrl: Swift.String,
                gistsUrl: Swift.String,
                starredUrl: Swift.String,
                subscriptionsUrl: Swift.String,
                organizationsUrl: Swift.String,
                reposUrl: Swift.String,
                eventsUrl: Swift.String,
                receivedEventsUrl: Swift.String,
                _type: Swift.String,
                siteAdmin: Swift.Bool,
                starredAt: Swift.String? = nil,
                userViewType: Swift.String? = nil
            ) {
                self.name = name
                self.email = email
                self.login = login
                self.id = id
                self.nodeId = nodeId
                self.avatarUrl = avatarUrl
                self.gravatarId = gravatarId
                self.url = url
                self.htmlUrl = htmlUrl
                self.followersUrl = followersUrl
                self.followingUrl = followingUrl
                self.gistsUrl = gistsUrl
                self.starredUrl = starredUrl
                self.subscriptionsUrl = subscriptionsUrl
                self.organizationsUrl = organizationsUrl
                self.reposUrl = reposUrl
                self.eventsUrl = eventsUrl
                self.receivedEventsUrl = receivedEventsUrl
                self._type = _type
                self.siteAdmin = siteAdmin
                self.starredAt = starredAt
                self.userViewType = userViewType
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case email
                case login
                case id
                case nodeId = "node_id"
                case avatarUrl = "avatar_url"
                case gravatarId = "gravatar_id"
                case url
                case htmlUrl = "html_url"
                case followersUrl = "followers_url"
                case followingUrl = "following_url"
                case gistsUrl = "gists_url"
                case starredUrl = "starred_url"
                case subscriptionsUrl = "subscriptions_url"
                case organizationsUrl = "organizations_url"
                case reposUrl = "repos_url"
                case eventsUrl = "events_url"
                case receivedEventsUrl = "received_events_url"
                case _type = "type"
                case siteAdmin = "site_admin"
                case starredAt = "starred_at"
                case userViewType = "user_view_type"
            }
        }
        /// License Simple
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-license-simple`.
        public struct NullableLicenseSimple: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/nullable-license-simple/key`.
            public var key: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-license-simple/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-license-simple/url`.
            public var url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-license-simple/spdx_id`.
            public var spdxId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-license-simple/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-license-simple/html_url`.
            public var htmlUrl: Swift.String?
            /// Creates a new `NullableLicenseSimple`.
            ///
            /// - Parameters:
            ///   - key:
            ///   - name:
            ///   - url:
            ///   - spdxId:
            ///   - nodeId:
            ///   - htmlUrl:
            public init(
                key: Swift.String,
                name: Swift.String,
                url: Swift.String? = nil,
                spdxId: Swift.String? = nil,
                nodeId: Swift.String,
                htmlUrl: Swift.String? = nil
            ) {
                self.key = key
                self.name = name
                self.url = url
                self.spdxId = spdxId
                self.nodeId = nodeId
                self.htmlUrl = htmlUrl
            }
            public enum CodingKeys: String, CodingKey {
                case key
                case name
                case url
                case spdxId = "spdx_id"
                case nodeId = "node_id"
                case htmlUrl = "html_url"
            }
        }
        /// A repository on GitHub.
        ///
        /// - Remark: Generated from `#/components/schemas/repository`.
        public struct Repository: Codable, Hashable, Sendable {
            /// Unique identifier of the repository
            ///
            /// - Remark: Generated from `#/components/schemas/repository/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/repository/node_id`.
            public var nodeId: Swift.String
            /// The name of the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/full_name`.
            public var fullName: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/license`.
            public var license: Components.Schemas.NullableLicenseSimple?
            /// - Remark: Generated from `#/components/schemas/repository/forks`.
            public var forks: Swift.Int
            /// - Remark: Generated from `#/components/schemas/repository/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository/permissions/admin`.
                public var admin: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/repository/permissions/pull`.
                public var pull: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/repository/permissions/triage`.
                public var triage: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/repository/permissions/push`.
                public var push: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/repository/permissions/maintain`.
                public var maintain: Swift.Bool?
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - admin:
                ///   - pull:
                ///   - triage:
                ///   - push:
                ///   - maintain:
                public init(
                    admin: Swift.Bool,
                    pull: Swift.Bool,
                    triage: Swift.Bool? = nil,
                    push: Swift.Bool,
                    maintain: Swift.Bool? = nil
                ) {
                    self.admin = admin
                    self.pull = pull
                    self.triage = triage
                    self.push = push
                    self.maintain = maintain
                }
                public enum CodingKeys: String, CodingKey {
                    case admin
                    case pull
                    case triage
                    case push
                    case maintain
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository/permissions`.
            public var permissions: Components.Schemas.Repository.PermissionsPayload?
            /// - Remark: Generated from `#/components/schemas/repository/owner`.
            public var owner: Components.Schemas.SimpleUser
            /// Whether the repository is private or public.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/private`.
            public var _private: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/repository/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository/fork`.
            public var fork: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/repository/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/archive_url`.
            public var archiveUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/assignees_url`.
            public var assigneesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/blobs_url`.
            public var blobsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/branches_url`.
            public var branchesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/collaborators_url`.
            public var collaboratorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/comments_url`.
            public var commentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/commits_url`.
            public var commitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/compare_url`.
            public var compareUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/contents_url`.
            public var contentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/contributors_url`.
            public var contributorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/deployments_url`.
            public var deploymentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/downloads_url`.
            public var downloadsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/forks_url`.
            public var forksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/git_commits_url`.
            public var gitCommitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/git_refs_url`.
            public var gitRefsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/git_tags_url`.
            public var gitTagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/git_url`.
            public var gitUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/issue_comment_url`.
            public var issueCommentUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/issue_events_url`.
            public var issueEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/issues_url`.
            public var issuesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/keys_url`.
            public var keysUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/labels_url`.
            public var labelsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/languages_url`.
            public var languagesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/merges_url`.
            public var mergesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/milestones_url`.
            public var milestonesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/notifications_url`.
            public var notificationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/pulls_url`.
            public var pullsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/releases_url`.
            public var releasesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/ssh_url`.
            public var sshUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/stargazers_url`.
            public var stargazersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/statuses_url`.
            public var statusesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/subscribers_url`.
            public var subscribersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/subscription_url`.
            public var subscriptionUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/tags_url`.
            public var tagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/teams_url`.
            public var teamsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/trees_url`.
            public var treesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/clone_url`.
            public var cloneUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/mirror_url`.
            public var mirrorUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository/hooks_url`.
            public var hooksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/svn_url`.
            public var svnUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/homepage`.
            public var homepage: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository/language`.
            public var language: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository/forks_count`.
            public var forksCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/repository/stargazers_count`.
            public var stargazersCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/repository/watchers_count`.
            public var watchersCount: Swift.Int
            /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/size`.
            public var size: Swift.Int
            /// The default branch of the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/default_branch`.
            public var defaultBranch: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository/open_issues_count`.
            public var openIssuesCount: Swift.Int
            /// Whether this repository acts as a template that can be used to generate new repositories.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/is_template`.
            public var isTemplate: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/repository/topics`.
            public var topics: [Swift.String]?
            /// Whether issues are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/has_issues`.
            public var hasIssues: Swift.Bool
            /// Whether projects are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/has_projects`.
            public var hasProjects: Swift.Bool
            /// Whether the wiki is enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/has_wiki`.
            public var hasWiki: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/repository/has_pages`.
            public var hasPages: Swift.Bool
            /// Whether downloads are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/has_downloads`.
            @available(*, deprecated)
            public var hasDownloads: Swift.Bool
            /// Whether discussions are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/has_discussions`.
            public var hasDiscussions: Swift.Bool?
            /// Whether the repository is archived.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/archived`.
            public var archived: Swift.Bool
            /// Returns whether or not this repository disabled.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/disabled`.
            public var disabled: Swift.Bool
            /// The repository visibility: public, private, or internal.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/visibility`.
            public var visibility: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository/pushed_at`.
            public var pushedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/repository/created_at`.
            public var createdAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/repository/updated_at`.
            public var updatedAt: Foundation.Date?
            /// Whether to allow rebase merges for pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/allow_rebase_merge`.
            public var allowRebaseMerge: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/repository/temp_clone_token`.
            public var tempCloneToken: Swift.String?
            /// Whether to allow squash merges for pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/allow_squash_merge`.
            public var allowSquashMerge: Swift.Bool?
            /// Whether to allow Auto-merge to be used on pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/allow_auto_merge`.
            public var allowAutoMerge: Swift.Bool?
            /// Whether to delete head branches when pull requests are merged
            ///
            /// - Remark: Generated from `#/components/schemas/repository/delete_branch_on_merge`.
            public var deleteBranchOnMerge: Swift.Bool?
            /// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/allow_update_branch`.
            public var allowUpdateBranch: Swift.Bool?
            /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/use_squash_pr_title_as_default`.
            @available(*, deprecated)
            public var useSquashPrTitleAsDefault: Swift.Bool?
            /// The default value for a squash merge commit title:
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            ///
            /// - Remark: Generated from `#/components/schemas/repository/squash_merge_commit_title`.
            @frozen public enum SquashMergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prTitle = "PR_TITLE"
                case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
            }
            /// The default value for a squash merge commit title:
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            ///
            /// - Remark: Generated from `#/components/schemas/repository/squash_merge_commit_title`.
            public var squashMergeCommitTitle: Components.Schemas.Repository.SquashMergeCommitTitlePayload?
            /// The default value for a squash merge commit message:
            ///
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/squash_merge_commit_message`.
            @frozen public enum SquashMergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prBody = "PR_BODY"
                case commitMessages = "COMMIT_MESSAGES"
                case blank = "BLANK"
            }
            /// The default value for a squash merge commit message:
            ///
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/squash_merge_commit_message`.
            public var squashMergeCommitMessage: Components.Schemas.Repository.SquashMergeCommitMessagePayload?
            /// The default value for a merge commit title.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            ///
            /// - Remark: Generated from `#/components/schemas/repository/merge_commit_title`.
            @frozen public enum MergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prTitle = "PR_TITLE"
                case mergeMessage = "MERGE_MESSAGE"
            }
            /// The default value for a merge commit title.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            ///
            /// - Remark: Generated from `#/components/schemas/repository/merge_commit_title`.
            public var mergeCommitTitle: Components.Schemas.Repository.MergeCommitTitlePayload?
            /// The default value for a merge commit message.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/merge_commit_message`.
            @frozen public enum MergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prBody = "PR_BODY"
                case prTitle = "PR_TITLE"
                case blank = "BLANK"
            }
            /// The default value for a merge commit message.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/merge_commit_message`.
            public var mergeCommitMessage: Components.Schemas.Repository.MergeCommitMessagePayload?
            /// Whether to allow merge commits for pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/repository/allow_merge_commit`.
            public var allowMergeCommit: Swift.Bool?
            /// Whether to allow forking this repo
            ///
            /// - Remark: Generated from `#/components/schemas/repository/allow_forking`.
            public var allowForking: Swift.Bool?
            /// Whether to require contributors to sign off on web-based commits
            ///
            /// - Remark: Generated from `#/components/schemas/repository/web_commit_signoff_required`.
            public var webCommitSignoffRequired: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/repository/open_issues`.
            public var openIssues: Swift.Int
            /// - Remark: Generated from `#/components/schemas/repository/watchers`.
            public var watchers: Swift.Int
            /// - Remark: Generated from `#/components/schemas/repository/master_branch`.
            public var masterBranch: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository/starred_at`.
            public var starredAt: Swift.String?
            /// Whether anonymous git access is enabled for this repository
            ///
            /// - Remark: Generated from `#/components/schemas/repository/anonymous_access_enabled`.
            public var anonymousAccessEnabled: Swift.Bool?
            /// Creates a new `Repository`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the repository
            ///   - nodeId:
            ///   - name: The name of the repository.
            ///   - fullName:
            ///   - license:
            ///   - forks:
            ///   - permissions:
            ///   - owner:
            ///   - _private: Whether the repository is private or public.
            ///   - htmlUrl:
            ///   - description:
            ///   - fork:
            ///   - url:
            ///   - archiveUrl:
            ///   - assigneesUrl:
            ///   - blobsUrl:
            ///   - branchesUrl:
            ///   - collaboratorsUrl:
            ///   - commentsUrl:
            ///   - commitsUrl:
            ///   - compareUrl:
            ///   - contentsUrl:
            ///   - contributorsUrl:
            ///   - deploymentsUrl:
            ///   - downloadsUrl:
            ///   - eventsUrl:
            ///   - forksUrl:
            ///   - gitCommitsUrl:
            ///   - gitRefsUrl:
            ///   - gitTagsUrl:
            ///   - gitUrl:
            ///   - issueCommentUrl:
            ///   - issueEventsUrl:
            ///   - issuesUrl:
            ///   - keysUrl:
            ///   - labelsUrl:
            ///   - languagesUrl:
            ///   - mergesUrl:
            ///   - milestonesUrl:
            ///   - notificationsUrl:
            ///   - pullsUrl:
            ///   - releasesUrl:
            ///   - sshUrl:
            ///   - stargazersUrl:
            ///   - statusesUrl:
            ///   - subscribersUrl:
            ///   - subscriptionUrl:
            ///   - tagsUrl:
            ///   - teamsUrl:
            ///   - treesUrl:
            ///   - cloneUrl:
            ///   - mirrorUrl:
            ///   - hooksUrl:
            ///   - svnUrl:
            ///   - homepage:
            ///   - language:
            ///   - forksCount:
            ///   - stargazersCount:
            ///   - watchersCount:
            ///   - size: The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///   - defaultBranch: The default branch of the repository.
            ///   - openIssuesCount:
            ///   - isTemplate: Whether this repository acts as a template that can be used to generate new repositories.
            ///   - topics:
            ///   - hasIssues: Whether issues are enabled.
            ///   - hasProjects: Whether projects are enabled.
            ///   - hasWiki: Whether the wiki is enabled.
            ///   - hasPages:
            ///   - hasDownloads: Whether downloads are enabled.
            ///   - hasDiscussions: Whether discussions are enabled.
            ///   - archived: Whether the repository is archived.
            ///   - disabled: Returns whether or not this repository disabled.
            ///   - visibility: The repository visibility: public, private, or internal.
            ///   - pushedAt:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - allowRebaseMerge: Whether to allow rebase merges for pull requests.
            ///   - tempCloneToken:
            ///   - allowSquashMerge: Whether to allow squash merges for pull requests.
            ///   - allowAutoMerge: Whether to allow Auto-merge to be used on pull requests.
            ///   - deleteBranchOnMerge: Whether to delete head branches when pull requests are merged
            ///   - allowUpdateBranch: Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
            ///   - useSquashPrTitleAsDefault: Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
            ///   - squashMergeCommitTitle: The default value for a squash merge commit title:
            ///   - squashMergeCommitMessage: The default value for a squash merge commit message:
            ///   - mergeCommitTitle: The default value for a merge commit title.
            ///   - mergeCommitMessage: The default value for a merge commit message.
            ///   - allowMergeCommit: Whether to allow merge commits for pull requests.
            ///   - allowForking: Whether to allow forking this repo
            ///   - webCommitSignoffRequired: Whether to require contributors to sign off on web-based commits
            ///   - openIssues:
            ///   - watchers:
            ///   - masterBranch:
            ///   - starredAt:
            ///   - anonymousAccessEnabled: Whether anonymous git access is enabled for this repository
            public init(
                id: Swift.Int64,
                nodeId: Swift.String,
                name: Swift.String,
                fullName: Swift.String,
                license: Components.Schemas.NullableLicenseSimple? = nil,
                forks: Swift.Int,
                permissions: Components.Schemas.Repository.PermissionsPayload? = nil,
                owner: Components.Schemas.SimpleUser,
                _private: Swift.Bool,
                htmlUrl: Swift.String,
                description: Swift.String? = nil,
                fork: Swift.Bool,
                url: Swift.String,
                archiveUrl: Swift.String,
                assigneesUrl: Swift.String,
                blobsUrl: Swift.String,
                branchesUrl: Swift.String,
                collaboratorsUrl: Swift.String,
                commentsUrl: Swift.String,
                commitsUrl: Swift.String,
                compareUrl: Swift.String,
                contentsUrl: Swift.String,
                contributorsUrl: Swift.String,
                deploymentsUrl: Swift.String,
                downloadsUrl: Swift.String,
                eventsUrl: Swift.String,
                forksUrl: Swift.String,
                gitCommitsUrl: Swift.String,
                gitRefsUrl: Swift.String,
                gitTagsUrl: Swift.String,
                gitUrl: Swift.String,
                issueCommentUrl: Swift.String,
                issueEventsUrl: Swift.String,
                issuesUrl: Swift.String,
                keysUrl: Swift.String,
                labelsUrl: Swift.String,
                languagesUrl: Swift.String,
                mergesUrl: Swift.String,
                milestonesUrl: Swift.String,
                notificationsUrl: Swift.String,
                pullsUrl: Swift.String,
                releasesUrl: Swift.String,
                sshUrl: Swift.String,
                stargazersUrl: Swift.String,
                statusesUrl: Swift.String,
                subscribersUrl: Swift.String,
                subscriptionUrl: Swift.String,
                tagsUrl: Swift.String,
                teamsUrl: Swift.String,
                treesUrl: Swift.String,
                cloneUrl: Swift.String,
                mirrorUrl: Swift.String? = nil,
                hooksUrl: Swift.String,
                svnUrl: Swift.String,
                homepage: Swift.String? = nil,
                language: Swift.String? = nil,
                forksCount: Swift.Int,
                stargazersCount: Swift.Int,
                watchersCount: Swift.Int,
                size: Swift.Int,
                defaultBranch: Swift.String,
                openIssuesCount: Swift.Int,
                isTemplate: Swift.Bool? = nil,
                topics: [Swift.String]? = nil,
                hasIssues: Swift.Bool,
                hasProjects: Swift.Bool,
                hasWiki: Swift.Bool,
                hasPages: Swift.Bool,
                hasDownloads: Swift.Bool,
                hasDiscussions: Swift.Bool? = nil,
                archived: Swift.Bool,
                disabled: Swift.Bool,
                visibility: Swift.String? = nil,
                pushedAt: Foundation.Date? = nil,
                createdAt: Foundation.Date? = nil,
                updatedAt: Foundation.Date? = nil,
                allowRebaseMerge: Swift.Bool? = nil,
                tempCloneToken: Swift.String? = nil,
                allowSquashMerge: Swift.Bool? = nil,
                allowAutoMerge: Swift.Bool? = nil,
                deleteBranchOnMerge: Swift.Bool? = nil,
                allowUpdateBranch: Swift.Bool? = nil,
                useSquashPrTitleAsDefault: Swift.Bool? = nil,
                squashMergeCommitTitle: Components.Schemas.Repository.SquashMergeCommitTitlePayload? = nil,
                squashMergeCommitMessage: Components.Schemas.Repository.SquashMergeCommitMessagePayload? = nil,
                mergeCommitTitle: Components.Schemas.Repository.MergeCommitTitlePayload? = nil,
                mergeCommitMessage: Components.Schemas.Repository.MergeCommitMessagePayload? = nil,
                allowMergeCommit: Swift.Bool? = nil,
                allowForking: Swift.Bool? = nil,
                webCommitSignoffRequired: Swift.Bool? = nil,
                openIssues: Swift.Int,
                watchers: Swift.Int,
                masterBranch: Swift.String? = nil,
                starredAt: Swift.String? = nil,
                anonymousAccessEnabled: Swift.Bool? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.fullName = fullName
                self.license = license
                self.forks = forks
                self.permissions = permissions
                self.owner = owner
                self._private = _private
                self.htmlUrl = htmlUrl
                self.description = description
                self.fork = fork
                self.url = url
                self.archiveUrl = archiveUrl
                self.assigneesUrl = assigneesUrl
                self.blobsUrl = blobsUrl
                self.branchesUrl = branchesUrl
                self.collaboratorsUrl = collaboratorsUrl
                self.commentsUrl = commentsUrl
                self.commitsUrl = commitsUrl
                self.compareUrl = compareUrl
                self.contentsUrl = contentsUrl
                self.contributorsUrl = contributorsUrl
                self.deploymentsUrl = deploymentsUrl
                self.downloadsUrl = downloadsUrl
                self.eventsUrl = eventsUrl
                self.forksUrl = forksUrl
                self.gitCommitsUrl = gitCommitsUrl
                self.gitRefsUrl = gitRefsUrl
                self.gitTagsUrl = gitTagsUrl
                self.gitUrl = gitUrl
                self.issueCommentUrl = issueCommentUrl
                self.issueEventsUrl = issueEventsUrl
                self.issuesUrl = issuesUrl
                self.keysUrl = keysUrl
                self.labelsUrl = labelsUrl
                self.languagesUrl = languagesUrl
                self.mergesUrl = mergesUrl
                self.milestonesUrl = milestonesUrl
                self.notificationsUrl = notificationsUrl
                self.pullsUrl = pullsUrl
                self.releasesUrl = releasesUrl
                self.sshUrl = sshUrl
                self.stargazersUrl = stargazersUrl
                self.statusesUrl = statusesUrl
                self.subscribersUrl = subscribersUrl
                self.subscriptionUrl = subscriptionUrl
                self.tagsUrl = tagsUrl
                self.teamsUrl = teamsUrl
                self.treesUrl = treesUrl
                self.cloneUrl = cloneUrl
                self.mirrorUrl = mirrorUrl
                self.hooksUrl = hooksUrl
                self.svnUrl = svnUrl
                self.homepage = homepage
                self.language = language
                self.forksCount = forksCount
                self.stargazersCount = stargazersCount
                self.watchersCount = watchersCount
                self.size = size
                self.defaultBranch = defaultBranch
                self.openIssuesCount = openIssuesCount
                self.isTemplate = isTemplate
                self.topics = topics
                self.hasIssues = hasIssues
                self.hasProjects = hasProjects
                self.hasWiki = hasWiki
                self.hasPages = hasPages
                self.hasDownloads = hasDownloads
                self.hasDiscussions = hasDiscussions
                self.archived = archived
                self.disabled = disabled
                self.visibility = visibility
                self.pushedAt = pushedAt
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.allowRebaseMerge = allowRebaseMerge
                self.tempCloneToken = tempCloneToken
                self.allowSquashMerge = allowSquashMerge
                self.allowAutoMerge = allowAutoMerge
                self.deleteBranchOnMerge = deleteBranchOnMerge
                self.allowUpdateBranch = allowUpdateBranch
                self.useSquashPrTitleAsDefault = useSquashPrTitleAsDefault
                self.squashMergeCommitTitle = squashMergeCommitTitle
                self.squashMergeCommitMessage = squashMergeCommitMessage
                self.mergeCommitTitle = mergeCommitTitle
                self.mergeCommitMessage = mergeCommitMessage
                self.allowMergeCommit = allowMergeCommit
                self.allowForking = allowForking
                self.webCommitSignoffRequired = webCommitSignoffRequired
                self.openIssues = openIssues
                self.watchers = watchers
                self.masterBranch = masterBranch
                self.starredAt = starredAt
                self.anonymousAccessEnabled = anonymousAccessEnabled
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case name
                case fullName = "full_name"
                case license
                case forks
                case permissions
                case owner
                case _private = "private"
                case htmlUrl = "html_url"
                case description
                case fork
                case url
                case archiveUrl = "archive_url"
                case assigneesUrl = "assignees_url"
                case blobsUrl = "blobs_url"
                case branchesUrl = "branches_url"
                case collaboratorsUrl = "collaborators_url"
                case commentsUrl = "comments_url"
                case commitsUrl = "commits_url"
                case compareUrl = "compare_url"
                case contentsUrl = "contents_url"
                case contributorsUrl = "contributors_url"
                case deploymentsUrl = "deployments_url"
                case downloadsUrl = "downloads_url"
                case eventsUrl = "events_url"
                case forksUrl = "forks_url"
                case gitCommitsUrl = "git_commits_url"
                case gitRefsUrl = "git_refs_url"
                case gitTagsUrl = "git_tags_url"
                case gitUrl = "git_url"
                case issueCommentUrl = "issue_comment_url"
                case issueEventsUrl = "issue_events_url"
                case issuesUrl = "issues_url"
                case keysUrl = "keys_url"
                case labelsUrl = "labels_url"
                case languagesUrl = "languages_url"
                case mergesUrl = "merges_url"
                case milestonesUrl = "milestones_url"
                case notificationsUrl = "notifications_url"
                case pullsUrl = "pulls_url"
                case releasesUrl = "releases_url"
                case sshUrl = "ssh_url"
                case stargazersUrl = "stargazers_url"
                case statusesUrl = "statuses_url"
                case subscribersUrl = "subscribers_url"
                case subscriptionUrl = "subscription_url"
                case tagsUrl = "tags_url"
                case teamsUrl = "teams_url"
                case treesUrl = "trees_url"
                case cloneUrl = "clone_url"
                case mirrorUrl = "mirror_url"
                case hooksUrl = "hooks_url"
                case svnUrl = "svn_url"
                case homepage
                case language
                case forksCount = "forks_count"
                case stargazersCount = "stargazers_count"
                case watchersCount = "watchers_count"
                case size
                case defaultBranch = "default_branch"
                case openIssuesCount = "open_issues_count"
                case isTemplate = "is_template"
                case topics
                case hasIssues = "has_issues"
                case hasProjects = "has_projects"
                case hasWiki = "has_wiki"
                case hasPages = "has_pages"
                case hasDownloads = "has_downloads"
                case hasDiscussions = "has_discussions"
                case archived
                case disabled
                case visibility
                case pushedAt = "pushed_at"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case allowRebaseMerge = "allow_rebase_merge"
                case tempCloneToken = "temp_clone_token"
                case allowSquashMerge = "allow_squash_merge"
                case allowAutoMerge = "allow_auto_merge"
                case deleteBranchOnMerge = "delete_branch_on_merge"
                case allowUpdateBranch = "allow_update_branch"
                case useSquashPrTitleAsDefault = "use_squash_pr_title_as_default"
                case squashMergeCommitTitle = "squash_merge_commit_title"
                case squashMergeCommitMessage = "squash_merge_commit_message"
                case mergeCommitTitle = "merge_commit_title"
                case mergeCommitMessage = "merge_commit_message"
                case allowMergeCommit = "allow_merge_commit"
                case allowForking = "allow_forking"
                case webCommitSignoffRequired = "web_commit_signoff_required"
                case openIssues = "open_issues"
                case watchers
                case masterBranch = "master_branch"
                case starredAt = "starred_at"
                case anonymousAccessEnabled = "anonymous_access_enabled"
            }
        }
        /// Code Of Conduct
        ///
        /// - Remark: Generated from `#/components/schemas/code-of-conduct`.
        public struct CodeOfConduct: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/code-of-conduct/key`.
            public var key: Swift.String
            /// - Remark: Generated from `#/components/schemas/code-of-conduct/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/code-of-conduct/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/code-of-conduct/body`.
            public var body: Swift.String?
            /// - Remark: Generated from `#/components/schemas/code-of-conduct/html_url`.
            public var htmlUrl: Swift.String?
            /// Creates a new `CodeOfConduct`.
            ///
            /// - Parameters:
            ///   - key:
            ///   - name:
            ///   - url:
            ///   - body:
            ///   - htmlUrl:
            public init(
                key: Swift.String,
                name: Swift.String,
                url: Swift.String,
                body: Swift.String? = nil,
                htmlUrl: Swift.String? = nil
            ) {
                self.key = key
                self.name = name
                self.url = url
                self.body = body
                self.htmlUrl = htmlUrl
            }
            public enum CodingKeys: String, CodingKey {
                case key
                case name
                case url
                case body
                case htmlUrl = "html_url"
            }
        }
        /// A collection of related issues and pull requests.
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-milestone`.
        public struct NullableMilestone: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/labels_url`.
            public var labelsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/node_id`.
            public var nodeId: Swift.String
            /// The number of the milestone.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/number`.
            public var number: Swift.Int
            /// The state of the milestone.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/state`.
            @frozen public enum StatePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case open = "open"
                case closed = "closed"
            }
            /// The state of the milestone.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/state`.
            public var state: Components.Schemas.NullableMilestone.StatePayload
            /// The title of the milestone.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/title`.
            public var title: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/creator`.
            public var creator: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/open_issues`.
            public var openIssues: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/closed_issues`.
            public var closedIssues: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/closed_at`.
            public var closedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/nullable-milestone/due_on`.
            public var dueOn: Foundation.Date?
            /// Creates a new `NullableMilestone`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - htmlUrl:
            ///   - labelsUrl:
            ///   - id:
            ///   - nodeId:
            ///   - number: The number of the milestone.
            ///   - state: The state of the milestone.
            ///   - title: The title of the milestone.
            ///   - description:
            ///   - creator:
            ///   - openIssues:
            ///   - closedIssues:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - closedAt:
            ///   - dueOn:
            public init(
                url: Swift.String,
                htmlUrl: Swift.String,
                labelsUrl: Swift.String,
                id: Swift.Int,
                nodeId: Swift.String,
                number: Swift.Int,
                state: Components.Schemas.NullableMilestone.StatePayload,
                title: Swift.String,
                description: Swift.String? = nil,
                creator: Components.Schemas.NullableSimpleUser? = nil,
                openIssues: Swift.Int,
                closedIssues: Swift.Int,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                closedAt: Foundation.Date? = nil,
                dueOn: Foundation.Date? = nil
            ) {
                self.url = url
                self.htmlUrl = htmlUrl
                self.labelsUrl = labelsUrl
                self.id = id
                self.nodeId = nodeId
                self.number = number
                self.state = state
                self.title = title
                self.description = description
                self.creator = creator
                self.openIssues = openIssues
                self.closedIssues = closedIssues
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.closedAt = closedAt
                self.dueOn = dueOn
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case htmlUrl = "html_url"
                case labelsUrl = "labels_url"
                case id
                case nodeId = "node_id"
                case number
                case state
                case title
                case description
                case creator
                case openIssues = "open_issues"
                case closedIssues = "closed_issues"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case closedAt = "closed_at"
                case dueOn = "due_on"
            }
        }
        /// GitHub apps are a new way to extend GitHub. They can be installed directly on organizations and user accounts and granted access to specific repositories. They come with granular permissions and built-in webhooks. GitHub apps are first class actors within GitHub.
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-integration`.
        public struct NullableIntegration: Codable, Hashable, Sendable {
            /// Unique identifier of the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-integration/id`.
            public var id: Swift.Int
            /// The slug name of the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-integration/slug`.
            public var slug: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-integration/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-integration/client_id`.
            public var clientId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-integration/owner`.
            @frozen public enum OwnerPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/nullable-integration/owner/case1`.
                case SimpleUser(Components.Schemas.SimpleUser)
                /// - Remark: Generated from `#/components/schemas/nullable-integration/owner/case2`.
                case Enterprise(Components.Schemas.Enterprise)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .SimpleUser(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .Enterprise(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .SimpleUser(value):
                        try value.encode(to: encoder)
                    case let .Enterprise(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// - Remark: Generated from `#/components/schemas/nullable-integration/owner`.
            public var owner: Components.Schemas.NullableIntegration.OwnerPayload
            /// The name of the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-integration/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-integration/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-integration/external_url`.
            public var externalUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-integration/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-integration/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/nullable-integration/updated_at`.
            public var updatedAt: Foundation.Date
            /// The set of permissions for the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-integration/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/nullable-integration/permissions/issues`.
                public var issues: Swift.String?
                /// - Remark: Generated from `#/components/schemas/nullable-integration/permissions/checks`.
                public var checks: Swift.String?
                /// - Remark: Generated from `#/components/schemas/nullable-integration/permissions/metadata`.
                public var metadata: Swift.String?
                /// - Remark: Generated from `#/components/schemas/nullable-integration/permissions/contents`.
                public var contents: Swift.String?
                /// - Remark: Generated from `#/components/schemas/nullable-integration/permissions/deployments`.
                public var deployments: Swift.String?
                /// A container of undocumented properties.
                public var additionalProperties: [String: Swift.String]
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - issues:
                ///   - checks:
                ///   - metadata:
                ///   - contents:
                ///   - deployments:
                ///   - additionalProperties: A container of undocumented properties.
                public init(
                    issues: Swift.String? = nil,
                    checks: Swift.String? = nil,
                    metadata: Swift.String? = nil,
                    contents: Swift.String? = nil,
                    deployments: Swift.String? = nil,
                    additionalProperties: [String: Swift.String] = .init()
                ) {
                    self.issues = issues
                    self.checks = checks
                    self.metadata = metadata
                    self.contents = contents
                    self.deployments = deployments
                    self.additionalProperties = additionalProperties
                }
                public enum CodingKeys: String, CodingKey {
                    case issues
                    case checks
                    case metadata
                    case contents
                    case deployments
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.issues = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .issues
                    )
                    self.checks = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .checks
                    )
                    self.metadata = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .metadata
                    )
                    self.contents = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .contents
                    )
                    self.deployments = try container.decodeIfPresent(
                        Swift.String.self,
                        forKey: .deployments
                    )
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [
                        "issues",
                        "checks",
                        "metadata",
                        "contents",
                        "deployments"
                    ])
                }
                public func encode(to encoder: any Encoder) throws {
                    var container = encoder.container(keyedBy: CodingKeys.self)
                    try container.encodeIfPresent(
                        self.issues,
                        forKey: .issues
                    )
                    try container.encodeIfPresent(
                        self.checks,
                        forKey: .checks
                    )
                    try container.encodeIfPresent(
                        self.metadata,
                        forKey: .metadata
                    )
                    try container.encodeIfPresent(
                        self.contents,
                        forKey: .contents
                    )
                    try container.encodeIfPresent(
                        self.deployments,
                        forKey: .deployments
                    )
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// The set of permissions for the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-integration/permissions`.
            public var permissions: Components.Schemas.NullableIntegration.PermissionsPayload
            /// The list of events for the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-integration/events`.
            public var events: [Swift.String]
            /// The number of installations associated with the GitHub app
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-integration/installations_count`.
            public var installationsCount: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/nullable-integration/client_secret`.
            public var clientSecret: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-integration/webhook_secret`.
            public var webhookSecret: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-integration/pem`.
            public var pem: Swift.String?
            /// Creates a new `NullableIntegration`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the GitHub app
            ///   - slug: The slug name of the GitHub app
            ///   - nodeId:
            ///   - clientId:
            ///   - owner:
            ///   - name: The name of the GitHub app
            ///   - description:
            ///   - externalUrl:
            ///   - htmlUrl:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - permissions: The set of permissions for the GitHub app
            ///   - events: The list of events for the GitHub app
            ///   - installationsCount: The number of installations associated with the GitHub app
            ///   - clientSecret:
            ///   - webhookSecret:
            ///   - pem:
            public init(
                id: Swift.Int,
                slug: Swift.String? = nil,
                nodeId: Swift.String,
                clientId: Swift.String? = nil,
                owner: Components.Schemas.NullableIntegration.OwnerPayload,
                name: Swift.String,
                description: Swift.String? = nil,
                externalUrl: Swift.String,
                htmlUrl: Swift.String,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                permissions: Components.Schemas.NullableIntegration.PermissionsPayload,
                events: [Swift.String],
                installationsCount: Swift.Int? = nil,
                clientSecret: Swift.String? = nil,
                webhookSecret: Swift.String? = nil,
                pem: Swift.String? = nil
            ) {
                self.id = id
                self.slug = slug
                self.nodeId = nodeId
                self.clientId = clientId
                self.owner = owner
                self.name = name
                self.description = description
                self.externalUrl = externalUrl
                self.htmlUrl = htmlUrl
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.permissions = permissions
                self.events = events
                self.installationsCount = installationsCount
                self.clientSecret = clientSecret
                self.webhookSecret = webhookSecret
                self.pem = pem
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case slug
                case nodeId = "node_id"
                case clientId = "client_id"
                case owner
                case name
                case description
                case externalUrl = "external_url"
                case htmlUrl = "html_url"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case permissions
                case events
                case installationsCount = "installations_count"
                case clientSecret = "client_secret"
                case webhookSecret = "webhook_secret"
                case pem
            }
        }
        /// How the author is associated with the repository.
        ///
        /// - Remark: Generated from `#/components/schemas/author-association`.
        @frozen public enum AuthorAssociation: String, Codable, Hashable, Sendable, CaseIterable {
            case collaborator = "COLLABORATOR"
            case contributor = "CONTRIBUTOR"
            case firstTimer = "FIRST_TIMER"
            case firstTimeContributor = "FIRST_TIME_CONTRIBUTOR"
            case mannequin = "MANNEQUIN"
            case member = "MEMBER"
            case none = "NONE"
            case owner = "OWNER"
        }
        /// - Remark: Generated from `#/components/schemas/reaction-rollup`.
        public struct ReactionRollup: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/total_count`.
            public var totalCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/+1`.
            public var _plus_1: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/-1`.
            public var _hyphen_1: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/laugh`.
            public var laugh: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/confused`.
            public var confused: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/heart`.
            public var heart: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/hooray`.
            public var hooray: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/eyes`.
            public var eyes: Swift.Int
            /// - Remark: Generated from `#/components/schemas/reaction-rollup/rocket`.
            public var rocket: Swift.Int
            /// Creates a new `ReactionRollup`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - totalCount:
            ///   - _plus_1:
            ///   - _hyphen_1:
            ///   - laugh:
            ///   - confused:
            ///   - heart:
            ///   - hooray:
            ///   - eyes:
            ///   - rocket:
            public init(
                url: Swift.String,
                totalCount: Swift.Int,
                _plus_1: Swift.Int,
                _hyphen_1: Swift.Int,
                laugh: Swift.Int,
                confused: Swift.Int,
                heart: Swift.Int,
                hooray: Swift.Int,
                eyes: Swift.Int,
                rocket: Swift.Int
            ) {
                self.url = url
                self.totalCount = totalCount
                self._plus_1 = _plus_1
                self._hyphen_1 = _hyphen_1
                self.laugh = laugh
                self.confused = confused
                self.heart = heart
                self.hooray = hooray
                self.eyes = eyes
                self.rocket = rocket
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case totalCount = "total_count"
                case _plus_1 = "+1"
                case _hyphen_1 = "-1"
                case laugh
                case confused
                case heart
                case hooray
                case eyes
                case rocket
            }
        }
        /// - Remark: Generated from `#/components/schemas/security-and-analysis`.
        public struct SecurityAndAnalysis: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/advanced_security`.
            public struct AdvancedSecurityPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/advanced_security/status`.
                @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case enabled = "enabled"
                    case disabled = "disabled"
                }
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/advanced_security/status`.
                public var status: Components.Schemas.SecurityAndAnalysis.AdvancedSecurityPayload.StatusPayload?
                /// Creates a new `AdvancedSecurityPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Components.Schemas.SecurityAndAnalysis.AdvancedSecurityPayload.StatusPayload? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/advanced_security`.
            public var advancedSecurity: Components.Schemas.SecurityAndAnalysis.AdvancedSecurityPayload?
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/code_security`.
            public struct CodeSecurityPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/code_security/status`.
                @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case enabled = "enabled"
                    case disabled = "disabled"
                }
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/code_security/status`.
                public var status: Components.Schemas.SecurityAndAnalysis.CodeSecurityPayload.StatusPayload?
                /// Creates a new `CodeSecurityPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Components.Schemas.SecurityAndAnalysis.CodeSecurityPayload.StatusPayload? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/code_security`.
            public var codeSecurity: Components.Schemas.SecurityAndAnalysis.CodeSecurityPayload?
            /// Enable or disable Dependabot security updates for the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/dependabot_security_updates`.
            public struct DependabotSecurityUpdatesPayload: Codable, Hashable, Sendable {
                /// The enablement status of Dependabot security updates for the repository.
                ///
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/dependabot_security_updates/status`.
                @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case enabled = "enabled"
                    case disabled = "disabled"
                }
                /// The enablement status of Dependabot security updates for the repository.
                ///
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/dependabot_security_updates/status`.
                public var status: Components.Schemas.SecurityAndAnalysis.DependabotSecurityUpdatesPayload.StatusPayload?
                /// Creates a new `DependabotSecurityUpdatesPayload`.
                ///
                /// - Parameters:
                ///   - status: The enablement status of Dependabot security updates for the repository.
                public init(status: Components.Schemas.SecurityAndAnalysis.DependabotSecurityUpdatesPayload.StatusPayload? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// Enable or disable Dependabot security updates for the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/dependabot_security_updates`.
            public var dependabotSecurityUpdates: Components.Schemas.SecurityAndAnalysis.DependabotSecurityUpdatesPayload?
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning`.
            public struct SecretScanningPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning/status`.
                @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case enabled = "enabled"
                    case disabled = "disabled"
                }
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning/status`.
                public var status: Components.Schemas.SecurityAndAnalysis.SecretScanningPayload.StatusPayload?
                /// Creates a new `SecretScanningPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Components.Schemas.SecurityAndAnalysis.SecretScanningPayload.StatusPayload? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning`.
            public var secretScanning: Components.Schemas.SecurityAndAnalysis.SecretScanningPayload?
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_push_protection`.
            public struct SecretScanningPushProtectionPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_push_protection/status`.
                @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case enabled = "enabled"
                    case disabled = "disabled"
                }
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_push_protection/status`.
                public var status: Components.Schemas.SecurityAndAnalysis.SecretScanningPushProtectionPayload.StatusPayload?
                /// Creates a new `SecretScanningPushProtectionPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Components.Schemas.SecurityAndAnalysis.SecretScanningPushProtectionPayload.StatusPayload? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_push_protection`.
            public var secretScanningPushProtection: Components.Schemas.SecurityAndAnalysis.SecretScanningPushProtectionPayload?
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_non_provider_patterns`.
            public struct SecretScanningNonProviderPatternsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_non_provider_patterns/status`.
                @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case enabled = "enabled"
                    case disabled = "disabled"
                }
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_non_provider_patterns/status`.
                public var status: Components.Schemas.SecurityAndAnalysis.SecretScanningNonProviderPatternsPayload.StatusPayload?
                /// Creates a new `SecretScanningNonProviderPatternsPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Components.Schemas.SecurityAndAnalysis.SecretScanningNonProviderPatternsPayload.StatusPayload? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_non_provider_patterns`.
            public var secretScanningNonProviderPatterns: Components.Schemas.SecurityAndAnalysis.SecretScanningNonProviderPatternsPayload?
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_ai_detection`.
            public struct SecretScanningAiDetectionPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_ai_detection/status`.
                @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case enabled = "enabled"
                    case disabled = "disabled"
                }
                /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_ai_detection/status`.
                public var status: Components.Schemas.SecurityAndAnalysis.SecretScanningAiDetectionPayload.StatusPayload?
                /// Creates a new `SecretScanningAiDetectionPayload`.
                ///
                /// - Parameters:
                ///   - status:
                public init(status: Components.Schemas.SecurityAndAnalysis.SecretScanningAiDetectionPayload.StatusPayload? = nil) {
                    self.status = status
                }
                public enum CodingKeys: String, CodingKey {
                    case status
                }
            }
            /// - Remark: Generated from `#/components/schemas/security-and-analysis/secret_scanning_ai_detection`.
            public var secretScanningAiDetection: Components.Schemas.SecurityAndAnalysis.SecretScanningAiDetectionPayload?
            /// Creates a new `SecurityAndAnalysis`.
            ///
            /// - Parameters:
            ///   - advancedSecurity:
            ///   - codeSecurity:
            ///   - dependabotSecurityUpdates: Enable or disable Dependabot security updates for the repository.
            ///   - secretScanning:
            ///   - secretScanningPushProtection:
            ///   - secretScanningNonProviderPatterns:
            ///   - secretScanningAiDetection:
            public init(
                advancedSecurity: Components.Schemas.SecurityAndAnalysis.AdvancedSecurityPayload? = nil,
                codeSecurity: Components.Schemas.SecurityAndAnalysis.CodeSecurityPayload? = nil,
                dependabotSecurityUpdates: Components.Schemas.SecurityAndAnalysis.DependabotSecurityUpdatesPayload? = nil,
                secretScanning: Components.Schemas.SecurityAndAnalysis.SecretScanningPayload? = nil,
                secretScanningPushProtection: Components.Schemas.SecurityAndAnalysis.SecretScanningPushProtectionPayload? = nil,
                secretScanningNonProviderPatterns: Components.Schemas.SecurityAndAnalysis.SecretScanningNonProviderPatternsPayload? = nil,
                secretScanningAiDetection: Components.Schemas.SecurityAndAnalysis.SecretScanningAiDetectionPayload? = nil
            ) {
                self.advancedSecurity = advancedSecurity
                self.codeSecurity = codeSecurity
                self.dependabotSecurityUpdates = dependabotSecurityUpdates
                self.secretScanning = secretScanning
                self.secretScanningPushProtection = secretScanningPushProtection
                self.secretScanningNonProviderPatterns = secretScanningNonProviderPatterns
                self.secretScanningAiDetection = secretScanningAiDetection
            }
            public enum CodingKeys: String, CodingKey {
                case advancedSecurity = "advanced_security"
                case codeSecurity = "code_security"
                case dependabotSecurityUpdates = "dependabot_security_updates"
                case secretScanning = "secret_scanning"
                case secretScanningPushProtection = "secret_scanning_push_protection"
                case secretScanningNonProviderPatterns = "secret_scanning_non_provider_patterns"
                case secretScanningAiDetection = "secret_scanning_ai_detection"
            }
        }
        /// Minimal Repository
        ///
        /// - Remark: Generated from `#/components/schemas/minimal-repository`.
        public struct MinimalRepository: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/minimal-repository/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/minimal-repository/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/full_name`.
            public var fullName: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/owner`.
            public var owner: Components.Schemas.SimpleUser
            /// - Remark: Generated from `#/components/schemas/minimal-repository/private`.
            public var _private: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/minimal-repository/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/fork`.
            public var fork: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/minimal-repository/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/archive_url`.
            public var archiveUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/assignees_url`.
            public var assigneesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/blobs_url`.
            public var blobsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/branches_url`.
            public var branchesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/collaborators_url`.
            public var collaboratorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/comments_url`.
            public var commentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/commits_url`.
            public var commitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/compare_url`.
            public var compareUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/contents_url`.
            public var contentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/contributors_url`.
            public var contributorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/deployments_url`.
            public var deploymentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/downloads_url`.
            public var downloadsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/forks_url`.
            public var forksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/git_commits_url`.
            public var gitCommitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/git_refs_url`.
            public var gitRefsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/git_tags_url`.
            public var gitTagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/git_url`.
            public var gitUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/issue_comment_url`.
            public var issueCommentUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/issue_events_url`.
            public var issueEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/issues_url`.
            public var issuesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/keys_url`.
            public var keysUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/labels_url`.
            public var labelsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/languages_url`.
            public var languagesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/merges_url`.
            public var mergesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/milestones_url`.
            public var milestonesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/notifications_url`.
            public var notificationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/pulls_url`.
            public var pullsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/releases_url`.
            public var releasesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/ssh_url`.
            public var sshUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/stargazers_url`.
            public var stargazersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/statuses_url`.
            public var statusesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/subscribers_url`.
            public var subscribersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/subscription_url`.
            public var subscriptionUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/tags_url`.
            public var tagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/teams_url`.
            public var teamsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/trees_url`.
            public var treesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/clone_url`.
            public var cloneUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/mirror_url`.
            public var mirrorUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/hooks_url`.
            public var hooksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/minimal-repository/svn_url`.
            public var svnUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/homepage`.
            public var homepage: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/language`.
            public var language: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/forks_count`.
            public var forksCount: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/stargazers_count`.
            public var stargazersCount: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/watchers_count`.
            public var watchersCount: Swift.Int?
            /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///
            /// - Remark: Generated from `#/components/schemas/minimal-repository/size`.
            public var size: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/default_branch`.
            public var defaultBranch: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/open_issues_count`.
            public var openIssuesCount: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/is_template`.
            public var isTemplate: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/topics`.
            public var topics: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/has_issues`.
            public var hasIssues: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/has_projects`.
            public var hasProjects: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/has_wiki`.
            public var hasWiki: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/has_pages`.
            public var hasPages: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/has_downloads`.
            public var hasDownloads: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/has_discussions`.
            public var hasDiscussions: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/archived`.
            public var archived: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/disabled`.
            public var disabled: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/visibility`.
            public var visibility: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/pushed_at`.
            public var pushedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/created_at`.
            public var createdAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/updated_at`.
            public var updatedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/minimal-repository/permissions/admin`.
                public var admin: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/permissions/maintain`.
                public var maintain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/permissions/push`.
                public var push: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/permissions/triage`.
                public var triage: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/permissions/pull`.
                public var pull: Swift.Bool?
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - admin:
                ///   - maintain:
                ///   - push:
                ///   - triage:
                ///   - pull:
                public init(
                    admin: Swift.Bool? = nil,
                    maintain: Swift.Bool? = nil,
                    push: Swift.Bool? = nil,
                    triage: Swift.Bool? = nil,
                    pull: Swift.Bool? = nil
                ) {
                    self.admin = admin
                    self.maintain = maintain
                    self.push = push
                    self.triage = triage
                    self.pull = pull
                }
                public enum CodingKeys: String, CodingKey {
                    case admin
                    case maintain
                    case push
                    case triage
                    case pull
                }
            }
            /// - Remark: Generated from `#/components/schemas/minimal-repository/permissions`.
            public var permissions: Components.Schemas.MinimalRepository.PermissionsPayload?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/role_name`.
            public var roleName: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/temp_clone_token`.
            public var tempCloneToken: Swift.String?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/delete_branch_on_merge`.
            public var deleteBranchOnMerge: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/subscribers_count`.
            public var subscribersCount: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/network_count`.
            public var networkCount: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/code_of_conduct`.
            public var codeOfConduct: Components.Schemas.CodeOfConduct?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/license`.
            public struct LicensePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/minimal-repository/license/key`.
                public var key: Swift.String?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/license/name`.
                public var name: Swift.String?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/license/spdx_id`.
                public var spdxId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/license/url`.
                public var url: Swift.String?
                /// - Remark: Generated from `#/components/schemas/minimal-repository/license/node_id`.
                public var nodeId: Swift.String?
                /// Creates a new `LicensePayload`.
                ///
                /// - Parameters:
                ///   - key:
                ///   - name:
                ///   - spdxId:
                ///   - url:
                ///   - nodeId:
                public init(
                    key: Swift.String? = nil,
                    name: Swift.String? = nil,
                    spdxId: Swift.String? = nil,
                    url: Swift.String? = nil,
                    nodeId: Swift.String? = nil
                ) {
                    self.key = key
                    self.name = name
                    self.spdxId = spdxId
                    self.url = url
                    self.nodeId = nodeId
                }
                public enum CodingKeys: String, CodingKey {
                    case key
                    case name
                    case spdxId = "spdx_id"
                    case url
                    case nodeId = "node_id"
                }
            }
            /// - Remark: Generated from `#/components/schemas/minimal-repository/license`.
            public var license: Components.Schemas.MinimalRepository.LicensePayload?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/forks`.
            public var forks: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/open_issues`.
            public var openIssues: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/watchers`.
            public var watchers: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/allow_forking`.
            public var allowForking: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/web_commit_signoff_required`.
            public var webCommitSignoffRequired: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/minimal-repository/security_and_analysis`.
            public var securityAndAnalysis: Components.Schemas.SecurityAndAnalysis?
            /// Creates a new `MinimalRepository`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - nodeId:
            ///   - name:
            ///   - fullName:
            ///   - owner:
            ///   - _private:
            ///   - htmlUrl:
            ///   - description:
            ///   - fork:
            ///   - url:
            ///   - archiveUrl:
            ///   - assigneesUrl:
            ///   - blobsUrl:
            ///   - branchesUrl:
            ///   - collaboratorsUrl:
            ///   - commentsUrl:
            ///   - commitsUrl:
            ///   - compareUrl:
            ///   - contentsUrl:
            ///   - contributorsUrl:
            ///   - deploymentsUrl:
            ///   - downloadsUrl:
            ///   - eventsUrl:
            ///   - forksUrl:
            ///   - gitCommitsUrl:
            ///   - gitRefsUrl:
            ///   - gitTagsUrl:
            ///   - gitUrl:
            ///   - issueCommentUrl:
            ///   - issueEventsUrl:
            ///   - issuesUrl:
            ///   - keysUrl:
            ///   - labelsUrl:
            ///   - languagesUrl:
            ///   - mergesUrl:
            ///   - milestonesUrl:
            ///   - notificationsUrl:
            ///   - pullsUrl:
            ///   - releasesUrl:
            ///   - sshUrl:
            ///   - stargazersUrl:
            ///   - statusesUrl:
            ///   - subscribersUrl:
            ///   - subscriptionUrl:
            ///   - tagsUrl:
            ///   - teamsUrl:
            ///   - treesUrl:
            ///   - cloneUrl:
            ///   - mirrorUrl:
            ///   - hooksUrl:
            ///   - svnUrl:
            ///   - homepage:
            ///   - language:
            ///   - forksCount:
            ///   - stargazersCount:
            ///   - watchersCount:
            ///   - size: The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///   - defaultBranch:
            ///   - openIssuesCount:
            ///   - isTemplate:
            ///   - topics:
            ///   - hasIssues:
            ///   - hasProjects:
            ///   - hasWiki:
            ///   - hasPages:
            ///   - hasDownloads:
            ///   - hasDiscussions:
            ///   - archived:
            ///   - disabled:
            ///   - visibility:
            ///   - pushedAt:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - permissions:
            ///   - roleName:
            ///   - tempCloneToken:
            ///   - deleteBranchOnMerge:
            ///   - subscribersCount:
            ///   - networkCount:
            ///   - codeOfConduct:
            ///   - license:
            ///   - forks:
            ///   - openIssues:
            ///   - watchers:
            ///   - allowForking:
            ///   - webCommitSignoffRequired:
            ///   - securityAndAnalysis:
            public init(
                id: Swift.Int64,
                nodeId: Swift.String,
                name: Swift.String,
                fullName: Swift.String,
                owner: Components.Schemas.SimpleUser,
                _private: Swift.Bool,
                htmlUrl: Swift.String,
                description: Swift.String? = nil,
                fork: Swift.Bool,
                url: Swift.String,
                archiveUrl: Swift.String,
                assigneesUrl: Swift.String,
                blobsUrl: Swift.String,
                branchesUrl: Swift.String,
                collaboratorsUrl: Swift.String,
                commentsUrl: Swift.String,
                commitsUrl: Swift.String,
                compareUrl: Swift.String,
                contentsUrl: Swift.String,
                contributorsUrl: Swift.String,
                deploymentsUrl: Swift.String,
                downloadsUrl: Swift.String,
                eventsUrl: Swift.String,
                forksUrl: Swift.String,
                gitCommitsUrl: Swift.String,
                gitRefsUrl: Swift.String,
                gitTagsUrl: Swift.String,
                gitUrl: Swift.String? = nil,
                issueCommentUrl: Swift.String,
                issueEventsUrl: Swift.String,
                issuesUrl: Swift.String,
                keysUrl: Swift.String,
                labelsUrl: Swift.String,
                languagesUrl: Swift.String,
                mergesUrl: Swift.String,
                milestonesUrl: Swift.String,
                notificationsUrl: Swift.String,
                pullsUrl: Swift.String,
                releasesUrl: Swift.String,
                sshUrl: Swift.String? = nil,
                stargazersUrl: Swift.String,
                statusesUrl: Swift.String,
                subscribersUrl: Swift.String,
                subscriptionUrl: Swift.String,
                tagsUrl: Swift.String,
                teamsUrl: Swift.String,
                treesUrl: Swift.String,
                cloneUrl: Swift.String? = nil,
                mirrorUrl: Swift.String? = nil,
                hooksUrl: Swift.String,
                svnUrl: Swift.String? = nil,
                homepage: Swift.String? = nil,
                language: Swift.String? = nil,
                forksCount: Swift.Int? = nil,
                stargazersCount: Swift.Int? = nil,
                watchersCount: Swift.Int? = nil,
                size: Swift.Int? = nil,
                defaultBranch: Swift.String? = nil,
                openIssuesCount: Swift.Int? = nil,
                isTemplate: Swift.Bool? = nil,
                topics: [Swift.String]? = nil,
                hasIssues: Swift.Bool? = nil,
                hasProjects: Swift.Bool? = nil,
                hasWiki: Swift.Bool? = nil,
                hasPages: Swift.Bool? = nil,
                hasDownloads: Swift.Bool? = nil,
                hasDiscussions: Swift.Bool? = nil,
                archived: Swift.Bool? = nil,
                disabled: Swift.Bool? = nil,
                visibility: Swift.String? = nil,
                pushedAt: Foundation.Date? = nil,
                createdAt: Foundation.Date? = nil,
                updatedAt: Foundation.Date? = nil,
                permissions: Components.Schemas.MinimalRepository.PermissionsPayload? = nil,
                roleName: Swift.String? = nil,
                tempCloneToken: Swift.String? = nil,
                deleteBranchOnMerge: Swift.Bool? = nil,
                subscribersCount: Swift.Int? = nil,
                networkCount: Swift.Int? = nil,
                codeOfConduct: Components.Schemas.CodeOfConduct? = nil,
                license: Components.Schemas.MinimalRepository.LicensePayload? = nil,
                forks: Swift.Int? = nil,
                openIssues: Swift.Int? = nil,
                watchers: Swift.Int? = nil,
                allowForking: Swift.Bool? = nil,
                webCommitSignoffRequired: Swift.Bool? = nil,
                securityAndAnalysis: Components.Schemas.SecurityAndAnalysis? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.fullName = fullName
                self.owner = owner
                self._private = _private
                self.htmlUrl = htmlUrl
                self.description = description
                self.fork = fork
                self.url = url
                self.archiveUrl = archiveUrl
                self.assigneesUrl = assigneesUrl
                self.blobsUrl = blobsUrl
                self.branchesUrl = branchesUrl
                self.collaboratorsUrl = collaboratorsUrl
                self.commentsUrl = commentsUrl
                self.commitsUrl = commitsUrl
                self.compareUrl = compareUrl
                self.contentsUrl = contentsUrl
                self.contributorsUrl = contributorsUrl
                self.deploymentsUrl = deploymentsUrl
                self.downloadsUrl = downloadsUrl
                self.eventsUrl = eventsUrl
                self.forksUrl = forksUrl
                self.gitCommitsUrl = gitCommitsUrl
                self.gitRefsUrl = gitRefsUrl
                self.gitTagsUrl = gitTagsUrl
                self.gitUrl = gitUrl
                self.issueCommentUrl = issueCommentUrl
                self.issueEventsUrl = issueEventsUrl
                self.issuesUrl = issuesUrl
                self.keysUrl = keysUrl
                self.labelsUrl = labelsUrl
                self.languagesUrl = languagesUrl
                self.mergesUrl = mergesUrl
                self.milestonesUrl = milestonesUrl
                self.notificationsUrl = notificationsUrl
                self.pullsUrl = pullsUrl
                self.releasesUrl = releasesUrl
                self.sshUrl = sshUrl
                self.stargazersUrl = stargazersUrl
                self.statusesUrl = statusesUrl
                self.subscribersUrl = subscribersUrl
                self.subscriptionUrl = subscriptionUrl
                self.tagsUrl = tagsUrl
                self.teamsUrl = teamsUrl
                self.treesUrl = treesUrl
                self.cloneUrl = cloneUrl
                self.mirrorUrl = mirrorUrl
                self.hooksUrl = hooksUrl
                self.svnUrl = svnUrl
                self.homepage = homepage
                self.language = language
                self.forksCount = forksCount
                self.stargazersCount = stargazersCount
                self.watchersCount = watchersCount
                self.size = size
                self.defaultBranch = defaultBranch
                self.openIssuesCount = openIssuesCount
                self.isTemplate = isTemplate
                self.topics = topics
                self.hasIssues = hasIssues
                self.hasProjects = hasProjects
                self.hasWiki = hasWiki
                self.hasPages = hasPages
                self.hasDownloads = hasDownloads
                self.hasDiscussions = hasDiscussions
                self.archived = archived
                self.disabled = disabled
                self.visibility = visibility
                self.pushedAt = pushedAt
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.permissions = permissions
                self.roleName = roleName
                self.tempCloneToken = tempCloneToken
                self.deleteBranchOnMerge = deleteBranchOnMerge
                self.subscribersCount = subscribersCount
                self.networkCount = networkCount
                self.codeOfConduct = codeOfConduct
                self.license = license
                self.forks = forks
                self.openIssues = openIssues
                self.watchers = watchers
                self.allowForking = allowForking
                self.webCommitSignoffRequired = webCommitSignoffRequired
                self.securityAndAnalysis = securityAndAnalysis
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case name
                case fullName = "full_name"
                case owner
                case _private = "private"
                case htmlUrl = "html_url"
                case description
                case fork
                case url
                case archiveUrl = "archive_url"
                case assigneesUrl = "assignees_url"
                case blobsUrl = "blobs_url"
                case branchesUrl = "branches_url"
                case collaboratorsUrl = "collaborators_url"
                case commentsUrl = "comments_url"
                case commitsUrl = "commits_url"
                case compareUrl = "compare_url"
                case contentsUrl = "contents_url"
                case contributorsUrl = "contributors_url"
                case deploymentsUrl = "deployments_url"
                case downloadsUrl = "downloads_url"
                case eventsUrl = "events_url"
                case forksUrl = "forks_url"
                case gitCommitsUrl = "git_commits_url"
                case gitRefsUrl = "git_refs_url"
                case gitTagsUrl = "git_tags_url"
                case gitUrl = "git_url"
                case issueCommentUrl = "issue_comment_url"
                case issueEventsUrl = "issue_events_url"
                case issuesUrl = "issues_url"
                case keysUrl = "keys_url"
                case labelsUrl = "labels_url"
                case languagesUrl = "languages_url"
                case mergesUrl = "merges_url"
                case milestonesUrl = "milestones_url"
                case notificationsUrl = "notifications_url"
                case pullsUrl = "pulls_url"
                case releasesUrl = "releases_url"
                case sshUrl = "ssh_url"
                case stargazersUrl = "stargazers_url"
                case statusesUrl = "statuses_url"
                case subscribersUrl = "subscribers_url"
                case subscriptionUrl = "subscription_url"
                case tagsUrl = "tags_url"
                case teamsUrl = "teams_url"
                case treesUrl = "trees_url"
                case cloneUrl = "clone_url"
                case mirrorUrl = "mirror_url"
                case hooksUrl = "hooks_url"
                case svnUrl = "svn_url"
                case homepage
                case language
                case forksCount = "forks_count"
                case stargazersCount = "stargazers_count"
                case watchersCount = "watchers_count"
                case size
                case defaultBranch = "default_branch"
                case openIssuesCount = "open_issues_count"
                case isTemplate = "is_template"
                case topics
                case hasIssues = "has_issues"
                case hasProjects = "has_projects"
                case hasWiki = "has_wiki"
                case hasPages = "has_pages"
                case hasDownloads = "has_downloads"
                case hasDiscussions = "has_discussions"
                case archived
                case disabled
                case visibility
                case pushedAt = "pushed_at"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case permissions
                case roleName = "role_name"
                case tempCloneToken = "temp_clone_token"
                case deleteBranchOnMerge = "delete_branch_on_merge"
                case subscribersCount = "subscribers_count"
                case networkCount = "network_count"
                case codeOfConduct = "code_of_conduct"
                case license
                case forks
                case openIssues = "open_issues"
                case watchers
                case allowForking = "allow_forking"
                case webCommitSignoffRequired = "web_commit_signoff_required"
                case securityAndAnalysis = "security_and_analysis"
            }
        }
        /// An object without any properties.
        ///
        /// - Remark: Generated from `#/components/schemas/empty-object`.
        public struct EmptyObject: Codable, Hashable, Sendable {
            /// Creates a new `EmptyObject`.
            public init() {}
            public init(from decoder: any Decoder) throws {
                try decoder.ensureNoAdditionalProperties(knownKeys: [])
            }
        }
        /// Groups of organization members that gives permissions on specified repositories.
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-team-simple`.
        public struct NullableTeamSimple: Codable, Hashable, Sendable {
            /// Unique identifier of the team
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/node_id`.
            public var nodeId: Swift.String
            /// URL for the team
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/members_url`.
            public var membersUrl: Swift.String
            /// Name of the team
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/name`.
            public var name: Swift.String
            /// Description of the team
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/description`.
            public var description: Swift.String?
            /// Permission that the team will have for its repositories
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/permission`.
            public var permission: Swift.String
            /// The level of privacy this team should have
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/privacy`.
            public var privacy: Swift.String?
            /// The notification setting the team has set
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/notification_setting`.
            public var notificationSetting: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/repositories_url`.
            public var repositoriesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/slug`.
            public var slug: Swift.String
            /// Distinguished Name (DN) that team maps to within LDAP environment
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-team-simple/ldap_dn`.
            public var ldapDn: Swift.String?
            /// Creates a new `NullableTeamSimple`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the team
            ///   - nodeId:
            ///   - url: URL for the team
            ///   - membersUrl:
            ///   - name: Name of the team
            ///   - description: Description of the team
            ///   - permission: Permission that the team will have for its repositories
            ///   - privacy: The level of privacy this team should have
            ///   - notificationSetting: The notification setting the team has set
            ///   - htmlUrl:
            ///   - repositoriesUrl:
            ///   - slug:
            ///   - ldapDn: Distinguished Name (DN) that team maps to within LDAP environment
            public init(
                id: Swift.Int,
                nodeId: Swift.String,
                url: Swift.String,
                membersUrl: Swift.String,
                name: Swift.String,
                description: Swift.String? = nil,
                permission: Swift.String,
                privacy: Swift.String? = nil,
                notificationSetting: Swift.String? = nil,
                htmlUrl: Swift.String,
                repositoriesUrl: Swift.String,
                slug: Swift.String,
                ldapDn: Swift.String? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.url = url
                self.membersUrl = membersUrl
                self.name = name
                self.description = description
                self.permission = permission
                self.privacy = privacy
                self.notificationSetting = notificationSetting
                self.htmlUrl = htmlUrl
                self.repositoriesUrl = repositoriesUrl
                self.slug = slug
                self.ldapDn = ldapDn
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case url
                case membersUrl = "members_url"
                case name
                case description
                case permission
                case privacy
                case notificationSetting = "notification_setting"
                case htmlUrl = "html_url"
                case repositoriesUrl = "repositories_url"
                case slug
                case ldapDn = "ldap_dn"
            }
        }
        /// Groups of organization members that gives permissions on specified repositories.
        ///
        /// - Remark: Generated from `#/components/schemas/team`.
        public struct Team: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/team/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/team/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/slug`.
            public var slug: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/team/privacy`.
            public var privacy: Swift.String?
            /// - Remark: Generated from `#/components/schemas/team/notification_setting`.
            public var notificationSetting: Swift.String?
            /// - Remark: Generated from `#/components/schemas/team/permission`.
            public var permission: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/team/permissions/pull`.
                public var pull: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/team/permissions/triage`.
                public var triage: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/team/permissions/push`.
                public var push: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/team/permissions/maintain`.
                public var maintain: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/team/permissions/admin`.
                public var admin: Swift.Bool
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - pull:
                ///   - triage:
                ///   - push:
                ///   - maintain:
                ///   - admin:
                public init(
                    pull: Swift.Bool,
                    triage: Swift.Bool,
                    push: Swift.Bool,
                    maintain: Swift.Bool,
                    admin: Swift.Bool
                ) {
                    self.pull = pull
                    self.triage = triage
                    self.push = push
                    self.maintain = maintain
                    self.admin = admin
                }
                public enum CodingKeys: String, CodingKey {
                    case pull
                    case triage
                    case push
                    case maintain
                    case admin
                }
            }
            /// - Remark: Generated from `#/components/schemas/team/permissions`.
            public var permissions: Components.Schemas.Team.PermissionsPayload?
            /// - Remark: Generated from `#/components/schemas/team/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/members_url`.
            public var membersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/repositories_url`.
            public var repositoriesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/team/parent`.
            public var parent: Components.Schemas.NullableTeamSimple?
            /// Creates a new `Team`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - nodeId:
            ///   - name:
            ///   - slug:
            ///   - description:
            ///   - privacy:
            ///   - notificationSetting:
            ///   - permission:
            ///   - permissions:
            ///   - url:
            ///   - htmlUrl:
            ///   - membersUrl:
            ///   - repositoriesUrl:
            ///   - parent:
            public init(
                id: Swift.Int,
                nodeId: Swift.String,
                name: Swift.String,
                slug: Swift.String,
                description: Swift.String? = nil,
                privacy: Swift.String? = nil,
                notificationSetting: Swift.String? = nil,
                permission: Swift.String,
                permissions: Components.Schemas.Team.PermissionsPayload? = nil,
                url: Swift.String,
                htmlUrl: Swift.String,
                membersUrl: Swift.String,
                repositoriesUrl: Swift.String,
                parent: Components.Schemas.NullableTeamSimple? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.slug = slug
                self.description = description
                self.privacy = privacy
                self.notificationSetting = notificationSetting
                self.permission = permission
                self.permissions = permissions
                self.url = url
                self.htmlUrl = htmlUrl
                self.membersUrl = membersUrl
                self.repositoriesUrl = repositoriesUrl
                self.parent = parent
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case name
                case slug
                case description
                case privacy
                case notificationSetting = "notification_setting"
                case permission
                case permissions
                case url
                case htmlUrl = "html_url"
                case membersUrl = "members_url"
                case repositoriesUrl = "repositories_url"
                case parent
            }
        }
        /// Custom property name and associated value
        ///
        /// - Remark: Generated from `#/components/schemas/custom-property-value`.
        public struct CustomPropertyValue: Codable, Hashable, Sendable {
            /// The name of the property
            ///
            /// - Remark: Generated from `#/components/schemas/custom-property-value/property_name`.
            public var propertyName: Swift.String
            /// The value assigned to the property
            ///
            /// - Remark: Generated from `#/components/schemas/custom-property-value/value`.
            @frozen public enum ValuePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/custom-property-value/value/case1`.
                case case1(Swift.String)
                /// - Remark: Generated from `#/components/schemas/custom-property-value/value/case2`.
                case case2([Swift.String])
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .case1(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .case2(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .case1(value):
                        try encoder.encodeToSingleValueContainer(value)
                    case let .case2(value):
                        try encoder.encodeToSingleValueContainer(value)
                    }
                }
            }
            /// The value assigned to the property
            ///
            /// - Remark: Generated from `#/components/schemas/custom-property-value/value`.
            public var value: Components.Schemas.CustomPropertyValue.ValuePayload?
            /// Creates a new `CustomPropertyValue`.
            ///
            /// - Parameters:
            ///   - propertyName: The name of the property
            ///   - value: The value assigned to the property
            public init(
                propertyName: Swift.String,
                value: Components.Schemas.CustomPropertyValue.ValuePayload? = nil
            ) {
                self.propertyName = propertyName
                self.value = value
            }
            public enum CodingKeys: String, CodingKey {
                case propertyName = "property_name"
                case value
            }
        }
        /// A repository on GitHub.
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-repository`.
        public struct NullableRepository: Codable, Hashable, Sendable {
            /// Unique identifier of the repository
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/nullable-repository/node_id`.
            public var nodeId: Swift.String
            /// The name of the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/full_name`.
            public var fullName: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/license`.
            public var license: Components.Schemas.NullableLicenseSimple?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/forks`.
            public var forks: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-repository/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/nullable-repository/permissions/admin`.
                public var admin: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/nullable-repository/permissions/pull`.
                public var pull: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/nullable-repository/permissions/triage`.
                public var triage: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/nullable-repository/permissions/push`.
                public var push: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/nullable-repository/permissions/maintain`.
                public var maintain: Swift.Bool?
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - admin:
                ///   - pull:
                ///   - triage:
                ///   - push:
                ///   - maintain:
                public init(
                    admin: Swift.Bool,
                    pull: Swift.Bool,
                    triage: Swift.Bool? = nil,
                    push: Swift.Bool,
                    maintain: Swift.Bool? = nil
                ) {
                    self.admin = admin
                    self.pull = pull
                    self.triage = triage
                    self.push = push
                    self.maintain = maintain
                }
                public enum CodingKeys: String, CodingKey {
                    case admin
                    case pull
                    case triage
                    case push
                    case maintain
                }
            }
            /// - Remark: Generated from `#/components/schemas/nullable-repository/permissions`.
            public var permissions: Components.Schemas.NullableRepository.PermissionsPayload?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/owner`.
            public var owner: Components.Schemas.SimpleUser
            /// Whether the repository is private or public.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/private`.
            public var _private: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/nullable-repository/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/fork`.
            public var fork: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/nullable-repository/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/archive_url`.
            public var archiveUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/assignees_url`.
            public var assigneesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/blobs_url`.
            public var blobsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/branches_url`.
            public var branchesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/collaborators_url`.
            public var collaboratorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/comments_url`.
            public var commentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/commits_url`.
            public var commitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/compare_url`.
            public var compareUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/contents_url`.
            public var contentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/contributors_url`.
            public var contributorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/deployments_url`.
            public var deploymentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/downloads_url`.
            public var downloadsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/forks_url`.
            public var forksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/git_commits_url`.
            public var gitCommitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/git_refs_url`.
            public var gitRefsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/git_tags_url`.
            public var gitTagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/git_url`.
            public var gitUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/issue_comment_url`.
            public var issueCommentUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/issue_events_url`.
            public var issueEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/issues_url`.
            public var issuesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/keys_url`.
            public var keysUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/labels_url`.
            public var labelsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/languages_url`.
            public var languagesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/merges_url`.
            public var mergesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/milestones_url`.
            public var milestonesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/notifications_url`.
            public var notificationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/pulls_url`.
            public var pullsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/releases_url`.
            public var releasesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/ssh_url`.
            public var sshUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/stargazers_url`.
            public var stargazersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/statuses_url`.
            public var statusesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/subscribers_url`.
            public var subscribersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/subscription_url`.
            public var subscriptionUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/tags_url`.
            public var tagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/teams_url`.
            public var teamsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/trees_url`.
            public var treesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/clone_url`.
            public var cloneUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/mirror_url`.
            public var mirrorUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/hooks_url`.
            public var hooksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/svn_url`.
            public var svnUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/homepage`.
            public var homepage: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/language`.
            public var language: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/forks_count`.
            public var forksCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-repository/stargazers_count`.
            public var stargazersCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-repository/watchers_count`.
            public var watchersCount: Swift.Int
            /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/size`.
            public var size: Swift.Int
            /// The default branch of the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/default_branch`.
            public var defaultBranch: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-repository/open_issues_count`.
            public var openIssuesCount: Swift.Int
            /// Whether this repository acts as a template that can be used to generate new repositories.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/is_template`.
            public var isTemplate: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/topics`.
            public var topics: [Swift.String]?
            /// Whether issues are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/has_issues`.
            public var hasIssues: Swift.Bool
            /// Whether projects are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/has_projects`.
            public var hasProjects: Swift.Bool
            /// Whether the wiki is enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/has_wiki`.
            public var hasWiki: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/nullable-repository/has_pages`.
            public var hasPages: Swift.Bool
            /// Whether downloads are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/has_downloads`.
            @available(*, deprecated)
            public var hasDownloads: Swift.Bool
            /// Whether discussions are enabled.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/has_discussions`.
            public var hasDiscussions: Swift.Bool?
            /// Whether the repository is archived.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/archived`.
            public var archived: Swift.Bool
            /// Returns whether or not this repository disabled.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/disabled`.
            public var disabled: Swift.Bool
            /// The repository visibility: public, private, or internal.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/visibility`.
            public var visibility: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/pushed_at`.
            public var pushedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/created_at`.
            public var createdAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/updated_at`.
            public var updatedAt: Foundation.Date?
            /// Whether to allow rebase merges for pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/allow_rebase_merge`.
            public var allowRebaseMerge: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/temp_clone_token`.
            public var tempCloneToken: Swift.String?
            /// Whether to allow squash merges for pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/allow_squash_merge`.
            public var allowSquashMerge: Swift.Bool?
            /// Whether to allow Auto-merge to be used on pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/allow_auto_merge`.
            public var allowAutoMerge: Swift.Bool?
            /// Whether to delete head branches when pull requests are merged
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/delete_branch_on_merge`.
            public var deleteBranchOnMerge: Swift.Bool?
            /// Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/allow_update_branch`.
            public var allowUpdateBranch: Swift.Bool?
            /// Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/use_squash_pr_title_as_default`.
            @available(*, deprecated)
            public var useSquashPrTitleAsDefault: Swift.Bool?
            /// The default value for a squash merge commit title:
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/squash_merge_commit_title`.
            @frozen public enum SquashMergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prTitle = "PR_TITLE"
                case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
            }
            /// The default value for a squash merge commit title:
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/squash_merge_commit_title`.
            public var squashMergeCommitTitle: Components.Schemas.NullableRepository.SquashMergeCommitTitlePayload?
            /// The default value for a squash merge commit message:
            ///
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/squash_merge_commit_message`.
            @frozen public enum SquashMergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prBody = "PR_BODY"
                case commitMessages = "COMMIT_MESSAGES"
                case blank = "BLANK"
            }
            /// The default value for a squash merge commit message:
            ///
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/squash_merge_commit_message`.
            public var squashMergeCommitMessage: Components.Schemas.NullableRepository.SquashMergeCommitMessagePayload?
            /// The default value for a merge commit title.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/merge_commit_title`.
            @frozen public enum MergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prTitle = "PR_TITLE"
                case mergeMessage = "MERGE_MESSAGE"
            }
            /// The default value for a merge commit title.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/merge_commit_title`.
            public var mergeCommitTitle: Components.Schemas.NullableRepository.MergeCommitTitlePayload?
            /// The default value for a merge commit message.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/merge_commit_message`.
            @frozen public enum MergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prBody = "PR_BODY"
                case prTitle = "PR_TITLE"
                case blank = "BLANK"
            }
            /// The default value for a merge commit message.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/merge_commit_message`.
            public var mergeCommitMessage: Components.Schemas.NullableRepository.MergeCommitMessagePayload?
            /// Whether to allow merge commits for pull requests.
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/allow_merge_commit`.
            public var allowMergeCommit: Swift.Bool?
            /// Whether to allow forking this repo
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/allow_forking`.
            public var allowForking: Swift.Bool?
            /// Whether to require contributors to sign off on web-based commits
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/web_commit_signoff_required`.
            public var webCommitSignoffRequired: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/open_issues`.
            public var openIssues: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-repository/watchers`.
            public var watchers: Swift.Int
            /// - Remark: Generated from `#/components/schemas/nullable-repository/master_branch`.
            public var masterBranch: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-repository/starred_at`.
            public var starredAt: Swift.String?
            /// Whether anonymous git access is enabled for this repository
            ///
            /// - Remark: Generated from `#/components/schemas/nullable-repository/anonymous_access_enabled`.
            public var anonymousAccessEnabled: Swift.Bool?
            /// Creates a new `NullableRepository`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the repository
            ///   - nodeId:
            ///   - name: The name of the repository.
            ///   - fullName:
            ///   - license:
            ///   - forks:
            ///   - permissions:
            ///   - owner:
            ///   - _private: Whether the repository is private or public.
            ///   - htmlUrl:
            ///   - description:
            ///   - fork:
            ///   - url:
            ///   - archiveUrl:
            ///   - assigneesUrl:
            ///   - blobsUrl:
            ///   - branchesUrl:
            ///   - collaboratorsUrl:
            ///   - commentsUrl:
            ///   - commitsUrl:
            ///   - compareUrl:
            ///   - contentsUrl:
            ///   - contributorsUrl:
            ///   - deploymentsUrl:
            ///   - downloadsUrl:
            ///   - eventsUrl:
            ///   - forksUrl:
            ///   - gitCommitsUrl:
            ///   - gitRefsUrl:
            ///   - gitTagsUrl:
            ///   - gitUrl:
            ///   - issueCommentUrl:
            ///   - issueEventsUrl:
            ///   - issuesUrl:
            ///   - keysUrl:
            ///   - labelsUrl:
            ///   - languagesUrl:
            ///   - mergesUrl:
            ///   - milestonesUrl:
            ///   - notificationsUrl:
            ///   - pullsUrl:
            ///   - releasesUrl:
            ///   - sshUrl:
            ///   - stargazersUrl:
            ///   - statusesUrl:
            ///   - subscribersUrl:
            ///   - subscriptionUrl:
            ///   - tagsUrl:
            ///   - teamsUrl:
            ///   - treesUrl:
            ///   - cloneUrl:
            ///   - mirrorUrl:
            ///   - hooksUrl:
            ///   - svnUrl:
            ///   - homepage:
            ///   - language:
            ///   - forksCount:
            ///   - stargazersCount:
            ///   - watchersCount:
            ///   - size: The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///   - defaultBranch: The default branch of the repository.
            ///   - openIssuesCount:
            ///   - isTemplate: Whether this repository acts as a template that can be used to generate new repositories.
            ///   - topics:
            ///   - hasIssues: Whether issues are enabled.
            ///   - hasProjects: Whether projects are enabled.
            ///   - hasWiki: Whether the wiki is enabled.
            ///   - hasPages:
            ///   - hasDownloads: Whether downloads are enabled.
            ///   - hasDiscussions: Whether discussions are enabled.
            ///   - archived: Whether the repository is archived.
            ///   - disabled: Returns whether or not this repository disabled.
            ///   - visibility: The repository visibility: public, private, or internal.
            ///   - pushedAt:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - allowRebaseMerge: Whether to allow rebase merges for pull requests.
            ///   - tempCloneToken:
            ///   - allowSquashMerge: Whether to allow squash merges for pull requests.
            ///   - allowAutoMerge: Whether to allow Auto-merge to be used on pull requests.
            ///   - deleteBranchOnMerge: Whether to delete head branches when pull requests are merged
            ///   - allowUpdateBranch: Whether or not a pull request head branch that is behind its base branch can always be updated even if it is not required to be up to date before merging.
            ///   - useSquashPrTitleAsDefault: Whether a squash merge commit can use the pull request title as default. **This property is closing down. Please use `squash_merge_commit_title` instead.
            ///   - squashMergeCommitTitle: The default value for a squash merge commit title:
            ///   - squashMergeCommitMessage: The default value for a squash merge commit message:
            ///   - mergeCommitTitle: The default value for a merge commit title.
            ///   - mergeCommitMessage: The default value for a merge commit message.
            ///   - allowMergeCommit: Whether to allow merge commits for pull requests.
            ///   - allowForking: Whether to allow forking this repo
            ///   - webCommitSignoffRequired: Whether to require contributors to sign off on web-based commits
            ///   - openIssues:
            ///   - watchers:
            ///   - masterBranch:
            ///   - starredAt:
            ///   - anonymousAccessEnabled: Whether anonymous git access is enabled for this repository
            public init(
                id: Swift.Int64,
                nodeId: Swift.String,
                name: Swift.String,
                fullName: Swift.String,
                license: Components.Schemas.NullableLicenseSimple? = nil,
                forks: Swift.Int,
                permissions: Components.Schemas.NullableRepository.PermissionsPayload? = nil,
                owner: Components.Schemas.SimpleUser,
                _private: Swift.Bool,
                htmlUrl: Swift.String,
                description: Swift.String? = nil,
                fork: Swift.Bool,
                url: Swift.String,
                archiveUrl: Swift.String,
                assigneesUrl: Swift.String,
                blobsUrl: Swift.String,
                branchesUrl: Swift.String,
                collaboratorsUrl: Swift.String,
                commentsUrl: Swift.String,
                commitsUrl: Swift.String,
                compareUrl: Swift.String,
                contentsUrl: Swift.String,
                contributorsUrl: Swift.String,
                deploymentsUrl: Swift.String,
                downloadsUrl: Swift.String,
                eventsUrl: Swift.String,
                forksUrl: Swift.String,
                gitCommitsUrl: Swift.String,
                gitRefsUrl: Swift.String,
                gitTagsUrl: Swift.String,
                gitUrl: Swift.String,
                issueCommentUrl: Swift.String,
                issueEventsUrl: Swift.String,
                issuesUrl: Swift.String,
                keysUrl: Swift.String,
                labelsUrl: Swift.String,
                languagesUrl: Swift.String,
                mergesUrl: Swift.String,
                milestonesUrl: Swift.String,
                notificationsUrl: Swift.String,
                pullsUrl: Swift.String,
                releasesUrl: Swift.String,
                sshUrl: Swift.String,
                stargazersUrl: Swift.String,
                statusesUrl: Swift.String,
                subscribersUrl: Swift.String,
                subscriptionUrl: Swift.String,
                tagsUrl: Swift.String,
                teamsUrl: Swift.String,
                treesUrl: Swift.String,
                cloneUrl: Swift.String,
                mirrorUrl: Swift.String? = nil,
                hooksUrl: Swift.String,
                svnUrl: Swift.String,
                homepage: Swift.String? = nil,
                language: Swift.String? = nil,
                forksCount: Swift.Int,
                stargazersCount: Swift.Int,
                watchersCount: Swift.Int,
                size: Swift.Int,
                defaultBranch: Swift.String,
                openIssuesCount: Swift.Int,
                isTemplate: Swift.Bool? = nil,
                topics: [Swift.String]? = nil,
                hasIssues: Swift.Bool,
                hasProjects: Swift.Bool,
                hasWiki: Swift.Bool,
                hasPages: Swift.Bool,
                hasDownloads: Swift.Bool,
                hasDiscussions: Swift.Bool? = nil,
                archived: Swift.Bool,
                disabled: Swift.Bool,
                visibility: Swift.String? = nil,
                pushedAt: Foundation.Date? = nil,
                createdAt: Foundation.Date? = nil,
                updatedAt: Foundation.Date? = nil,
                allowRebaseMerge: Swift.Bool? = nil,
                tempCloneToken: Swift.String? = nil,
                allowSquashMerge: Swift.Bool? = nil,
                allowAutoMerge: Swift.Bool? = nil,
                deleteBranchOnMerge: Swift.Bool? = nil,
                allowUpdateBranch: Swift.Bool? = nil,
                useSquashPrTitleAsDefault: Swift.Bool? = nil,
                squashMergeCommitTitle: Components.Schemas.NullableRepository.SquashMergeCommitTitlePayload? = nil,
                squashMergeCommitMessage: Components.Schemas.NullableRepository.SquashMergeCommitMessagePayload? = nil,
                mergeCommitTitle: Components.Schemas.NullableRepository.MergeCommitTitlePayload? = nil,
                mergeCommitMessage: Components.Schemas.NullableRepository.MergeCommitMessagePayload? = nil,
                allowMergeCommit: Swift.Bool? = nil,
                allowForking: Swift.Bool? = nil,
                webCommitSignoffRequired: Swift.Bool? = nil,
                openIssues: Swift.Int,
                watchers: Swift.Int,
                masterBranch: Swift.String? = nil,
                starredAt: Swift.String? = nil,
                anonymousAccessEnabled: Swift.Bool? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.fullName = fullName
                self.license = license
                self.forks = forks
                self.permissions = permissions
                self.owner = owner
                self._private = _private
                self.htmlUrl = htmlUrl
                self.description = description
                self.fork = fork
                self.url = url
                self.archiveUrl = archiveUrl
                self.assigneesUrl = assigneesUrl
                self.blobsUrl = blobsUrl
                self.branchesUrl = branchesUrl
                self.collaboratorsUrl = collaboratorsUrl
                self.commentsUrl = commentsUrl
                self.commitsUrl = commitsUrl
                self.compareUrl = compareUrl
                self.contentsUrl = contentsUrl
                self.contributorsUrl = contributorsUrl
                self.deploymentsUrl = deploymentsUrl
                self.downloadsUrl = downloadsUrl
                self.eventsUrl = eventsUrl
                self.forksUrl = forksUrl
                self.gitCommitsUrl = gitCommitsUrl
                self.gitRefsUrl = gitRefsUrl
                self.gitTagsUrl = gitTagsUrl
                self.gitUrl = gitUrl
                self.issueCommentUrl = issueCommentUrl
                self.issueEventsUrl = issueEventsUrl
                self.issuesUrl = issuesUrl
                self.keysUrl = keysUrl
                self.labelsUrl = labelsUrl
                self.languagesUrl = languagesUrl
                self.mergesUrl = mergesUrl
                self.milestonesUrl = milestonesUrl
                self.notificationsUrl = notificationsUrl
                self.pullsUrl = pullsUrl
                self.releasesUrl = releasesUrl
                self.sshUrl = sshUrl
                self.stargazersUrl = stargazersUrl
                self.statusesUrl = statusesUrl
                self.subscribersUrl = subscribersUrl
                self.subscriptionUrl = subscriptionUrl
                self.tagsUrl = tagsUrl
                self.teamsUrl = teamsUrl
                self.treesUrl = treesUrl
                self.cloneUrl = cloneUrl
                self.mirrorUrl = mirrorUrl
                self.hooksUrl = hooksUrl
                self.svnUrl = svnUrl
                self.homepage = homepage
                self.language = language
                self.forksCount = forksCount
                self.stargazersCount = stargazersCount
                self.watchersCount = watchersCount
                self.size = size
                self.defaultBranch = defaultBranch
                self.openIssuesCount = openIssuesCount
                self.isTemplate = isTemplate
                self.topics = topics
                self.hasIssues = hasIssues
                self.hasProjects = hasProjects
                self.hasWiki = hasWiki
                self.hasPages = hasPages
                self.hasDownloads = hasDownloads
                self.hasDiscussions = hasDiscussions
                self.archived = archived
                self.disabled = disabled
                self.visibility = visibility
                self.pushedAt = pushedAt
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.allowRebaseMerge = allowRebaseMerge
                self.tempCloneToken = tempCloneToken
                self.allowSquashMerge = allowSquashMerge
                self.allowAutoMerge = allowAutoMerge
                self.deleteBranchOnMerge = deleteBranchOnMerge
                self.allowUpdateBranch = allowUpdateBranch
                self.useSquashPrTitleAsDefault = useSquashPrTitleAsDefault
                self.squashMergeCommitTitle = squashMergeCommitTitle
                self.squashMergeCommitMessage = squashMergeCommitMessage
                self.mergeCommitTitle = mergeCommitTitle
                self.mergeCommitMessage = mergeCommitMessage
                self.allowMergeCommit = allowMergeCommit
                self.allowForking = allowForking
                self.webCommitSignoffRequired = webCommitSignoffRequired
                self.openIssues = openIssues
                self.watchers = watchers
                self.masterBranch = masterBranch
                self.starredAt = starredAt
                self.anonymousAccessEnabled = anonymousAccessEnabled
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case name
                case fullName = "full_name"
                case license
                case forks
                case permissions
                case owner
                case _private = "private"
                case htmlUrl = "html_url"
                case description
                case fork
                case url
                case archiveUrl = "archive_url"
                case assigneesUrl = "assignees_url"
                case blobsUrl = "blobs_url"
                case branchesUrl = "branches_url"
                case collaboratorsUrl = "collaborators_url"
                case commentsUrl = "comments_url"
                case commitsUrl = "commits_url"
                case compareUrl = "compare_url"
                case contentsUrl = "contents_url"
                case contributorsUrl = "contributors_url"
                case deploymentsUrl = "deployments_url"
                case downloadsUrl = "downloads_url"
                case eventsUrl = "events_url"
                case forksUrl = "forks_url"
                case gitCommitsUrl = "git_commits_url"
                case gitRefsUrl = "git_refs_url"
                case gitTagsUrl = "git_tags_url"
                case gitUrl = "git_url"
                case issueCommentUrl = "issue_comment_url"
                case issueEventsUrl = "issue_events_url"
                case issuesUrl = "issues_url"
                case keysUrl = "keys_url"
                case labelsUrl = "labels_url"
                case languagesUrl = "languages_url"
                case mergesUrl = "merges_url"
                case milestonesUrl = "milestones_url"
                case notificationsUrl = "notifications_url"
                case pullsUrl = "pulls_url"
                case releasesUrl = "releases_url"
                case sshUrl = "ssh_url"
                case stargazersUrl = "stargazers_url"
                case statusesUrl = "statuses_url"
                case subscribersUrl = "subscribers_url"
                case subscriptionUrl = "subscription_url"
                case tagsUrl = "tags_url"
                case teamsUrl = "teams_url"
                case treesUrl = "trees_url"
                case cloneUrl = "clone_url"
                case mirrorUrl = "mirror_url"
                case hooksUrl = "hooks_url"
                case svnUrl = "svn_url"
                case homepage
                case language
                case forksCount = "forks_count"
                case stargazersCount = "stargazers_count"
                case watchersCount = "watchers_count"
                case size
                case defaultBranch = "default_branch"
                case openIssuesCount = "open_issues_count"
                case isTemplate = "is_template"
                case topics
                case hasIssues = "has_issues"
                case hasProjects = "has_projects"
                case hasWiki = "has_wiki"
                case hasPages = "has_pages"
                case hasDownloads = "has_downloads"
                case hasDiscussions = "has_discussions"
                case archived
                case disabled
                case visibility
                case pushedAt = "pushed_at"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case allowRebaseMerge = "allow_rebase_merge"
                case tempCloneToken = "temp_clone_token"
                case allowSquashMerge = "allow_squash_merge"
                case allowAutoMerge = "allow_auto_merge"
                case deleteBranchOnMerge = "delete_branch_on_merge"
                case allowUpdateBranch = "allow_update_branch"
                case useSquashPrTitleAsDefault = "use_squash_pr_title_as_default"
                case squashMergeCommitTitle = "squash_merge_commit_title"
                case squashMergeCommitMessage = "squash_merge_commit_message"
                case mergeCommitTitle = "merge_commit_title"
                case mergeCommitMessage = "merge_commit_message"
                case allowMergeCommit = "allow_merge_commit"
                case allowForking = "allow_forking"
                case webCommitSignoffRequired = "web_commit_signoff_required"
                case openIssues = "open_issues"
                case watchers
                case masterBranch = "master_branch"
                case starredAt = "starred_at"
                case anonymousAccessEnabled = "anonymous_access_enabled"
            }
        }
        /// Code of Conduct Simple
        ///
        /// - Remark: Generated from `#/components/schemas/code-of-conduct-simple`.
        public struct CodeOfConductSimple: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/code-of-conduct-simple/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/code-of-conduct-simple/key`.
            public var key: Swift.String
            /// - Remark: Generated from `#/components/schemas/code-of-conduct-simple/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/code-of-conduct-simple/html_url`.
            public var htmlUrl: Swift.String?
            /// Creates a new `CodeOfConductSimple`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - key:
            ///   - name:
            ///   - htmlUrl:
            public init(
                url: Swift.String,
                key: Swift.String,
                name: Swift.String,
                htmlUrl: Swift.String? = nil
            ) {
                self.url = url
                self.key = key
                self.name = name
                self.htmlUrl = htmlUrl
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case key
                case name
                case htmlUrl = "html_url"
            }
        }
        /// Full Repository
        ///
        /// - Remark: Generated from `#/components/schemas/full-repository`.
        public struct FullRepository: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/full-repository/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/full-repository/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/full_name`.
            public var fullName: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/owner`.
            public var owner: Components.Schemas.SimpleUser
            /// - Remark: Generated from `#/components/schemas/full-repository/private`.
            public var _private: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/full-repository/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/full-repository/fork`.
            public var fork: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/full-repository/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/archive_url`.
            public var archiveUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/assignees_url`.
            public var assigneesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/blobs_url`.
            public var blobsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/branches_url`.
            public var branchesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/collaborators_url`.
            public var collaboratorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/comments_url`.
            public var commentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/commits_url`.
            public var commitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/compare_url`.
            public var compareUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/contents_url`.
            public var contentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/contributors_url`.
            public var contributorsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/deployments_url`.
            public var deploymentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/downloads_url`.
            public var downloadsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/forks_url`.
            public var forksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/git_commits_url`.
            public var gitCommitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/git_refs_url`.
            public var gitRefsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/git_tags_url`.
            public var gitTagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/git_url`.
            public var gitUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/issue_comment_url`.
            public var issueCommentUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/issue_events_url`.
            public var issueEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/issues_url`.
            public var issuesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/keys_url`.
            public var keysUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/labels_url`.
            public var labelsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/languages_url`.
            public var languagesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/merges_url`.
            public var mergesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/milestones_url`.
            public var milestonesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/notifications_url`.
            public var notificationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/pulls_url`.
            public var pullsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/releases_url`.
            public var releasesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/ssh_url`.
            public var sshUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/stargazers_url`.
            public var stargazersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/statuses_url`.
            public var statusesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/subscribers_url`.
            public var subscribersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/subscription_url`.
            public var subscriptionUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/tags_url`.
            public var tagsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/teams_url`.
            public var teamsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/trees_url`.
            public var treesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/clone_url`.
            public var cloneUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/mirror_url`.
            public var mirrorUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/full-repository/hooks_url`.
            public var hooksUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/svn_url`.
            public var svnUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/homepage`.
            public var homepage: Swift.String?
            /// - Remark: Generated from `#/components/schemas/full-repository/language`.
            public var language: Swift.String?
            /// - Remark: Generated from `#/components/schemas/full-repository/forks_count`.
            public var forksCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/stargazers_count`.
            public var stargazersCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/watchers_count`.
            public var watchersCount: Swift.Int
            /// The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/size`.
            public var size: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/default_branch`.
            public var defaultBranch: Swift.String
            /// - Remark: Generated from `#/components/schemas/full-repository/open_issues_count`.
            public var openIssuesCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/is_template`.
            public var isTemplate: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/topics`.
            public var topics: [Swift.String]?
            /// - Remark: Generated from `#/components/schemas/full-repository/has_issues`.
            public var hasIssues: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/full-repository/has_projects`.
            public var hasProjects: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/full-repository/has_wiki`.
            public var hasWiki: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/full-repository/has_pages`.
            public var hasPages: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/full-repository/has_downloads`.
            public var hasDownloads: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/has_discussions`.
            public var hasDiscussions: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/full-repository/archived`.
            public var archived: Swift.Bool
            /// Returns whether or not this repository disabled.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/disabled`.
            public var disabled: Swift.Bool
            /// The repository visibility: public, private, or internal.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/visibility`.
            public var visibility: Swift.String?
            /// - Remark: Generated from `#/components/schemas/full-repository/pushed_at`.
            public var pushedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/full-repository/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/full-repository/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/full-repository/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/full-repository/permissions/admin`.
                public var admin: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/full-repository/permissions/maintain`.
                public var maintain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/full-repository/permissions/push`.
                public var push: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/full-repository/permissions/triage`.
                public var triage: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/full-repository/permissions/pull`.
                public var pull: Swift.Bool
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - admin:
                ///   - maintain:
                ///   - push:
                ///   - triage:
                ///   - pull:
                public init(
                    admin: Swift.Bool,
                    maintain: Swift.Bool? = nil,
                    push: Swift.Bool,
                    triage: Swift.Bool? = nil,
                    pull: Swift.Bool
                ) {
                    self.admin = admin
                    self.maintain = maintain
                    self.push = push
                    self.triage = triage
                    self.pull = pull
                }
                public enum CodingKeys: String, CodingKey {
                    case admin
                    case maintain
                    case push
                    case triage
                    case pull
                }
            }
            /// - Remark: Generated from `#/components/schemas/full-repository/permissions`.
            public var permissions: Components.Schemas.FullRepository.PermissionsPayload?
            /// - Remark: Generated from `#/components/schemas/full-repository/allow_rebase_merge`.
            public var allowRebaseMerge: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/template_repository`.
            public var templateRepository: Components.Schemas.NullableRepository?
            /// - Remark: Generated from `#/components/schemas/full-repository/temp_clone_token`.
            public var tempCloneToken: Swift.String?
            /// - Remark: Generated from `#/components/schemas/full-repository/allow_squash_merge`.
            public var allowSquashMerge: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/allow_auto_merge`.
            public var allowAutoMerge: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/delete_branch_on_merge`.
            public var deleteBranchOnMerge: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/allow_merge_commit`.
            public var allowMergeCommit: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/allow_update_branch`.
            public var allowUpdateBranch: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/use_squash_pr_title_as_default`.
            public var useSquashPrTitleAsDefault: Swift.Bool?
            /// The default value for a squash merge commit title:
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/squash_merge_commit_title`.
            @frozen public enum SquashMergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prTitle = "PR_TITLE"
                case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
            }
            /// The default value for a squash merge commit title:
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/squash_merge_commit_title`.
            public var squashMergeCommitTitle: Components.Schemas.FullRepository.SquashMergeCommitTitlePayload?
            /// The default value for a squash merge commit message:
            ///
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/squash_merge_commit_message`.
            @frozen public enum SquashMergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prBody = "PR_BODY"
                case commitMessages = "COMMIT_MESSAGES"
                case blank = "BLANK"
            }
            /// The default value for a squash merge commit message:
            ///
            /// - `PR_BODY` - default to the pull request's body.
            /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/squash_merge_commit_message`.
            public var squashMergeCommitMessage: Components.Schemas.FullRepository.SquashMergeCommitMessagePayload?
            /// The default value for a merge commit title.
            ///
            ///   - `PR_TITLE` - default to the pull request's title.
            ///   - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/merge_commit_title`.
            @frozen public enum MergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prTitle = "PR_TITLE"
                case mergeMessage = "MERGE_MESSAGE"
            }
            /// The default value for a merge commit title.
            ///
            ///   - `PR_TITLE` - default to the pull request's title.
            ///   - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/merge_commit_title`.
            public var mergeCommitTitle: Components.Schemas.FullRepository.MergeCommitTitlePayload?
            /// The default value for a merge commit message.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/merge_commit_message`.
            @frozen public enum MergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case prBody = "PR_BODY"
                case prTitle = "PR_TITLE"
                case blank = "BLANK"
            }
            /// The default value for a merge commit message.
            ///
            /// - `PR_TITLE` - default to the pull request's title.
            /// - `PR_BODY` - default to the pull request's body.
            /// - `BLANK` - default to a blank commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/merge_commit_message`.
            public var mergeCommitMessage: Components.Schemas.FullRepository.MergeCommitMessagePayload?
            /// - Remark: Generated from `#/components/schemas/full-repository/allow_forking`.
            public var allowForking: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/web_commit_signoff_required`.
            public var webCommitSignoffRequired: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/subscribers_count`.
            public var subscribersCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/network_count`.
            public var networkCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/license`.
            public var license: Components.Schemas.NullableLicenseSimple?
            /// - Remark: Generated from `#/components/schemas/full-repository/organization`.
            public var organization: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/full-repository/parent`.
            public var parent: Components.Schemas.Repository?
            /// - Remark: Generated from `#/components/schemas/full-repository/source`.
            public var source: Components.Schemas.Repository?
            /// - Remark: Generated from `#/components/schemas/full-repository/forks`.
            public var forks: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/master_branch`.
            public var masterBranch: Swift.String?
            /// - Remark: Generated from `#/components/schemas/full-repository/open_issues`.
            public var openIssues: Swift.Int
            /// - Remark: Generated from `#/components/schemas/full-repository/watchers`.
            public var watchers: Swift.Int
            /// Whether anonymous git access is allowed.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/anonymous_access_enabled`.
            public var anonymousAccessEnabled: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/full-repository/code_of_conduct`.
            public var codeOfConduct: Components.Schemas.CodeOfConductSimple?
            /// - Remark: Generated from `#/components/schemas/full-repository/security_and_analysis`.
            public var securityAndAnalysis: Components.Schemas.SecurityAndAnalysis?
            /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/custom_properties`.
            public struct CustomPropertiesPayload: Codable, Hashable, Sendable {
                /// A container of undocumented properties.
                public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                /// Creates a new `CustomPropertiesPayload`.
                ///
                /// - Parameters:
                ///   - additionalProperties: A container of undocumented properties.
                public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                    self.additionalProperties = additionalProperties
                }
                public init(from decoder: any Decoder) throws {
                    additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeAdditionalProperties(additionalProperties)
                }
            }
            /// The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
            ///
            /// - Remark: Generated from `#/components/schemas/full-repository/custom_properties`.
            public var customProperties: Components.Schemas.FullRepository.CustomPropertiesPayload?
            /// Creates a new `FullRepository`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - nodeId:
            ///   - name:
            ///   - fullName:
            ///   - owner:
            ///   - _private:
            ///   - htmlUrl:
            ///   - description:
            ///   - fork:
            ///   - url:
            ///   - archiveUrl:
            ///   - assigneesUrl:
            ///   - blobsUrl:
            ///   - branchesUrl:
            ///   - collaboratorsUrl:
            ///   - commentsUrl:
            ///   - commitsUrl:
            ///   - compareUrl:
            ///   - contentsUrl:
            ///   - contributorsUrl:
            ///   - deploymentsUrl:
            ///   - downloadsUrl:
            ///   - eventsUrl:
            ///   - forksUrl:
            ///   - gitCommitsUrl:
            ///   - gitRefsUrl:
            ///   - gitTagsUrl:
            ///   - gitUrl:
            ///   - issueCommentUrl:
            ///   - issueEventsUrl:
            ///   - issuesUrl:
            ///   - keysUrl:
            ///   - labelsUrl:
            ///   - languagesUrl:
            ///   - mergesUrl:
            ///   - milestonesUrl:
            ///   - notificationsUrl:
            ///   - pullsUrl:
            ///   - releasesUrl:
            ///   - sshUrl:
            ///   - stargazersUrl:
            ///   - statusesUrl:
            ///   - subscribersUrl:
            ///   - subscriptionUrl:
            ///   - tagsUrl:
            ///   - teamsUrl:
            ///   - treesUrl:
            ///   - cloneUrl:
            ///   - mirrorUrl:
            ///   - hooksUrl:
            ///   - svnUrl:
            ///   - homepage:
            ///   - language:
            ///   - forksCount:
            ///   - stargazersCount:
            ///   - watchersCount:
            ///   - size: The size of the repository, in kilobytes. Size is calculated hourly. When a repository is initially created, the size is 0.
            ///   - defaultBranch:
            ///   - openIssuesCount:
            ///   - isTemplate:
            ///   - topics:
            ///   - hasIssues:
            ///   - hasProjects:
            ///   - hasWiki:
            ///   - hasPages:
            ///   - hasDownloads:
            ///   - hasDiscussions:
            ///   - archived:
            ///   - disabled: Returns whether or not this repository disabled.
            ///   - visibility: The repository visibility: public, private, or internal.
            ///   - pushedAt:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - permissions:
            ///   - allowRebaseMerge:
            ///   - templateRepository:
            ///   - tempCloneToken:
            ///   - allowSquashMerge:
            ///   - allowAutoMerge:
            ///   - deleteBranchOnMerge:
            ///   - allowMergeCommit:
            ///   - allowUpdateBranch:
            ///   - useSquashPrTitleAsDefault:
            ///   - squashMergeCommitTitle: The default value for a squash merge commit title:
            ///   - squashMergeCommitMessage: The default value for a squash merge commit message:
            ///   - mergeCommitTitle: The default value for a merge commit title.
            ///   - mergeCommitMessage: The default value for a merge commit message.
            ///   - allowForking:
            ///   - webCommitSignoffRequired:
            ///   - subscribersCount:
            ///   - networkCount:
            ///   - license:
            ///   - organization:
            ///   - parent:
            ///   - source:
            ///   - forks:
            ///   - masterBranch:
            ///   - openIssues:
            ///   - watchers:
            ///   - anonymousAccessEnabled: Whether anonymous git access is allowed.
            ///   - codeOfConduct:
            ///   - securityAndAnalysis:
            ///   - customProperties: The custom properties that were defined for the repository. The keys are the custom property names, and the values are the corresponding custom property values.
            public init(
                id: Swift.Int64,
                nodeId: Swift.String,
                name: Swift.String,
                fullName: Swift.String,
                owner: Components.Schemas.SimpleUser,
                _private: Swift.Bool,
                htmlUrl: Swift.String,
                description: Swift.String? = nil,
                fork: Swift.Bool,
                url: Swift.String,
                archiveUrl: Swift.String,
                assigneesUrl: Swift.String,
                blobsUrl: Swift.String,
                branchesUrl: Swift.String,
                collaboratorsUrl: Swift.String,
                commentsUrl: Swift.String,
                commitsUrl: Swift.String,
                compareUrl: Swift.String,
                contentsUrl: Swift.String,
                contributorsUrl: Swift.String,
                deploymentsUrl: Swift.String,
                downloadsUrl: Swift.String,
                eventsUrl: Swift.String,
                forksUrl: Swift.String,
                gitCommitsUrl: Swift.String,
                gitRefsUrl: Swift.String,
                gitTagsUrl: Swift.String,
                gitUrl: Swift.String,
                issueCommentUrl: Swift.String,
                issueEventsUrl: Swift.String,
                issuesUrl: Swift.String,
                keysUrl: Swift.String,
                labelsUrl: Swift.String,
                languagesUrl: Swift.String,
                mergesUrl: Swift.String,
                milestonesUrl: Swift.String,
                notificationsUrl: Swift.String,
                pullsUrl: Swift.String,
                releasesUrl: Swift.String,
                sshUrl: Swift.String,
                stargazersUrl: Swift.String,
                statusesUrl: Swift.String,
                subscribersUrl: Swift.String,
                subscriptionUrl: Swift.String,
                tagsUrl: Swift.String,
                teamsUrl: Swift.String,
                treesUrl: Swift.String,
                cloneUrl: Swift.String,
                mirrorUrl: Swift.String? = nil,
                hooksUrl: Swift.String,
                svnUrl: Swift.String,
                homepage: Swift.String? = nil,
                language: Swift.String? = nil,
                forksCount: Swift.Int,
                stargazersCount: Swift.Int,
                watchersCount: Swift.Int,
                size: Swift.Int,
                defaultBranch: Swift.String,
                openIssuesCount: Swift.Int,
                isTemplate: Swift.Bool? = nil,
                topics: [Swift.String]? = nil,
                hasIssues: Swift.Bool,
                hasProjects: Swift.Bool,
                hasWiki: Swift.Bool,
                hasPages: Swift.Bool,
                hasDownloads: Swift.Bool? = nil,
                hasDiscussions: Swift.Bool,
                archived: Swift.Bool,
                disabled: Swift.Bool,
                visibility: Swift.String? = nil,
                pushedAt: Foundation.Date,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                permissions: Components.Schemas.FullRepository.PermissionsPayload? = nil,
                allowRebaseMerge: Swift.Bool? = nil,
                templateRepository: Components.Schemas.NullableRepository? = nil,
                tempCloneToken: Swift.String? = nil,
                allowSquashMerge: Swift.Bool? = nil,
                allowAutoMerge: Swift.Bool? = nil,
                deleteBranchOnMerge: Swift.Bool? = nil,
                allowMergeCommit: Swift.Bool? = nil,
                allowUpdateBranch: Swift.Bool? = nil,
                useSquashPrTitleAsDefault: Swift.Bool? = nil,
                squashMergeCommitTitle: Components.Schemas.FullRepository.SquashMergeCommitTitlePayload? = nil,
                squashMergeCommitMessage: Components.Schemas.FullRepository.SquashMergeCommitMessagePayload? = nil,
                mergeCommitTitle: Components.Schemas.FullRepository.MergeCommitTitlePayload? = nil,
                mergeCommitMessage: Components.Schemas.FullRepository.MergeCommitMessagePayload? = nil,
                allowForking: Swift.Bool? = nil,
                webCommitSignoffRequired: Swift.Bool? = nil,
                subscribersCount: Swift.Int,
                networkCount: Swift.Int,
                license: Components.Schemas.NullableLicenseSimple? = nil,
                organization: Components.Schemas.NullableSimpleUser? = nil,
                parent: Components.Schemas.Repository? = nil,
                source: Components.Schemas.Repository? = nil,
                forks: Swift.Int,
                masterBranch: Swift.String? = nil,
                openIssues: Swift.Int,
                watchers: Swift.Int,
                anonymousAccessEnabled: Swift.Bool? = nil,
                codeOfConduct: Components.Schemas.CodeOfConductSimple? = nil,
                securityAndAnalysis: Components.Schemas.SecurityAndAnalysis? = nil,
                customProperties: Components.Schemas.FullRepository.CustomPropertiesPayload? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.fullName = fullName
                self.owner = owner
                self._private = _private
                self.htmlUrl = htmlUrl
                self.description = description
                self.fork = fork
                self.url = url
                self.archiveUrl = archiveUrl
                self.assigneesUrl = assigneesUrl
                self.blobsUrl = blobsUrl
                self.branchesUrl = branchesUrl
                self.collaboratorsUrl = collaboratorsUrl
                self.commentsUrl = commentsUrl
                self.commitsUrl = commitsUrl
                self.compareUrl = compareUrl
                self.contentsUrl = contentsUrl
                self.contributorsUrl = contributorsUrl
                self.deploymentsUrl = deploymentsUrl
                self.downloadsUrl = downloadsUrl
                self.eventsUrl = eventsUrl
                self.forksUrl = forksUrl
                self.gitCommitsUrl = gitCommitsUrl
                self.gitRefsUrl = gitRefsUrl
                self.gitTagsUrl = gitTagsUrl
                self.gitUrl = gitUrl
                self.issueCommentUrl = issueCommentUrl
                self.issueEventsUrl = issueEventsUrl
                self.issuesUrl = issuesUrl
                self.keysUrl = keysUrl
                self.labelsUrl = labelsUrl
                self.languagesUrl = languagesUrl
                self.mergesUrl = mergesUrl
                self.milestonesUrl = milestonesUrl
                self.notificationsUrl = notificationsUrl
                self.pullsUrl = pullsUrl
                self.releasesUrl = releasesUrl
                self.sshUrl = sshUrl
                self.stargazersUrl = stargazersUrl
                self.statusesUrl = statusesUrl
                self.subscribersUrl = subscribersUrl
                self.subscriptionUrl = subscriptionUrl
                self.tagsUrl = tagsUrl
                self.teamsUrl = teamsUrl
                self.treesUrl = treesUrl
                self.cloneUrl = cloneUrl
                self.mirrorUrl = mirrorUrl
                self.hooksUrl = hooksUrl
                self.svnUrl = svnUrl
                self.homepage = homepage
                self.language = language
                self.forksCount = forksCount
                self.stargazersCount = stargazersCount
                self.watchersCount = watchersCount
                self.size = size
                self.defaultBranch = defaultBranch
                self.openIssuesCount = openIssuesCount
                self.isTemplate = isTemplate
                self.topics = topics
                self.hasIssues = hasIssues
                self.hasProjects = hasProjects
                self.hasWiki = hasWiki
                self.hasPages = hasPages
                self.hasDownloads = hasDownloads
                self.hasDiscussions = hasDiscussions
                self.archived = archived
                self.disabled = disabled
                self.visibility = visibility
                self.pushedAt = pushedAt
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.permissions = permissions
                self.allowRebaseMerge = allowRebaseMerge
                self.templateRepository = templateRepository
                self.tempCloneToken = tempCloneToken
                self.allowSquashMerge = allowSquashMerge
                self.allowAutoMerge = allowAutoMerge
                self.deleteBranchOnMerge = deleteBranchOnMerge
                self.allowMergeCommit = allowMergeCommit
                self.allowUpdateBranch = allowUpdateBranch
                self.useSquashPrTitleAsDefault = useSquashPrTitleAsDefault
                self.squashMergeCommitTitle = squashMergeCommitTitle
                self.squashMergeCommitMessage = squashMergeCommitMessage
                self.mergeCommitTitle = mergeCommitTitle
                self.mergeCommitMessage = mergeCommitMessage
                self.allowForking = allowForking
                self.webCommitSignoffRequired = webCommitSignoffRequired
                self.subscribersCount = subscribersCount
                self.networkCount = networkCount
                self.license = license
                self.organization = organization
                self.parent = parent
                self.source = source
                self.forks = forks
                self.masterBranch = masterBranch
                self.openIssues = openIssues
                self.watchers = watchers
                self.anonymousAccessEnabled = anonymousAccessEnabled
                self.codeOfConduct = codeOfConduct
                self.securityAndAnalysis = securityAndAnalysis
                self.customProperties = customProperties
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case name
                case fullName = "full_name"
                case owner
                case _private = "private"
                case htmlUrl = "html_url"
                case description
                case fork
                case url
                case archiveUrl = "archive_url"
                case assigneesUrl = "assignees_url"
                case blobsUrl = "blobs_url"
                case branchesUrl = "branches_url"
                case collaboratorsUrl = "collaborators_url"
                case commentsUrl = "comments_url"
                case commitsUrl = "commits_url"
                case compareUrl = "compare_url"
                case contentsUrl = "contents_url"
                case contributorsUrl = "contributors_url"
                case deploymentsUrl = "deployments_url"
                case downloadsUrl = "downloads_url"
                case eventsUrl = "events_url"
                case forksUrl = "forks_url"
                case gitCommitsUrl = "git_commits_url"
                case gitRefsUrl = "git_refs_url"
                case gitTagsUrl = "git_tags_url"
                case gitUrl = "git_url"
                case issueCommentUrl = "issue_comment_url"
                case issueEventsUrl = "issue_events_url"
                case issuesUrl = "issues_url"
                case keysUrl = "keys_url"
                case labelsUrl = "labels_url"
                case languagesUrl = "languages_url"
                case mergesUrl = "merges_url"
                case milestonesUrl = "milestones_url"
                case notificationsUrl = "notifications_url"
                case pullsUrl = "pulls_url"
                case releasesUrl = "releases_url"
                case sshUrl = "ssh_url"
                case stargazersUrl = "stargazers_url"
                case statusesUrl = "statuses_url"
                case subscribersUrl = "subscribers_url"
                case subscriptionUrl = "subscription_url"
                case tagsUrl = "tags_url"
                case teamsUrl = "teams_url"
                case treesUrl = "trees_url"
                case cloneUrl = "clone_url"
                case mirrorUrl = "mirror_url"
                case hooksUrl = "hooks_url"
                case svnUrl = "svn_url"
                case homepage
                case language
                case forksCount = "forks_count"
                case stargazersCount = "stargazers_count"
                case watchersCount = "watchers_count"
                case size
                case defaultBranch = "default_branch"
                case openIssuesCount = "open_issues_count"
                case isTemplate = "is_template"
                case topics
                case hasIssues = "has_issues"
                case hasProjects = "has_projects"
                case hasWiki = "has_wiki"
                case hasPages = "has_pages"
                case hasDownloads = "has_downloads"
                case hasDiscussions = "has_discussions"
                case archived
                case disabled
                case visibility
                case pushedAt = "pushed_at"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case permissions
                case allowRebaseMerge = "allow_rebase_merge"
                case templateRepository = "template_repository"
                case tempCloneToken = "temp_clone_token"
                case allowSquashMerge = "allow_squash_merge"
                case allowAutoMerge = "allow_auto_merge"
                case deleteBranchOnMerge = "delete_branch_on_merge"
                case allowMergeCommit = "allow_merge_commit"
                case allowUpdateBranch = "allow_update_branch"
                case useSquashPrTitleAsDefault = "use_squash_pr_title_as_default"
                case squashMergeCommitTitle = "squash_merge_commit_title"
                case squashMergeCommitMessage = "squash_merge_commit_message"
                case mergeCommitTitle = "merge_commit_title"
                case mergeCommitMessage = "merge_commit_message"
                case allowForking = "allow_forking"
                case webCommitSignoffRequired = "web_commit_signoff_required"
                case subscribersCount = "subscribers_count"
                case networkCount = "network_count"
                case license
                case organization
                case parent
                case source
                case forks
                case masterBranch = "master_branch"
                case openIssues = "open_issues"
                case watchers
                case anonymousAccessEnabled = "anonymous_access_enabled"
                case codeOfConduct = "code_of_conduct"
                case securityAndAnalysis = "security_and_analysis"
                case customProperties = "custom_properties"
            }
        }
        /// The enforcement level of the ruleset. `evaluate` allows admins to test rules before enforcing them. Admins can view insights on the Rule Insights page (`evaluate` is only available with GitHub Enterprise).
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-enforcement`.
        @frozen public enum RepositoryRuleEnforcement: String, Codable, Hashable, Sendable, CaseIterable {
            case disabled = "disabled"
            case active = "active"
            case evaluate = "evaluate"
        }
        /// An actor that can bypass rules in a ruleset
        ///
        /// - Remark: Generated from `#/components/schemas/repository-ruleset-bypass-actor`.
        public struct RepositoryRulesetBypassActor: Codable, Hashable, Sendable {
            /// The ID of the actor that can bypass a ruleset. If `actor_type` is `OrganizationAdmin`, this should be `1`. If `actor_type` is `DeployKey`, this should be null. `OrganizationAdmin` is not applicable for personal repositories.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-bypass-actor/actor_id`.
            public var actorId: Swift.Int?
            /// The type of actor that can bypass a ruleset.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-bypass-actor/actor_type`.
            @frozen public enum ActorTypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case integration = "Integration"
                case organizationAdmin = "OrganizationAdmin"
                case repositoryRole = "RepositoryRole"
                case team = "Team"
                case deployKey = "DeployKey"
            }
            /// The type of actor that can bypass a ruleset.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-bypass-actor/actor_type`.
            public var actorType: Components.Schemas.RepositoryRulesetBypassActor.ActorTypePayload
            /// When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-bypass-actor/bypass_mode`.
            @frozen public enum BypassModePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case always = "always"
                case pullRequest = "pull_request"
            }
            /// When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-bypass-actor/bypass_mode`.
            public var bypassMode: Components.Schemas.RepositoryRulesetBypassActor.BypassModePayload?
            /// Creates a new `RepositoryRulesetBypassActor`.
            ///
            /// - Parameters:
            ///   - actorId: The ID of the actor that can bypass a ruleset. If `actor_type` is `OrganizationAdmin`, this should be `1`. If `actor_type` is `DeployKey`, this should be null. `OrganizationAdmin` is not applicable for personal repositories.
            ///   - actorType: The type of actor that can bypass a ruleset.
            ///   - bypassMode: When the specified actor can bypass the ruleset. `pull_request` means that an actor can only bypass rules on pull requests. `pull_request` is not applicable for the `DeployKey` actor type. Also, `pull_request` is only applicable to branch rulesets.
            public init(
                actorId: Swift.Int? = nil,
                actorType: Components.Schemas.RepositoryRulesetBypassActor.ActorTypePayload,
                bypassMode: Components.Schemas.RepositoryRulesetBypassActor.BypassModePayload? = nil
            ) {
                self.actorId = actorId
                self.actorType = actorType
                self.bypassMode = bypassMode
            }
            public enum CodingKeys: String, CodingKey {
                case actorId = "actor_id"
                case actorType = "actor_type"
                case bypassMode = "bypass_mode"
            }
        }
        /// Parameters for a repository ruleset ref name condition
        ///
        /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions`.
        public struct RepositoryRulesetConditions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions/ref_name`.
            public struct RefNamePayload: Codable, Hashable, Sendable {
                /// Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions/ref_name/include`.
                public var include: [Swift.String]?
                /// Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions/ref_name/exclude`.
                public var exclude: [Swift.String]?
                /// Creates a new `RefNamePayload`.
                ///
                /// - Parameters:
                ///   - include: Array of ref names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the default branch or `~ALL` to include all branches.
                ///   - exclude: Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match.
                public init(
                    include: [Swift.String]? = nil,
                    exclude: [Swift.String]? = nil
                ) {
                    self.include = include
                    self.exclude = exclude
                }
                public enum CodingKeys: String, CodingKey {
                    case include
                    case exclude
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions/ref_name`.
            public var refName: Components.Schemas.RepositoryRulesetConditions.RefNamePayload?
            /// Creates a new `RepositoryRulesetConditions`.
            ///
            /// - Parameters:
            ///   - refName:
            public init(refName: Components.Schemas.RepositoryRulesetConditions.RefNamePayload? = nil) {
                self.refName = refName
            }
            public enum CodingKeys: String, CodingKey {
                case refName = "ref_name"
            }
        }
        /// Parameters for a repository name condition
        ///
        /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-name-target`.
        public struct RepositoryRulesetConditionsRepositoryNameTarget: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-name-target/repository_name`.
            public struct RepositoryNamePayload: Codable, Hashable, Sendable {
                /// Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-name-target/repository_name/include`.
                public var include: [Swift.String]?
                /// Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-name-target/repository_name/exclude`.
                public var exclude: [Swift.String]?
                /// Whether renaming of target repositories is prevented.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-name-target/repository_name/protected`.
                public var protected: Swift.Bool?
                /// Creates a new `RepositoryNamePayload`.
                ///
                /// - Parameters:
                ///   - include: Array of repository names or patterns to include. One of these patterns must match for the condition to pass. Also accepts `~ALL` to include all repositories.
                ///   - exclude: Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match.
                ///   - protected: Whether renaming of target repositories is prevented.
                public init(
                    include: [Swift.String]? = nil,
                    exclude: [Swift.String]? = nil,
                    protected: Swift.Bool? = nil
                ) {
                    self.include = include
                    self.exclude = exclude
                    self.protected = protected
                }
                public enum CodingKeys: String, CodingKey {
                    case include
                    case exclude
                    case protected
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-name-target/repository_name`.
            public var repositoryName: Components.Schemas.RepositoryRulesetConditionsRepositoryNameTarget.RepositoryNamePayload
            /// Creates a new `RepositoryRulesetConditionsRepositoryNameTarget`.
            ///
            /// - Parameters:
            ///   - repositoryName:
            public init(repositoryName: Components.Schemas.RepositoryRulesetConditionsRepositoryNameTarget.RepositoryNamePayload) {
                self.repositoryName = repositoryName
            }
            public enum CodingKeys: String, CodingKey {
                case repositoryName = "repository_name"
            }
        }
        /// Parameters for a repository ID condition
        ///
        /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-id-target`.
        public struct RepositoryRulesetConditionsRepositoryIdTarget: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-id-target/repository_id`.
            public struct RepositoryIdPayload: Codable, Hashable, Sendable {
                /// The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-id-target/repository_id/repository_ids`.
                public var repositoryIds: [Swift.Int]?
                /// Creates a new `RepositoryIdPayload`.
                ///
                /// - Parameters:
                ///   - repositoryIds: The repository IDs that the ruleset applies to. One of these IDs must match for the condition to pass.
                public init(repositoryIds: [Swift.Int]? = nil) {
                    self.repositoryIds = repositoryIds
                }
                public enum CodingKeys: String, CodingKey {
                    case repositoryIds = "repository_ids"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-id-target/repository_id`.
            public var repositoryId: Components.Schemas.RepositoryRulesetConditionsRepositoryIdTarget.RepositoryIdPayload
            /// Creates a new `RepositoryRulesetConditionsRepositoryIdTarget`.
            ///
            /// - Parameters:
            ///   - repositoryId:
            public init(repositoryId: Components.Schemas.RepositoryRulesetConditionsRepositoryIdTarget.RepositoryIdPayload) {
                self.repositoryId = repositoryId
            }
            public enum CodingKeys: String, CodingKey {
                case repositoryId = "repository_id"
            }
        }
        /// Parameters for a targeting a repository property
        ///
        /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-spec`.
        public struct RepositoryRulesetConditionsRepositoryPropertySpec: Codable, Hashable, Sendable {
            /// The name of the repository property to target
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-spec/name`.
            public var name: Swift.String
            /// The values to match for the repository property
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-spec/property_values`.
            public var propertyValues: [Swift.String]
            /// The source of the repository property. Defaults to 'custom' if not specified.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-spec/source`.
            @frozen public enum SourcePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case custom = "custom"
                case system = "system"
            }
            /// The source of the repository property. Defaults to 'custom' if not specified.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-spec/source`.
            public var source: Components.Schemas.RepositoryRulesetConditionsRepositoryPropertySpec.SourcePayload?
            /// Creates a new `RepositoryRulesetConditionsRepositoryPropertySpec`.
            ///
            /// - Parameters:
            ///   - name: The name of the repository property to target
            ///   - propertyValues: The values to match for the repository property
            ///   - source: The source of the repository property. Defaults to 'custom' if not specified.
            public init(
                name: Swift.String,
                propertyValues: [Swift.String],
                source: Components.Schemas.RepositoryRulesetConditionsRepositoryPropertySpec.SourcePayload? = nil
            ) {
                self.name = name
                self.propertyValues = propertyValues
                self.source = source
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case propertyValues = "property_values"
                case source
            }
        }
        /// Parameters for a repository property condition
        ///
        /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-target`.
        public struct RepositoryRulesetConditionsRepositoryPropertyTarget: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-target/repository_property`.
            public struct RepositoryPropertyPayload: Codable, Hashable, Sendable {
                /// The repository properties and values to include. All of these properties must match for the condition to pass.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-target/repository_property/include`.
                public var include: [Components.Schemas.RepositoryRulesetConditionsRepositoryPropertySpec]?
                /// The repository properties and values to exclude. The condition will not pass if any of these properties match.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-target/repository_property/exclude`.
                public var exclude: [Components.Schemas.RepositoryRulesetConditionsRepositoryPropertySpec]?
                /// Creates a new `RepositoryPropertyPayload`.
                ///
                /// - Parameters:
                ///   - include: The repository properties and values to include. All of these properties must match for the condition to pass.
                ///   - exclude: The repository properties and values to exclude. The condition will not pass if any of these properties match.
                public init(
                    include: [Components.Schemas.RepositoryRulesetConditionsRepositoryPropertySpec]? = nil,
                    exclude: [Components.Schemas.RepositoryRulesetConditionsRepositoryPropertySpec]? = nil
                ) {
                    self.include = include
                    self.exclude = exclude
                }
                public enum CodingKeys: String, CodingKey {
                    case include
                    case exclude
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-ruleset-conditions-repository-property-target/repository_property`.
            public var repositoryProperty: Components.Schemas.RepositoryRulesetConditionsRepositoryPropertyTarget.RepositoryPropertyPayload
            /// Creates a new `RepositoryRulesetConditionsRepositoryPropertyTarget`.
            ///
            /// - Parameters:
            ///   - repositoryProperty:
            public init(repositoryProperty: Components.Schemas.RepositoryRulesetConditionsRepositoryPropertyTarget.RepositoryPropertyPayload) {
                self.repositoryProperty = repositoryProperty
            }
            public enum CodingKeys: String, CodingKey {
                case repositoryProperty = "repository_property"
            }
        }
        /// Conditions for an organization ruleset.
        /// The branch and tag rulesets conditions object should contain both `repository_name` and `ref_name` properties, or both `repository_id` and `ref_name` properties, or both `repository_property` and `ref_name` properties.
        /// The push rulesets conditions object does not require the `ref_name` property.
        /// For repository policy rulesets, the conditions object should only contain the `repository_name`, the `repository_id`, or the `repository_property`.
        ///
        /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions`.
        @frozen public enum OrgRulesetConditions: Codable, Hashable, Sendable {
            /// Conditions to target repositories by name and refs by name
            ///
            /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case1`.
            public struct Case1Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case1/value1`.
                public var value1: Components.Schemas.RepositoryRulesetConditions
                /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case1/value2`.
                public var value2: Components.Schemas.RepositoryRulesetConditionsRepositoryNameTarget
                /// Creates a new `Case1Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRulesetConditions,
                    value2: Components.Schemas.RepositoryRulesetConditionsRepositoryNameTarget
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// Conditions to target repositories by name and refs by name
            ///
            /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case1`.
            case case1(Components.Schemas.OrgRulesetConditions.Case1Payload)
            /// Conditions to target repositories by id and refs by name
            ///
            /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case2`.
            public struct Case2Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case2/value1`.
                public var value1: Components.Schemas.RepositoryRulesetConditions
                /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case2/value2`.
                public var value2: Components.Schemas.RepositoryRulesetConditionsRepositoryIdTarget
                /// Creates a new `Case2Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRulesetConditions,
                    value2: Components.Schemas.RepositoryRulesetConditionsRepositoryIdTarget
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// Conditions to target repositories by id and refs by name
            ///
            /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case2`.
            case case2(Components.Schemas.OrgRulesetConditions.Case2Payload)
            /// Conditions to target repositories by property and refs by name
            ///
            /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case3`.
            public struct Case3Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case3/value1`.
                public var value1: Components.Schemas.RepositoryRulesetConditions
                /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case3/value2`.
                public var value2: Components.Schemas.RepositoryRulesetConditionsRepositoryPropertyTarget
                /// Creates a new `Case3Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRulesetConditions,
                    value2: Components.Schemas.RepositoryRulesetConditionsRepositoryPropertyTarget
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// Conditions to target repositories by property and refs by name
            ///
            /// - Remark: Generated from `#/components/schemas/org-ruleset-conditions/case3`.
            case case3(Components.Schemas.OrgRulesetConditions.Case3Payload)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .case1(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case2(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case3(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .case1(value):
                    try value.encode(to: encoder)
                case let .case2(value):
                    try value.encode(to: encoder)
                case let .case3(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// Only allow users with bypass permission to create matching refs.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-creation`.
        public struct RepositoryRuleCreation: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-creation/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case creation = "creation"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-creation/type`.
            public var _type: Components.Schemas.RepositoryRuleCreation._TypePayload
            /// Creates a new `RepositoryRuleCreation`.
            ///
            /// - Parameters:
            ///   - _type:
            public init(_type: Components.Schemas.RepositoryRuleCreation._TypePayload) {
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
            }
        }
        /// Only allow users with bypass permission to update matching refs.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-update`.
        public struct RepositoryRuleUpdate: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-update/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case update = "update"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-update/type`.
            public var _type: Components.Schemas.RepositoryRuleUpdate._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-update/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// Branch can pull changes from its upstream repository
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-update/parameters/update_allows_fetch_and_merge`.
                public var updateAllowsFetchAndMerge: Swift.Bool
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - updateAllowsFetchAndMerge: Branch can pull changes from its upstream repository
                public init(updateAllowsFetchAndMerge: Swift.Bool) {
                    self.updateAllowsFetchAndMerge = updateAllowsFetchAndMerge
                }
                public enum CodingKeys: String, CodingKey {
                    case updateAllowsFetchAndMerge = "update_allows_fetch_and_merge"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-update/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleUpdate.ParametersPayload?
            /// Creates a new `RepositoryRuleUpdate`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleUpdate._TypePayload,
                parameters: Components.Schemas.RepositoryRuleUpdate.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Only allow users with bypass permissions to delete matching refs.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-deletion`.
        public struct RepositoryRuleDeletion: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-deletion/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case deletion = "deletion"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-deletion/type`.
            public var _type: Components.Schemas.RepositoryRuleDeletion._TypePayload
            /// Creates a new `RepositoryRuleDeletion`.
            ///
            /// - Parameters:
            ///   - _type:
            public init(_type: Components.Schemas.RepositoryRuleDeletion._TypePayload) {
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
            }
        }
        /// Prevent merge commits from being pushed to matching refs.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-required-linear-history`.
        public struct RepositoryRuleRequiredLinearHistory: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-linear-history/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case requiredLinearHistory = "required_linear_history"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-linear-history/type`.
            public var _type: Components.Schemas.RepositoryRuleRequiredLinearHistory._TypePayload
            /// Creates a new `RepositoryRuleRequiredLinearHistory`.
            ///
            /// - Parameters:
            ///   - _type:
            public init(_type: Components.Schemas.RepositoryRuleRequiredLinearHistory._TypePayload) {
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
            }
        }
        /// Merges must be performed via a merge queue.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue`.
        public struct RepositoryRuleMergeQueue: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case mergeQueue = "merge_queue"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/type`.
            public var _type: Components.Schemas.RepositoryRuleMergeQueue._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/check_response_timeout_minutes`.
                public var checkResponseTimeoutMinutes: Swift.Int
                /// When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/grouping_strategy`.
                @frozen public enum GroupingStrategyPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case allgreen = "ALLGREEN"
                    case headgreen = "HEADGREEN"
                }
                /// When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/grouping_strategy`.
                public var groupingStrategy: Components.Schemas.RepositoryRuleMergeQueue.ParametersPayload.GroupingStrategyPayload
                /// Limit the number of queued pull requests requesting checks and workflow runs at the same time.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/max_entries_to_build`.
                public var maxEntriesToBuild: Swift.Int
                /// The maximum number of PRs that will be merged together in a group.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/max_entries_to_merge`.
                public var maxEntriesToMerge: Swift.Int
                /// Method to use when merging changes from queued pull requests.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/merge_method`.
                @frozen public enum MergeMethodPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case merge = "MERGE"
                    case squash = "SQUASH"
                    case rebase = "REBASE"
                }
                /// Method to use when merging changes from queued pull requests.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/merge_method`.
                public var mergeMethod: Components.Schemas.RepositoryRuleMergeQueue.ParametersPayload.MergeMethodPayload
                /// The minimum number of PRs that will be merged together in a group.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/min_entries_to_merge`.
                public var minEntriesToMerge: Swift.Int
                /// The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters/min_entries_to_merge_wait_minutes`.
                public var minEntriesToMergeWaitMinutes: Swift.Int
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - checkResponseTimeoutMinutes: Maximum time for a required status check to report a conclusion. After this much time has elapsed, checks that have not reported a conclusion will be assumed to have failed
                ///   - groupingStrategy: When set to ALLGREEN, the merge commit created by merge queue for each PR in the group must pass all required checks to merge. When set to HEADGREEN, only the commit at the head of the merge group, i.e. the commit containing changes from all of the PRs in the group, must pass its required checks to merge.
                ///   - maxEntriesToBuild: Limit the number of queued pull requests requesting checks and workflow runs at the same time.
                ///   - maxEntriesToMerge: The maximum number of PRs that will be merged together in a group.
                ///   - mergeMethod: Method to use when merging changes from queued pull requests.
                ///   - minEntriesToMerge: The minimum number of PRs that will be merged together in a group.
                ///   - minEntriesToMergeWaitMinutes: The time merge queue should wait after the first PR is added to the queue for the minimum group size to be met. After this time has elapsed, the minimum group size will be ignored and a smaller group will be merged.
                public init(
                    checkResponseTimeoutMinutes: Swift.Int,
                    groupingStrategy: Components.Schemas.RepositoryRuleMergeQueue.ParametersPayload.GroupingStrategyPayload,
                    maxEntriesToBuild: Swift.Int,
                    maxEntriesToMerge: Swift.Int,
                    mergeMethod: Components.Schemas.RepositoryRuleMergeQueue.ParametersPayload.MergeMethodPayload,
                    minEntriesToMerge: Swift.Int,
                    minEntriesToMergeWaitMinutes: Swift.Int
                ) {
                    self.checkResponseTimeoutMinutes = checkResponseTimeoutMinutes
                    self.groupingStrategy = groupingStrategy
                    self.maxEntriesToBuild = maxEntriesToBuild
                    self.maxEntriesToMerge = maxEntriesToMerge
                    self.mergeMethod = mergeMethod
                    self.minEntriesToMerge = minEntriesToMerge
                    self.minEntriesToMergeWaitMinutes = minEntriesToMergeWaitMinutes
                }
                public enum CodingKeys: String, CodingKey {
                    case checkResponseTimeoutMinutes = "check_response_timeout_minutes"
                    case groupingStrategy = "grouping_strategy"
                    case maxEntriesToBuild = "max_entries_to_build"
                    case maxEntriesToMerge = "max_entries_to_merge"
                    case mergeMethod = "merge_method"
                    case minEntriesToMerge = "min_entries_to_merge"
                    case minEntriesToMergeWaitMinutes = "min_entries_to_merge_wait_minutes"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-merge-queue/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleMergeQueue.ParametersPayload?
            /// Creates a new `RepositoryRuleMergeQueue`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleMergeQueue._TypePayload,
                parameters: Components.Schemas.RepositoryRuleMergeQueue.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Choose which environments must be successfully deployed to before refs can be pushed into a ref that matches this rule.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-required-deployments`.
        public struct RepositoryRuleRequiredDeployments: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-deployments/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case requiredDeployments = "required_deployments"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-deployments/type`.
            public var _type: Components.Schemas.RepositoryRuleRequiredDeployments._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-deployments/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// The environments that must be successfully deployed to before branches can be merged.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-required-deployments/parameters/required_deployment_environments`.
                public var requiredDeploymentEnvironments: [Swift.String]
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - requiredDeploymentEnvironments: The environments that must be successfully deployed to before branches can be merged.
                public init(requiredDeploymentEnvironments: [Swift.String]) {
                    self.requiredDeploymentEnvironments = requiredDeploymentEnvironments
                }
                public enum CodingKeys: String, CodingKey {
                    case requiredDeploymentEnvironments = "required_deployment_environments"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-deployments/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleRequiredDeployments.ParametersPayload?
            /// Creates a new `RepositoryRuleRequiredDeployments`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleRequiredDeployments._TypePayload,
                parameters: Components.Schemas.RepositoryRuleRequiredDeployments.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Commits pushed to matching refs must have verified signatures.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-required-signatures`.
        public struct RepositoryRuleRequiredSignatures: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-signatures/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case requiredSignatures = "required_signatures"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-signatures/type`.
            public var _type: Components.Schemas.RepositoryRuleRequiredSignatures._TypePayload
            /// Creates a new `RepositoryRuleRequiredSignatures`.
            ///
            /// - Parameters:
            ///   - _type:
            public init(_type: Components.Schemas.RepositoryRuleRequiredSignatures._TypePayload) {
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
            }
        }
        /// Require all commits be made to a non-target branch and submitted via a pull request before they can be merged.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request`.
        public struct RepositoryRulePullRequest: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case pullRequest = "pull_request"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/type`.
            public var _type: Components.Schemas.RepositoryRulePullRequest._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/AllowedMergeMethodsPayload`.
                @frozen public enum AllowedMergeMethodsPayloadPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case merge = "merge"
                    case squash = "squash"
                    case rebase = "rebase"
                }
                /// Array of allowed merge methods. Allowed values include `merge`, `squash`, and `rebase`. At least one option must be enabled.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/allowed_merge_methods`.
                public typealias AllowedMergeMethodsPayload = [Components.Schemas.RepositoryRulePullRequest.ParametersPayload.AllowedMergeMethodsPayloadPayload]
                /// Array of allowed merge methods. Allowed values include `merge`, `squash`, and `rebase`. At least one option must be enabled.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/allowed_merge_methods`.
                public var allowedMergeMethods: Components.Schemas.RepositoryRulePullRequest.ParametersPayload.AllowedMergeMethodsPayload?
                /// Automatically request review from Copilot for new pull requests, if the author has access to Copilot code review.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/automatic_copilot_code_review_enabled`.
                public var automaticCopilotCodeReviewEnabled: Swift.Bool?
                /// New, reviewable commits pushed will dismiss previous pull request review approvals.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/dismiss_stale_reviews_on_push`.
                public var dismissStaleReviewsOnPush: Swift.Bool
                /// Require an approving review in pull requests that modify files that have a designated code owner.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/require_code_owner_review`.
                public var requireCodeOwnerReview: Swift.Bool
                /// Whether the most recent reviewable push must be approved by someone other than the person who pushed it.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/require_last_push_approval`.
                public var requireLastPushApproval: Swift.Bool
                /// The number of approving reviews that are required before a pull request can be merged.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/required_approving_review_count`.
                public var requiredApprovingReviewCount: Swift.Int
                /// All conversations on code must be resolved before a pull request can be merged.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters/required_review_thread_resolution`.
                public var requiredReviewThreadResolution: Swift.Bool
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - allowedMergeMethods: Array of allowed merge methods. Allowed values include `merge`, `squash`, and `rebase`. At least one option must be enabled.
                ///   - automaticCopilotCodeReviewEnabled: Automatically request review from Copilot for new pull requests, if the author has access to Copilot code review.
                ///   - dismissStaleReviewsOnPush: New, reviewable commits pushed will dismiss previous pull request review approvals.
                ///   - requireCodeOwnerReview: Require an approving review in pull requests that modify files that have a designated code owner.
                ///   - requireLastPushApproval: Whether the most recent reviewable push must be approved by someone other than the person who pushed it.
                ///   - requiredApprovingReviewCount: The number of approving reviews that are required before a pull request can be merged.
                ///   - requiredReviewThreadResolution: All conversations on code must be resolved before a pull request can be merged.
                public init(
                    allowedMergeMethods: Components.Schemas.RepositoryRulePullRequest.ParametersPayload.AllowedMergeMethodsPayload? = nil,
                    automaticCopilotCodeReviewEnabled: Swift.Bool? = nil,
                    dismissStaleReviewsOnPush: Swift.Bool,
                    requireCodeOwnerReview: Swift.Bool,
                    requireLastPushApproval: Swift.Bool,
                    requiredApprovingReviewCount: Swift.Int,
                    requiredReviewThreadResolution: Swift.Bool
                ) {
                    self.allowedMergeMethods = allowedMergeMethods
                    self.automaticCopilotCodeReviewEnabled = automaticCopilotCodeReviewEnabled
                    self.dismissStaleReviewsOnPush = dismissStaleReviewsOnPush
                    self.requireCodeOwnerReview = requireCodeOwnerReview
                    self.requireLastPushApproval = requireLastPushApproval
                    self.requiredApprovingReviewCount = requiredApprovingReviewCount
                    self.requiredReviewThreadResolution = requiredReviewThreadResolution
                }
                public enum CodingKeys: String, CodingKey {
                    case allowedMergeMethods = "allowed_merge_methods"
                    case automaticCopilotCodeReviewEnabled = "automatic_copilot_code_review_enabled"
                    case dismissStaleReviewsOnPush = "dismiss_stale_reviews_on_push"
                    case requireCodeOwnerReview = "require_code_owner_review"
                    case requireLastPushApproval = "require_last_push_approval"
                    case requiredApprovingReviewCount = "required_approving_review_count"
                    case requiredReviewThreadResolution = "required_review_thread_resolution"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-pull-request/parameters`.
            public var parameters: Components.Schemas.RepositoryRulePullRequest.ParametersPayload?
            /// Creates a new `RepositoryRulePullRequest`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRulePullRequest._TypePayload,
                parameters: Components.Schemas.RepositoryRulePullRequest.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Required status check
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-params-status-check-configuration`.
        public struct RepositoryRuleParamsStatusCheckConfiguration: Codable, Hashable, Sendable {
            /// The status check context name that must be present on the commit.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-status-check-configuration/context`.
            public var context: Swift.String
            /// The optional integration ID that this status check must originate from.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-status-check-configuration/integration_id`.
            public var integrationId: Swift.Int?
            /// Creates a new `RepositoryRuleParamsStatusCheckConfiguration`.
            ///
            /// - Parameters:
            ///   - context: The status check context name that must be present on the commit.
            ///   - integrationId: The optional integration ID that this status check must originate from.
            public init(
                context: Swift.String,
                integrationId: Swift.Int? = nil
            ) {
                self.context = context
                self.integrationId = integrationId
            }
            public enum CodingKeys: String, CodingKey {
                case context
                case integrationId = "integration_id"
            }
        }
        /// Choose which status checks must pass before the ref is updated. When enabled, commits must first be pushed to another ref where the checks pass.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks`.
        public struct RepositoryRuleRequiredStatusChecks: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case requiredStatusChecks = "required_status_checks"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks/type`.
            public var _type: Components.Schemas.RepositoryRuleRequiredStatusChecks._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// Allow repositories and branches to be created if a check would otherwise prohibit it.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks/parameters/do_not_enforce_on_create`.
                public var doNotEnforceOnCreate: Swift.Bool?
                /// Status checks that are required.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks/parameters/required_status_checks`.
                public var requiredStatusChecks: [Components.Schemas.RepositoryRuleParamsStatusCheckConfiguration]
                /// Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks/parameters/strict_required_status_checks_policy`.
                public var strictRequiredStatusChecksPolicy: Swift.Bool
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - doNotEnforceOnCreate: Allow repositories and branches to be created if a check would otherwise prohibit it.
                ///   - requiredStatusChecks: Status checks that are required.
                ///   - strictRequiredStatusChecksPolicy: Whether pull requests targeting a matching branch must be tested with the latest code. This setting will not take effect unless at least one status check is enabled.
                public init(
                    doNotEnforceOnCreate: Swift.Bool? = nil,
                    requiredStatusChecks: [Components.Schemas.RepositoryRuleParamsStatusCheckConfiguration],
                    strictRequiredStatusChecksPolicy: Swift.Bool
                ) {
                    self.doNotEnforceOnCreate = doNotEnforceOnCreate
                    self.requiredStatusChecks = requiredStatusChecks
                    self.strictRequiredStatusChecksPolicy = strictRequiredStatusChecksPolicy
                }
                public enum CodingKeys: String, CodingKey {
                    case doNotEnforceOnCreate = "do_not_enforce_on_create"
                    case requiredStatusChecks = "required_status_checks"
                    case strictRequiredStatusChecksPolicy = "strict_required_status_checks_policy"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-required-status-checks/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleRequiredStatusChecks.ParametersPayload?
            /// Creates a new `RepositoryRuleRequiredStatusChecks`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleRequiredStatusChecks._TypePayload,
                parameters: Components.Schemas.RepositoryRuleRequiredStatusChecks.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Prevent users with push access from force pushing to refs.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-non-fast-forward`.
        public struct RepositoryRuleNonFastForward: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-non-fast-forward/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case nonFastForward = "non_fast_forward"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-non-fast-forward/type`.
            public var _type: Components.Schemas.RepositoryRuleNonFastForward._TypePayload
            /// Creates a new `RepositoryRuleNonFastForward`.
            ///
            /// - Parameters:
            ///   - _type:
            public init(_type: Components.Schemas.RepositoryRuleNonFastForward._TypePayload) {
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
            }
        }
        /// Parameters to be used for the commit_message_pattern rule
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern`.
        public struct RepositoryRuleCommitMessagePattern: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case commitMessagePattern = "commit_message_pattern"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/type`.
            public var _type: Components.Schemas.RepositoryRuleCommitMessagePattern._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// How this rule will appear to users.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/parameters/name`.
                public var name: Swift.String?
                /// If true, the rule will fail if the pattern matches.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/parameters/negate`.
                public var negate: Swift.Bool?
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/parameters/operator`.
                @frozen public enum OperatorPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case startsWith = "starts_with"
                    case endsWith = "ends_with"
                    case contains = "contains"
                    case regex = "regex"
                }
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/parameters/operator`.
                public var _operator: Components.Schemas.RepositoryRuleCommitMessagePattern.ParametersPayload.OperatorPayload
                /// The pattern to match with.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/parameters/pattern`.
                public var pattern: Swift.String
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - name: How this rule will appear to users.
                ///   - negate: If true, the rule will fail if the pattern matches.
                ///   - _operator: The operator to use for matching.
                ///   - pattern: The pattern to match with.
                public init(
                    name: Swift.String? = nil,
                    negate: Swift.Bool? = nil,
                    _operator: Components.Schemas.RepositoryRuleCommitMessagePattern.ParametersPayload.OperatorPayload,
                    pattern: Swift.String
                ) {
                    self.name = name
                    self.negate = negate
                    self._operator = _operator
                    self.pattern = pattern
                }
                public enum CodingKeys: String, CodingKey {
                    case name
                    case negate
                    case _operator = "operator"
                    case pattern
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-message-pattern/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleCommitMessagePattern.ParametersPayload?
            /// Creates a new `RepositoryRuleCommitMessagePattern`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleCommitMessagePattern._TypePayload,
                parameters: Components.Schemas.RepositoryRuleCommitMessagePattern.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Parameters to be used for the commit_author_email_pattern rule
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern`.
        public struct RepositoryRuleCommitAuthorEmailPattern: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case commitAuthorEmailPattern = "commit_author_email_pattern"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/type`.
            public var _type: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// How this rule will appear to users.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/parameters/name`.
                public var name: Swift.String?
                /// If true, the rule will fail if the pattern matches.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/parameters/negate`.
                public var negate: Swift.Bool?
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/parameters/operator`.
                @frozen public enum OperatorPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case startsWith = "starts_with"
                    case endsWith = "ends_with"
                    case contains = "contains"
                    case regex = "regex"
                }
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/parameters/operator`.
                public var _operator: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern.ParametersPayload.OperatorPayload
                /// The pattern to match with.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/parameters/pattern`.
                public var pattern: Swift.String
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - name: How this rule will appear to users.
                ///   - negate: If true, the rule will fail if the pattern matches.
                ///   - _operator: The operator to use for matching.
                ///   - pattern: The pattern to match with.
                public init(
                    name: Swift.String? = nil,
                    negate: Swift.Bool? = nil,
                    _operator: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern.ParametersPayload.OperatorPayload,
                    pattern: Swift.String
                ) {
                    self.name = name
                    self.negate = negate
                    self._operator = _operator
                    self.pattern = pattern
                }
                public enum CodingKeys: String, CodingKey {
                    case name
                    case negate
                    case _operator = "operator"
                    case pattern
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-commit-author-email-pattern/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern.ParametersPayload?
            /// Creates a new `RepositoryRuleCommitAuthorEmailPattern`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern._TypePayload,
                parameters: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Parameters to be used for the committer_email_pattern rule
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern`.
        public struct RepositoryRuleCommitterEmailPattern: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case committerEmailPattern = "committer_email_pattern"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/type`.
            public var _type: Components.Schemas.RepositoryRuleCommitterEmailPattern._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// How this rule will appear to users.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/parameters/name`.
                public var name: Swift.String?
                /// If true, the rule will fail if the pattern matches.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/parameters/negate`.
                public var negate: Swift.Bool?
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/parameters/operator`.
                @frozen public enum OperatorPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case startsWith = "starts_with"
                    case endsWith = "ends_with"
                    case contains = "contains"
                    case regex = "regex"
                }
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/parameters/operator`.
                public var _operator: Components.Schemas.RepositoryRuleCommitterEmailPattern.ParametersPayload.OperatorPayload
                /// The pattern to match with.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/parameters/pattern`.
                public var pattern: Swift.String
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - name: How this rule will appear to users.
                ///   - negate: If true, the rule will fail if the pattern matches.
                ///   - _operator: The operator to use for matching.
                ///   - pattern: The pattern to match with.
                public init(
                    name: Swift.String? = nil,
                    negate: Swift.Bool? = nil,
                    _operator: Components.Schemas.RepositoryRuleCommitterEmailPattern.ParametersPayload.OperatorPayload,
                    pattern: Swift.String
                ) {
                    self.name = name
                    self.negate = negate
                    self._operator = _operator
                    self.pattern = pattern
                }
                public enum CodingKeys: String, CodingKey {
                    case name
                    case negate
                    case _operator = "operator"
                    case pattern
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-committer-email-pattern/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleCommitterEmailPattern.ParametersPayload?
            /// Creates a new `RepositoryRuleCommitterEmailPattern`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleCommitterEmailPattern._TypePayload,
                parameters: Components.Schemas.RepositoryRuleCommitterEmailPattern.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Parameters to be used for the branch_name_pattern rule
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern`.
        public struct RepositoryRuleBranchNamePattern: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case branchNamePattern = "branch_name_pattern"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/type`.
            public var _type: Components.Schemas.RepositoryRuleBranchNamePattern._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// How this rule will appear to users.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/parameters/name`.
                public var name: Swift.String?
                /// If true, the rule will fail if the pattern matches.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/parameters/negate`.
                public var negate: Swift.Bool?
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/parameters/operator`.
                @frozen public enum OperatorPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case startsWith = "starts_with"
                    case endsWith = "ends_with"
                    case contains = "contains"
                    case regex = "regex"
                }
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/parameters/operator`.
                public var _operator: Components.Schemas.RepositoryRuleBranchNamePattern.ParametersPayload.OperatorPayload
                /// The pattern to match with.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/parameters/pattern`.
                public var pattern: Swift.String
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - name: How this rule will appear to users.
                ///   - negate: If true, the rule will fail if the pattern matches.
                ///   - _operator: The operator to use for matching.
                ///   - pattern: The pattern to match with.
                public init(
                    name: Swift.String? = nil,
                    negate: Swift.Bool? = nil,
                    _operator: Components.Schemas.RepositoryRuleBranchNamePattern.ParametersPayload.OperatorPayload,
                    pattern: Swift.String
                ) {
                    self.name = name
                    self.negate = negate
                    self._operator = _operator
                    self.pattern = pattern
                }
                public enum CodingKeys: String, CodingKey {
                    case name
                    case negate
                    case _operator = "operator"
                    case pattern
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-branch-name-pattern/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleBranchNamePattern.ParametersPayload?
            /// Creates a new `RepositoryRuleBranchNamePattern`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleBranchNamePattern._TypePayload,
                parameters: Components.Schemas.RepositoryRuleBranchNamePattern.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Parameters to be used for the tag_name_pattern rule
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern`.
        public struct RepositoryRuleTagNamePattern: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case tagNamePattern = "tag_name_pattern"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/type`.
            public var _type: Components.Schemas.RepositoryRuleTagNamePattern._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// How this rule will appear to users.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/parameters/name`.
                public var name: Swift.String?
                /// If true, the rule will fail if the pattern matches.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/parameters/negate`.
                public var negate: Swift.Bool?
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/parameters/operator`.
                @frozen public enum OperatorPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case startsWith = "starts_with"
                    case endsWith = "ends_with"
                    case contains = "contains"
                    case regex = "regex"
                }
                /// The operator to use for matching.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/parameters/operator`.
                public var _operator: Components.Schemas.RepositoryRuleTagNamePattern.ParametersPayload.OperatorPayload
                /// The pattern to match with.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/parameters/pattern`.
                public var pattern: Swift.String
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - name: How this rule will appear to users.
                ///   - negate: If true, the rule will fail if the pattern matches.
                ///   - _operator: The operator to use for matching.
                ///   - pattern: The pattern to match with.
                public init(
                    name: Swift.String? = nil,
                    negate: Swift.Bool? = nil,
                    _operator: Components.Schemas.RepositoryRuleTagNamePattern.ParametersPayload.OperatorPayload,
                    pattern: Swift.String
                ) {
                    self.name = name
                    self.negate = negate
                    self._operator = _operator
                    self.pattern = pattern
                }
                public enum CodingKeys: String, CodingKey {
                    case name
                    case negate
                    case _operator = "operator"
                    case pattern
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-tag-name-pattern/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleTagNamePattern.ParametersPayload?
            /// Creates a new `RepositoryRuleTagNamePattern`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleTagNamePattern._TypePayload,
                parameters: Components.Schemas.RepositoryRuleTagNamePattern.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Prevent commits that include changes in specified file and folder paths from being pushed to the commit graph. This includes absolute paths that contain file names.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-file-path-restriction`.
        public struct RepositoryRuleFilePathRestriction: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-path-restriction/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case filePathRestriction = "file_path_restriction"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-path-restriction/type`.
            public var _type: Components.Schemas.RepositoryRuleFilePathRestriction._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-path-restriction/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// The file paths that are restricted from being pushed to the commit graph.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-file-path-restriction/parameters/restricted_file_paths`.
                public var restrictedFilePaths: [Swift.String]
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - restrictedFilePaths: The file paths that are restricted from being pushed to the commit graph.
                public init(restrictedFilePaths: [Swift.String]) {
                    self.restrictedFilePaths = restrictedFilePaths
                }
                public enum CodingKeys: String, CodingKey {
                    case restrictedFilePaths = "restricted_file_paths"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-path-restriction/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleFilePathRestriction.ParametersPayload?
            /// Creates a new `RepositoryRuleFilePathRestriction`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleFilePathRestriction._TypePayload,
                parameters: Components.Schemas.RepositoryRuleFilePathRestriction.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Prevent commits that include file paths that exceed the specified character limit from being pushed to the commit graph.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-path-length`.
        public struct RepositoryRuleMaxFilePathLength: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-path-length/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case maxFilePathLength = "max_file_path_length"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-path-length/type`.
            public var _type: Components.Schemas.RepositoryRuleMaxFilePathLength._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-path-length/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// The maximum amount of characters allowed in file paths.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-path-length/parameters/max_file_path_length`.
                public var maxFilePathLength: Swift.Int
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - maxFilePathLength: The maximum amount of characters allowed in file paths.
                public init(maxFilePathLength: Swift.Int) {
                    self.maxFilePathLength = maxFilePathLength
                }
                public enum CodingKeys: String, CodingKey {
                    case maxFilePathLength = "max_file_path_length"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-path-length/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleMaxFilePathLength.ParametersPayload?
            /// Creates a new `RepositoryRuleMaxFilePathLength`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleMaxFilePathLength._TypePayload,
                parameters: Components.Schemas.RepositoryRuleMaxFilePathLength.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Prevent commits that include files with specified file extensions from being pushed to the commit graph.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-file-extension-restriction`.
        public struct RepositoryRuleFileExtensionRestriction: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-extension-restriction/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case fileExtensionRestriction = "file_extension_restriction"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-extension-restriction/type`.
            public var _type: Components.Schemas.RepositoryRuleFileExtensionRestriction._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-extension-restriction/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// The file extensions that are restricted from being pushed to the commit graph.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-file-extension-restriction/parameters/restricted_file_extensions`.
                public var restrictedFileExtensions: [Swift.String]
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - restrictedFileExtensions: The file extensions that are restricted from being pushed to the commit graph.
                public init(restrictedFileExtensions: [Swift.String]) {
                    self.restrictedFileExtensions = restrictedFileExtensions
                }
                public enum CodingKeys: String, CodingKey {
                    case restrictedFileExtensions = "restricted_file_extensions"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-file-extension-restriction/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleFileExtensionRestriction.ParametersPayload?
            /// Creates a new `RepositoryRuleFileExtensionRestriction`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleFileExtensionRestriction._TypePayload,
                parameters: Components.Schemas.RepositoryRuleFileExtensionRestriction.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// Prevent commits with individual files that exceed the specified limit from being pushed to the commit graph.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-size`.
        public struct RepositoryRuleMaxFileSize: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-size/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case maxFileSize = "max_file_size"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-size/type`.
            public var _type: Components.Schemas.RepositoryRuleMaxFileSize._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-size/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-size/parameters/max_file_size`.
                public var maxFileSize: Swift.Int
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - maxFileSize: The maximum file size allowed in megabytes. This limit does not apply to Git Large File Storage (Git LFS).
                public init(maxFileSize: Swift.Int) {
                    self.maxFileSize = maxFileSize
                }
                public enum CodingKeys: String, CodingKey {
                    case maxFileSize = "max_file_size"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-max-file-size/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleMaxFileSize.ParametersPayload?
            /// Creates a new `RepositoryRuleMaxFileSize`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleMaxFileSize._TypePayload,
                parameters: Components.Schemas.RepositoryRuleMaxFileSize.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// A workflow that must run for this rule to pass
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-params-workflow-file-reference`.
        public struct RepositoryRuleParamsWorkflowFileReference: Codable, Hashable, Sendable {
            /// The path to the workflow file
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-workflow-file-reference/path`.
            public var path: Swift.String
            /// The ref (branch or tag) of the workflow file to use
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-workflow-file-reference/ref`.
            public var ref: Swift.String?
            /// The ID of the repository where the workflow is defined
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-workflow-file-reference/repository_id`.
            public var repositoryId: Swift.Int
            /// The commit SHA of the workflow file to use
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-workflow-file-reference/sha`.
            public var sha: Swift.String?
            /// Creates a new `RepositoryRuleParamsWorkflowFileReference`.
            ///
            /// - Parameters:
            ///   - path: The path to the workflow file
            ///   - ref: The ref (branch or tag) of the workflow file to use
            ///   - repositoryId: The ID of the repository where the workflow is defined
            ///   - sha: The commit SHA of the workflow file to use
            public init(
                path: Swift.String,
                ref: Swift.String? = nil,
                repositoryId: Swift.Int,
                sha: Swift.String? = nil
            ) {
                self.path = path
                self.ref = ref
                self.repositoryId = repositoryId
                self.sha = sha
            }
            public enum CodingKeys: String, CodingKey {
                case path
                case ref
                case repositoryId = "repository_id"
                case sha
            }
        }
        /// Require all changes made to a targeted branch to pass the specified workflows before they can be merged.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-workflows`.
        public struct RepositoryRuleWorkflows: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-workflows/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case workflows = "workflows"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-workflows/type`.
            public var _type: Components.Schemas.RepositoryRuleWorkflows._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-workflows/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// Allow repositories and branches to be created if a check would otherwise prohibit it.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-workflows/parameters/do_not_enforce_on_create`.
                public var doNotEnforceOnCreate: Swift.Bool?
                /// Workflows that must pass for this rule to pass.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-workflows/parameters/workflows`.
                public var workflows: [Components.Schemas.RepositoryRuleParamsWorkflowFileReference]
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - doNotEnforceOnCreate: Allow repositories and branches to be created if a check would otherwise prohibit it.
                ///   - workflows: Workflows that must pass for this rule to pass.
                public init(
                    doNotEnforceOnCreate: Swift.Bool? = nil,
                    workflows: [Components.Schemas.RepositoryRuleParamsWorkflowFileReference]
                ) {
                    self.doNotEnforceOnCreate = doNotEnforceOnCreate
                    self.workflows = workflows
                }
                public enum CodingKeys: String, CodingKey {
                    case doNotEnforceOnCreate = "do_not_enforce_on_create"
                    case workflows
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-workflows/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleWorkflows.ParametersPayload?
            /// Creates a new `RepositoryRuleWorkflows`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleWorkflows._TypePayload,
                parameters: Components.Schemas.RepositoryRuleWorkflows.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// A tool that must provide code scanning results for this rule to pass.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-params-code-scanning-tool`.
        public struct RepositoryRuleParamsCodeScanningTool: Codable, Hashable, Sendable {
            /// The severity level at which code scanning results that raise alerts block a reference update. For more information on alert severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-code-scanning-tool/alerts_threshold`.
            @frozen public enum AlertsThresholdPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case none = "none"
                case errors = "errors"
                case errorsAndWarnings = "errors_and_warnings"
                case all = "all"
            }
            /// The severity level at which code scanning results that raise alerts block a reference update. For more information on alert severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-code-scanning-tool/alerts_threshold`.
            public var alertsThreshold: Components.Schemas.RepositoryRuleParamsCodeScanningTool.AlertsThresholdPayload
            /// The severity level at which code scanning results that raise security alerts block a reference update. For more information on security severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-code-scanning-tool/security_alerts_threshold`.
            @frozen public enum SecurityAlertsThresholdPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case none = "none"
                case critical = "critical"
                case highOrHigher = "high_or_higher"
                case mediumOrHigher = "medium_or_higher"
                case all = "all"
            }
            /// The severity level at which code scanning results that raise security alerts block a reference update. For more information on security severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-code-scanning-tool/security_alerts_threshold`.
            public var securityAlertsThreshold: Components.Schemas.RepositoryRuleParamsCodeScanningTool.SecurityAlertsThresholdPayload
            /// The name of a code scanning tool
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-params-code-scanning-tool/tool`.
            public var tool: Swift.String
            /// Creates a new `RepositoryRuleParamsCodeScanningTool`.
            ///
            /// - Parameters:
            ///   - alertsThreshold: The severity level at which code scanning results that raise alerts block a reference update. For more information on alert severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
            ///   - securityAlertsThreshold: The severity level at which code scanning results that raise security alerts block a reference update. For more information on security severity levels, see "[About code scanning alerts](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels)."
            ///   - tool: The name of a code scanning tool
            public init(
                alertsThreshold: Components.Schemas.RepositoryRuleParamsCodeScanningTool.AlertsThresholdPayload,
                securityAlertsThreshold: Components.Schemas.RepositoryRuleParamsCodeScanningTool.SecurityAlertsThresholdPayload,
                tool: Swift.String
            ) {
                self.alertsThreshold = alertsThreshold
                self.securityAlertsThreshold = securityAlertsThreshold
                self.tool = tool
            }
            public enum CodingKeys: String, CodingKey {
                case alertsThreshold = "alerts_threshold"
                case securityAlertsThreshold = "security_alerts_threshold"
                case tool
            }
        }
        /// Choose which tools must provide code scanning results before the reference is updated. When configured, code scanning must be enabled and have results for both the commit and the reference being updated.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-code-scanning`.
        public struct RepositoryRuleCodeScanning: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-code-scanning/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case codeScanning = "code_scanning"
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-code-scanning/type`.
            public var _type: Components.Schemas.RepositoryRuleCodeScanning._TypePayload
            /// - Remark: Generated from `#/components/schemas/repository-rule-code-scanning/parameters`.
            public struct ParametersPayload: Codable, Hashable, Sendable {
                /// Tools that must provide code scanning results for this rule to pass.
                ///
                /// - Remark: Generated from `#/components/schemas/repository-rule-code-scanning/parameters/code_scanning_tools`.
                public var codeScanningTools: [Components.Schemas.RepositoryRuleParamsCodeScanningTool]
                /// Creates a new `ParametersPayload`.
                ///
                /// - Parameters:
                ///   - codeScanningTools: Tools that must provide code scanning results for this rule to pass.
                public init(codeScanningTools: [Components.Schemas.RepositoryRuleParamsCodeScanningTool]) {
                    self.codeScanningTools = codeScanningTools
                }
                public enum CodingKeys: String, CodingKey {
                    case codeScanningTools = "code_scanning_tools"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-code-scanning/parameters`.
            public var parameters: Components.Schemas.RepositoryRuleCodeScanning.ParametersPayload?
            /// Creates a new `RepositoryRuleCodeScanning`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - parameters:
            public init(
                _type: Components.Schemas.RepositoryRuleCodeScanning._TypePayload,
                parameters: Components.Schemas.RepositoryRuleCodeScanning.ParametersPayload? = nil
            ) {
                self._type = _type
                self.parameters = parameters
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case parameters
            }
        }
        /// A repository rule.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule`.
        @frozen public enum RepositoryRule: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule/case1`.
            case RepositoryRuleCreation(Components.Schemas.RepositoryRuleCreation)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case2`.
            case RepositoryRuleUpdate(Components.Schemas.RepositoryRuleUpdate)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case3`.
            case RepositoryRuleDeletion(Components.Schemas.RepositoryRuleDeletion)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case4`.
            case RepositoryRuleRequiredLinearHistory(Components.Schemas.RepositoryRuleRequiredLinearHistory)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case5`.
            case RepositoryRuleMergeQueue(Components.Schemas.RepositoryRuleMergeQueue)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case6`.
            case RepositoryRuleRequiredDeployments(Components.Schemas.RepositoryRuleRequiredDeployments)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case7`.
            case RepositoryRuleRequiredSignatures(Components.Schemas.RepositoryRuleRequiredSignatures)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case8`.
            case RepositoryRulePullRequest(Components.Schemas.RepositoryRulePullRequest)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case9`.
            case RepositoryRuleRequiredStatusChecks(Components.Schemas.RepositoryRuleRequiredStatusChecks)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case10`.
            case RepositoryRuleNonFastForward(Components.Schemas.RepositoryRuleNonFastForward)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case11`.
            case RepositoryRuleCommitMessagePattern(Components.Schemas.RepositoryRuleCommitMessagePattern)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case12`.
            case RepositoryRuleCommitAuthorEmailPattern(Components.Schemas.RepositoryRuleCommitAuthorEmailPattern)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case13`.
            case RepositoryRuleCommitterEmailPattern(Components.Schemas.RepositoryRuleCommitterEmailPattern)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case14`.
            case RepositoryRuleBranchNamePattern(Components.Schemas.RepositoryRuleBranchNamePattern)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case15`.
            case RepositoryRuleTagNamePattern(Components.Schemas.RepositoryRuleTagNamePattern)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case16`.
            case RepositoryRuleFilePathRestriction(Components.Schemas.RepositoryRuleFilePathRestriction)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case17`.
            case RepositoryRuleMaxFilePathLength(Components.Schemas.RepositoryRuleMaxFilePathLength)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case18`.
            case RepositoryRuleFileExtensionRestriction(Components.Schemas.RepositoryRuleFileExtensionRestriction)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case19`.
            case RepositoryRuleMaxFileSize(Components.Schemas.RepositoryRuleMaxFileSize)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case20`.
            case RepositoryRuleWorkflows(Components.Schemas.RepositoryRuleWorkflows)
            /// - Remark: Generated from `#/components/schemas/repository-rule/case21`.
            case RepositoryRuleCodeScanning(Components.Schemas.RepositoryRuleCodeScanning)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .RepositoryRuleCreation(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleUpdate(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleDeletion(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleRequiredLinearHistory(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleMergeQueue(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleRequiredDeployments(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleRequiredSignatures(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRulePullRequest(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleRequiredStatusChecks(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleNonFastForward(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleCommitMessagePattern(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleCommitAuthorEmailPattern(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleCommitterEmailPattern(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleBranchNamePattern(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleTagNamePattern(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleFilePathRestriction(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleMaxFilePathLength(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleFileExtensionRestriction(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleMaxFileSize(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleWorkflows(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .RepositoryRuleCodeScanning(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .RepositoryRuleCreation(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleUpdate(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleDeletion(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleRequiredLinearHistory(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleMergeQueue(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleRequiredDeployments(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleRequiredSignatures(value):
                    try value.encode(to: encoder)
                case let .RepositoryRulePullRequest(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleRequiredStatusChecks(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleNonFastForward(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleCommitMessagePattern(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleCommitAuthorEmailPattern(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleCommitterEmailPattern(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleBranchNamePattern(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleTagNamePattern(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleFilePathRestriction(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleMaxFilePathLength(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleFileExtensionRestriction(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleMaxFileSize(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleWorkflows(value):
                    try value.encode(to: encoder)
                case let .RepositoryRuleCodeScanning(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// A set of rules to apply when specified conditions are met.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-ruleset`.
        public struct RepositoryRuleset: Codable, Hashable, Sendable {
            /// The ID of the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/id`.
            public var id: Swift.Int
            /// The name of the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/name`.
            public var name: Swift.String
            /// The target of the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/target`.
            @frozen public enum TargetPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case branch = "branch"
                case tag = "tag"
                case push = "push"
                case repository = "repository"
            }
            /// The target of the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/target`.
            public var target: Components.Schemas.RepositoryRuleset.TargetPayload?
            /// The type of the source of the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/source_type`.
            @frozen public enum SourceTypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case repository = "Repository"
                case organization = "Organization"
                case enterprise = "Enterprise"
            }
            /// The type of the source of the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/source_type`.
            public var sourceType: Components.Schemas.RepositoryRuleset.SourceTypePayload?
            /// The name of the source
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/source`.
            public var source: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/enforcement`.
            public var enforcement: Components.Schemas.RepositoryRuleEnforcement
            /// The actors that can bypass the rules in this ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/bypass_actors`.
            public var bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]?
            /// The bypass type of the user making the API request for this ruleset. This field is only returned when
            /// querying the repository-level endpoint.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/current_user_can_bypass`.
            @frozen public enum CurrentUserCanBypassPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case always = "always"
                case pullRequestsOnly = "pull_requests_only"
                case never = "never"
            }
            /// The bypass type of the user making the API request for this ruleset. This field is only returned when
            /// querying the repository-level endpoint.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/current_user_can_bypass`.
            public var currentUserCanBypass: Components.Schemas.RepositoryRuleset.CurrentUserCanBypassPayload?
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/node_id`.
            public var nodeId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links/self`.
                public struct _SelfPayload: Codable, Hashable, Sendable {
                    /// The URL of the ruleset
                    ///
                    /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links/self/href`.
                    public var href: Swift.String?
                    /// Creates a new `_SelfPayload`.
                    ///
                    /// - Parameters:
                    ///   - href: The URL of the ruleset
                    public init(href: Swift.String? = nil) {
                        self.href = href
                    }
                    public enum CodingKeys: String, CodingKey {
                        case href
                    }
                }
                /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links/self`.
                public var _self: Components.Schemas.RepositoryRuleset._LinksPayload._SelfPayload?
                /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links/html`.
                public struct HtmlPayload: Codable, Hashable, Sendable {
                    /// The html URL of the ruleset
                    ///
                    /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links/html/href`.
                    public var href: Swift.String?
                    /// Creates a new `HtmlPayload`.
                    ///
                    /// - Parameters:
                    ///   - href: The html URL of the ruleset
                    public init(href: Swift.String? = nil) {
                        self.href = href
                    }
                    public enum CodingKeys: String, CodingKey {
                        case href
                    }
                }
                /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links/html`.
                public var html: Components.Schemas.RepositoryRuleset._LinksPayload.HtmlPayload?
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - _self:
                ///   - html:
                public init(
                    _self: Components.Schemas.RepositoryRuleset._LinksPayload._SelfPayload? = nil,
                    html: Components.Schemas.RepositoryRuleset._LinksPayload.HtmlPayload? = nil
                ) {
                    self._self = _self
                    self.html = html
                }
                public enum CodingKeys: String, CodingKey {
                    case _self = "self"
                    case html
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/_links`.
            public var _links: Components.Schemas.RepositoryRuleset._LinksPayload?
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/conditions`.
            public struct ConditionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-ruleset/conditions/value1`.
                public var value1: Components.Schemas.RepositoryRulesetConditions?
                /// - Remark: Generated from `#/components/schemas/repository-ruleset/conditions/value2`.
                public var value2: Components.Schemas.OrgRulesetConditions?
                /// Creates a new `ConditionsPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRulesetConditions? = nil,
                    value2: Components.Schemas.OrgRulesetConditions? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self.value1 = try .init(from: decoder)
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self.value2 = try .init(from: decoder)
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            self.value1,
                            self.value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1?.encode(to: encoder)
                    try self.value2?.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/conditions`.
            public var conditions: Components.Schemas.RepositoryRuleset.ConditionsPayload?
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/rules`.
            public var rules: [Components.Schemas.RepositoryRule]?
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/created_at`.
            public var createdAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/repository-ruleset/updated_at`.
            public var updatedAt: Foundation.Date?
            /// Creates a new `RepositoryRuleset`.
            ///
            /// - Parameters:
            ///   - id: The ID of the ruleset
            ///   - name: The name of the ruleset
            ///   - target: The target of the ruleset
            ///   - sourceType: The type of the source of the ruleset
            ///   - source: The name of the source
            ///   - enforcement:
            ///   - bypassActors: The actors that can bypass the rules in this ruleset
            ///   - currentUserCanBypass: The bypass type of the user making the API request for this ruleset. This field is only returned when
            ///   - nodeId:
            ///   - _links:
            ///   - conditions:
            ///   - rules:
            ///   - createdAt:
            ///   - updatedAt:
            public init(
                id: Swift.Int,
                name: Swift.String,
                target: Components.Schemas.RepositoryRuleset.TargetPayload? = nil,
                sourceType: Components.Schemas.RepositoryRuleset.SourceTypePayload? = nil,
                source: Swift.String,
                enforcement: Components.Schemas.RepositoryRuleEnforcement,
                bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]? = nil,
                currentUserCanBypass: Components.Schemas.RepositoryRuleset.CurrentUserCanBypassPayload? = nil,
                nodeId: Swift.String? = nil,
                _links: Components.Schemas.RepositoryRuleset._LinksPayload? = nil,
                conditions: Components.Schemas.RepositoryRuleset.ConditionsPayload? = nil,
                rules: [Components.Schemas.RepositoryRule]? = nil,
                createdAt: Foundation.Date? = nil,
                updatedAt: Foundation.Date? = nil
            ) {
                self.id = id
                self.name = name
                self.target = target
                self.sourceType = sourceType
                self.source = source
                self.enforcement = enforcement
                self.bypassActors = bypassActors
                self.currentUserCanBypass = currentUserCanBypass
                self.nodeId = nodeId
                self._links = _links
                self.conditions = conditions
                self.rules = rules
                self.createdAt = createdAt
                self.updatedAt = updatedAt
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case name
                case target
                case sourceType = "source_type"
                case source
                case enforcement
                case bypassActors = "bypass_actors"
                case currentUserCanBypass = "current_user_can_bypass"
                case nodeId = "node_id"
                case _links
                case conditions
                case rules
                case createdAt = "created_at"
                case updatedAt = "updated_at"
            }
        }
        /// - Remark: Generated from `#/components/schemas/RuleSuites`.
        public struct RuleSuitesPayload: Codable, Hashable, Sendable {
            /// The unique identifier of the rule insight.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/id`.
            public var id: Swift.Int?
            /// The number that identifies the user.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/actor_id`.
            public var actorId: Swift.Int?
            /// The handle for the GitHub user account.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/actor_name`.
            public var actorName: Swift.String?
            /// The first commit sha before the push evaluation.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/before_sha`.
            public var beforeSha: Swift.String?
            /// The last commit sha in the push evaluation.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/after_sha`.
            public var afterSha: Swift.String?
            /// The ref name that the evaluation ran on.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/ref`.
            public var ref: Swift.String?
            /// The ID of the repository associated with the rule evaluation.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/repository_id`.
            public var repositoryId: Swift.Int?
            /// The name of the repository without the `.git` extension.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/repository_name`.
            public var repositoryName: Swift.String?
            /// - Remark: Generated from `#/components/schemas/RuleSuites/pushed_at`.
            public var pushedAt: Foundation.Date?
            /// The result of the rule evaluations for rules with the `active` enforcement status.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/result`.
            @frozen public enum ResultPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case pass = "pass"
                case fail = "fail"
                case bypass = "bypass"
            }
            /// The result of the rule evaluations for rules with the `active` enforcement status.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/result`.
            public var result: Components.Schemas.RuleSuitesPayload.ResultPayload?
            /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/evaluation_result`.
            @frozen public enum EvaluationResultPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case pass = "pass"
                case fail = "fail"
                case bypass = "bypass"
            }
            /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
            ///
            /// - Remark: Generated from `#/components/schemas/RuleSuites/evaluation_result`.
            public var evaluationResult: Components.Schemas.RuleSuitesPayload.EvaluationResultPayload?
            /// Creates a new `RuleSuitesPayload`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of the rule insight.
            ///   - actorId: The number that identifies the user.
            ///   - actorName: The handle for the GitHub user account.
            ///   - beforeSha: The first commit sha before the push evaluation.
            ///   - afterSha: The last commit sha in the push evaluation.
            ///   - ref: The ref name that the evaluation ran on.
            ///   - repositoryId: The ID of the repository associated with the rule evaluation.
            ///   - repositoryName: The name of the repository without the `.git` extension.
            ///   - pushedAt:
            ///   - result: The result of the rule evaluations for rules with the `active` enforcement status.
            ///   - evaluationResult: The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`.
            public init(
                id: Swift.Int? = nil,
                actorId: Swift.Int? = nil,
                actorName: Swift.String? = nil,
                beforeSha: Swift.String? = nil,
                afterSha: Swift.String? = nil,
                ref: Swift.String? = nil,
                repositoryId: Swift.Int? = nil,
                repositoryName: Swift.String? = nil,
                pushedAt: Foundation.Date? = nil,
                result: Components.Schemas.RuleSuitesPayload.ResultPayload? = nil,
                evaluationResult: Components.Schemas.RuleSuitesPayload.EvaluationResultPayload? = nil
            ) {
                self.id = id
                self.actorId = actorId
                self.actorName = actorName
                self.beforeSha = beforeSha
                self.afterSha = afterSha
                self.ref = ref
                self.repositoryId = repositoryId
                self.repositoryName = repositoryName
                self.pushedAt = pushedAt
                self.result = result
                self.evaluationResult = evaluationResult
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case actorId = "actor_id"
                case actorName = "actor_name"
                case beforeSha = "before_sha"
                case afterSha = "after_sha"
                case ref
                case repositoryId = "repository_id"
                case repositoryName = "repository_name"
                case pushedAt = "pushed_at"
                case result
                case evaluationResult = "evaluation_result"
            }
        }
        /// Response
        ///
        /// - Remark: Generated from `#/components/schemas/rule-suites`.
        public typealias RuleSuites = [Components.Schemas.RuleSuitesPayload]
        /// Response
        ///
        /// - Remark: Generated from `#/components/schemas/rule-suite`.
        public struct RuleSuite: Codable, Hashable, Sendable {
            /// The unique identifier of the rule insight.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/id`.
            public var id: Swift.Int?
            /// The number that identifies the user.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/actor_id`.
            public var actorId: Swift.Int?
            /// The handle for the GitHub user account.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/actor_name`.
            public var actorName: Swift.String?
            /// The first commit sha before the push evaluation.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/before_sha`.
            public var beforeSha: Swift.String?
            /// The last commit sha in the push evaluation.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/after_sha`.
            public var afterSha: Swift.String?
            /// The ref name that the evaluation ran on.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/ref`.
            public var ref: Swift.String?
            /// The ID of the repository associated with the rule evaluation.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/repository_id`.
            public var repositoryId: Swift.Int?
            /// The name of the repository without the `.git` extension.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/repository_name`.
            public var repositoryName: Swift.String?
            /// - Remark: Generated from `#/components/schemas/rule-suite/pushed_at`.
            public var pushedAt: Foundation.Date?
            /// The result of the rule evaluations for rules with the `active` enforcement status.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/result`.
            @frozen public enum ResultPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case pass = "pass"
                case fail = "fail"
                case bypass = "bypass"
            }
            /// The result of the rule evaluations for rules with the `active` enforcement status.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/result`.
            public var result: Components.Schemas.RuleSuite.ResultPayload?
            /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/evaluation_result`.
            @frozen public enum EvaluationResultPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case pass = "pass"
                case fail = "fail"
                case bypass = "bypass"
            }
            /// The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/evaluation_result`.
            public var evaluationResult: Components.Schemas.RuleSuite.EvaluationResultPayload?
            /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload`.
            public struct RuleEvaluationsPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/rule_source`.
                public struct RuleSourcePayload: Codable, Hashable, Sendable {
                    /// The type of rule source.
                    ///
                    /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/rule_source/type`.
                    public var _type: Swift.String?
                    /// The ID of the rule source.
                    ///
                    /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/rule_source/id`.
                    public var id: Swift.Int?
                    /// The name of the rule source.
                    ///
                    /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/rule_source/name`.
                    public var name: Swift.String?
                    /// Creates a new `RuleSourcePayload`.
                    ///
                    /// - Parameters:
                    ///   - _type: The type of rule source.
                    ///   - id: The ID of the rule source.
                    ///   - name: The name of the rule source.
                    public init(
                        _type: Swift.String? = nil,
                        id: Swift.Int? = nil,
                        name: Swift.String? = nil
                    ) {
                        self._type = _type
                        self.id = id
                        self.name = name
                    }
                    public enum CodingKeys: String, CodingKey {
                        case _type = "type"
                        case id
                        case name
                    }
                }
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/rule_source`.
                public var ruleSource: Components.Schemas.RuleSuite.RuleEvaluationsPayloadPayload.RuleSourcePayload?
                /// The enforcement level of this rule source.
                ///
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/enforcement`.
                @frozen public enum EnforcementPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case active = "active"
                    case evaluate = "evaluate"
                    case deletedRuleset = "deleted ruleset"
                }
                /// The enforcement level of this rule source.
                ///
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/enforcement`.
                public var enforcement: Components.Schemas.RuleSuite.RuleEvaluationsPayloadPayload.EnforcementPayload?
                /// The result of the evaluation of the individual rule.
                ///
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/result`.
                @frozen public enum ResultPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case pass = "pass"
                    case fail = "fail"
                }
                /// The result of the evaluation of the individual rule.
                ///
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/result`.
                public var result: Components.Schemas.RuleSuite.RuleEvaluationsPayloadPayload.ResultPayload?
                /// The type of rule.
                ///
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/rule_type`.
                public var ruleType: Swift.String?
                /// The detailed failure message for the rule. Null if the rule passed.
                ///
                /// - Remark: Generated from `#/components/schemas/rule-suite/RuleEvaluationsPayload/details`.
                public var details: Swift.String?
                /// Creates a new `RuleEvaluationsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - ruleSource:
                ///   - enforcement: The enforcement level of this rule source.
                ///   - result: The result of the evaluation of the individual rule.
                ///   - ruleType: The type of rule.
                ///   - details: The detailed failure message for the rule. Null if the rule passed.
                public init(
                    ruleSource: Components.Schemas.RuleSuite.RuleEvaluationsPayloadPayload.RuleSourcePayload? = nil,
                    enforcement: Components.Schemas.RuleSuite.RuleEvaluationsPayloadPayload.EnforcementPayload? = nil,
                    result: Components.Schemas.RuleSuite.RuleEvaluationsPayloadPayload.ResultPayload? = nil,
                    ruleType: Swift.String? = nil,
                    details: Swift.String? = nil
                ) {
                    self.ruleSource = ruleSource
                    self.enforcement = enforcement
                    self.result = result
                    self.ruleType = ruleType
                    self.details = details
                }
                public enum CodingKeys: String, CodingKey {
                    case ruleSource = "rule_source"
                    case enforcement
                    case result
                    case ruleType = "rule_type"
                    case details
                }
            }
            /// Details on the evaluated rules.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/rule_evaluations`.
            public typealias RuleEvaluationsPayload = [Components.Schemas.RuleSuite.RuleEvaluationsPayloadPayload]
            /// Details on the evaluated rules.
            ///
            /// - Remark: Generated from `#/components/schemas/rule-suite/rule_evaluations`.
            public var ruleEvaluations: Components.Schemas.RuleSuite.RuleEvaluationsPayload?
            /// Creates a new `RuleSuite`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of the rule insight.
            ///   - actorId: The number that identifies the user.
            ///   - actorName: The handle for the GitHub user account.
            ///   - beforeSha: The first commit sha before the push evaluation.
            ///   - afterSha: The last commit sha in the push evaluation.
            ///   - ref: The ref name that the evaluation ran on.
            ///   - repositoryId: The ID of the repository associated with the rule evaluation.
            ///   - repositoryName: The name of the repository without the `.git` extension.
            ///   - pushedAt:
            ///   - result: The result of the rule evaluations for rules with the `active` enforcement status.
            ///   - evaluationResult: The result of the rule evaluations for rules with the `active` and `evaluate` enforcement statuses, demonstrating whether rules would pass or fail if all rules in the rule suite were `active`. Null if no rules with `evaluate` enforcement status were run.
            ///   - ruleEvaluations: Details on the evaluated rules.
            public init(
                id: Swift.Int? = nil,
                actorId: Swift.Int? = nil,
                actorName: Swift.String? = nil,
                beforeSha: Swift.String? = nil,
                afterSha: Swift.String? = nil,
                ref: Swift.String? = nil,
                repositoryId: Swift.Int? = nil,
                repositoryName: Swift.String? = nil,
                pushedAt: Foundation.Date? = nil,
                result: Components.Schemas.RuleSuite.ResultPayload? = nil,
                evaluationResult: Components.Schemas.RuleSuite.EvaluationResultPayload? = nil,
                ruleEvaluations: Components.Schemas.RuleSuite.RuleEvaluationsPayload? = nil
            ) {
                self.id = id
                self.actorId = actorId
                self.actorName = actorName
                self.beforeSha = beforeSha
                self.afterSha = afterSha
                self.ref = ref
                self.repositoryId = repositoryId
                self.repositoryName = repositoryName
                self.pushedAt = pushedAt
                self.result = result
                self.evaluationResult = evaluationResult
                self.ruleEvaluations = ruleEvaluations
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case actorId = "actor_id"
                case actorName = "actor_name"
                case beforeSha = "before_sha"
                case afterSha = "after_sha"
                case ref
                case repositoryId = "repository_id"
                case repositoryName = "repository_name"
                case pushedAt = "pushed_at"
                case result
                case evaluationResult = "evaluation_result"
                case ruleEvaluations = "rule_evaluations"
            }
        }
        /// The historical version of a ruleset
        ///
        /// - Remark: Generated from `#/components/schemas/ruleset-version`.
        public struct RulesetVersion: Codable, Hashable, Sendable {
            /// The ID of the previous version of the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/ruleset-version/version_id`.
            public var versionId: Swift.Int
            /// The actor who updated the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/ruleset-version/actor`.
            public struct ActorPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/ruleset-version/actor/id`.
                public var id: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/ruleset-version/actor/type`.
                public var _type: Swift.String?
                /// Creates a new `ActorPayload`.
                ///
                /// - Parameters:
                ///   - id:
                ///   - _type:
                public init(
                    id: Swift.Int? = nil,
                    _type: Swift.String? = nil
                ) {
                    self.id = id
                    self._type = _type
                }
                public enum CodingKeys: String, CodingKey {
                    case id
                    case _type = "type"
                }
            }
            /// The actor who updated the ruleset
            ///
            /// - Remark: Generated from `#/components/schemas/ruleset-version/actor`.
            public var actor: Components.Schemas.RulesetVersion.ActorPayload
            /// - Remark: Generated from `#/components/schemas/ruleset-version/updated_at`.
            public var updatedAt: Foundation.Date
            /// Creates a new `RulesetVersion`.
            ///
            /// - Parameters:
            ///   - versionId: The ID of the previous version of the ruleset
            ///   - actor: The actor who updated the ruleset
            ///   - updatedAt:
            public init(
                versionId: Swift.Int,
                actor: Components.Schemas.RulesetVersion.ActorPayload,
                updatedAt: Foundation.Date
            ) {
                self.versionId = versionId
                self.actor = actor
                self.updatedAt = updatedAt
            }
            public enum CodingKeys: String, CodingKey {
                case versionId = "version_id"
                case actor
                case updatedAt = "updated_at"
            }
        }
        /// - Remark: Generated from `#/components/schemas/ruleset-version-with-state`.
        public struct RulesetVersionWithState: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/ruleset-version-with-state/value1`.
            public var value1: Components.Schemas.RulesetVersion
            /// - Remark: Generated from `#/components/schemas/ruleset-version-with-state/value2`.
            public struct Value2Payload: Codable, Hashable, Sendable {
                /// The state of the ruleset version
                ///
                /// - Remark: Generated from `#/components/schemas/ruleset-version-with-state/value2/state`.
                public var state: OpenAPIRuntime.OpenAPIObjectContainer
                /// Creates a new `Value2Payload`.
                ///
                /// - Parameters:
                ///   - state: The state of the ruleset version
                public init(state: OpenAPIRuntime.OpenAPIObjectContainer) {
                    self.state = state
                }
                public enum CodingKeys: String, CodingKey {
                    case state
                }
            }
            /// - Remark: Generated from `#/components/schemas/ruleset-version-with-state/value2`.
            public var value2: Components.Schemas.RulesetVersionWithState.Value2Payload
            /// Creates a new `RulesetVersionWithState`.
            ///
            /// - Parameters:
            ///   - value1:
            ///   - value2:
            public init(
                value1: Components.Schemas.RulesetVersion,
                value2: Components.Schemas.RulesetVersionWithState.Value2Payload
            ) {
                self.value1 = value1
                self.value2 = value2
            }
            public init(from decoder: any Decoder) throws {
                self.value1 = try .init(from: decoder)
                self.value2 = try .init(from: decoder)
            }
            public func encode(to encoder: any Encoder) throws {
                try self.value1.encode(to: encoder)
                try self.value2.encode(to: encoder)
            }
        }
        /// The type of reviewer.
        ///
        /// - Remark: Generated from `#/components/schemas/deployment-reviewer-type`.
        @frozen public enum DeploymentReviewerType: String, Codable, Hashable, Sendable, CaseIterable {
            case user = "User"
            case team = "Team"
        }
        /// A request for a specific ref(branch,sha,tag) to be deployed
        ///
        /// - Remark: Generated from `#/components/schemas/deployment`.
        public struct Deployment: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/deployment/url`.
            public var url: Swift.String
            /// Unique identifier of the deployment
            ///
            /// - Remark: Generated from `#/components/schemas/deployment/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/deployment/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/deployment/sha`.
            public var sha: Swift.String
            /// The ref to deploy. This can be a branch, tag, or sha.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment/ref`.
            public var ref: Swift.String
            /// Parameter to specify a task to execute
            ///
            /// - Remark: Generated from `#/components/schemas/deployment/task`.
            public var task: Swift.String
            /// - Remark: Generated from `#/components/schemas/deployment/payload`.
            @frozen public enum PayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/deployment/payload/case1`.
                public struct Case1Payload: Codable, Hashable, Sendable {
                    /// A container of undocumented properties.
                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                    /// Creates a new `Case1Payload`.
                    ///
                    /// - Parameters:
                    ///   - additionalProperties: A container of undocumented properties.
                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                        self.additionalProperties = additionalProperties
                    }
                    public init(from decoder: any Decoder) throws {
                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeAdditionalProperties(additionalProperties)
                    }
                }
                /// - Remark: Generated from `#/components/schemas/deployment/payload/case1`.
                case case1(Components.Schemas.Deployment.PayloadPayload.Case1Payload)
                /// - Remark: Generated from `#/components/schemas/deployment/payload/case2`.
                case case2(Swift.String)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .case1(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .case2(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .case1(value):
                        try value.encode(to: encoder)
                    case let .case2(value):
                        try encoder.encodeToSingleValueContainer(value)
                    }
                }
            }
            /// - Remark: Generated from `#/components/schemas/deployment/payload`.
            public var payload: Components.Schemas.Deployment.PayloadPayload
            /// - Remark: Generated from `#/components/schemas/deployment/original_environment`.
            public var originalEnvironment: Swift.String?
            /// Name for the target deployment environment.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment/environment`.
            public var environment: Swift.String
            /// - Remark: Generated from `#/components/schemas/deployment/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/deployment/creator`.
            public var creator: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/deployment/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/deployment/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/deployment/statuses_url`.
            public var statusesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/deployment/repository_url`.
            public var repositoryUrl: Swift.String
            /// Specifies if the given environment is will no longer exist at some point in the future. Default: false.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment/transient_environment`.
            public var transientEnvironment: Swift.Bool?
            /// Specifies if the given environment is one that end-users directly interact with. Default: false.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment/production_environment`.
            public var productionEnvironment: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/deployment/performed_via_github_app`.
            public var performedViaGithubApp: Components.Schemas.NullableIntegration?
            /// Creates a new `Deployment`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - id: Unique identifier of the deployment
            ///   - nodeId:
            ///   - sha:
            ///   - ref: The ref to deploy. This can be a branch, tag, or sha.
            ///   - task: Parameter to specify a task to execute
            ///   - payload:
            ///   - originalEnvironment:
            ///   - environment: Name for the target deployment environment.
            ///   - description:
            ///   - creator:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - statusesUrl:
            ///   - repositoryUrl:
            ///   - transientEnvironment: Specifies if the given environment is will no longer exist at some point in the future. Default: false.
            ///   - productionEnvironment: Specifies if the given environment is one that end-users directly interact with. Default: false.
            ///   - performedViaGithubApp:
            public init(
                url: Swift.String,
                id: Swift.Int64,
                nodeId: Swift.String,
                sha: Swift.String,
                ref: Swift.String,
                task: Swift.String,
                payload: Components.Schemas.Deployment.PayloadPayload,
                originalEnvironment: Swift.String? = nil,
                environment: Swift.String,
                description: Swift.String? = nil,
                creator: Components.Schemas.NullableSimpleUser? = nil,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                statusesUrl: Swift.String,
                repositoryUrl: Swift.String,
                transientEnvironment: Swift.Bool? = nil,
                productionEnvironment: Swift.Bool? = nil,
                performedViaGithubApp: Components.Schemas.NullableIntegration? = nil
            ) {
                self.url = url
                self.id = id
                self.nodeId = nodeId
                self.sha = sha
                self.ref = ref
                self.task = task
                self.payload = payload
                self.originalEnvironment = originalEnvironment
                self.environment = environment
                self.description = description
                self.creator = creator
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.statusesUrl = statusesUrl
                self.repositoryUrl = repositoryUrl
                self.transientEnvironment = transientEnvironment
                self.productionEnvironment = productionEnvironment
                self.performedViaGithubApp = performedViaGithubApp
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case id
                case nodeId = "node_id"
                case sha
                case ref
                case task
                case payload
                case originalEnvironment = "original_environment"
                case environment
                case description
                case creator
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case statusesUrl = "statuses_url"
                case repositoryUrl = "repository_url"
                case transientEnvironment = "transient_environment"
                case productionEnvironment = "production_environment"
                case performedViaGithubApp = "performed_via_github_app"
            }
        }
        /// Activity
        ///
        /// - Remark: Generated from `#/components/schemas/activity`.
        public struct Activity: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/activity/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/activity/node_id`.
            public var nodeId: Swift.String
            /// The SHA of the commit before the activity.
            ///
            /// - Remark: Generated from `#/components/schemas/activity/before`.
            public var before: Swift.String
            /// The SHA of the commit after the activity.
            ///
            /// - Remark: Generated from `#/components/schemas/activity/after`.
            public var after: Swift.String
            /// The full Git reference, formatted as `refs/heads/<branch name>`.
            ///
            /// - Remark: Generated from `#/components/schemas/activity/ref`.
            public var ref: Swift.String
            /// The time when the activity occurred.
            ///
            /// - Remark: Generated from `#/components/schemas/activity/timestamp`.
            public var timestamp: Foundation.Date
            /// The type of the activity that was performed.
            ///
            /// - Remark: Generated from `#/components/schemas/activity/activity_type`.
            @frozen public enum ActivityTypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case push = "push"
                case forcePush = "force_push"
                case branchDeletion = "branch_deletion"
                case branchCreation = "branch_creation"
                case prMerge = "pr_merge"
                case mergeQueueMerge = "merge_queue_merge"
            }
            /// The type of the activity that was performed.
            ///
            /// - Remark: Generated from `#/components/schemas/activity/activity_type`.
            public var activityType: Components.Schemas.Activity.ActivityTypePayload
            /// - Remark: Generated from `#/components/schemas/activity/actor`.
            public var actor: Components.Schemas.NullableSimpleUser?
            /// Creates a new `Activity`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - nodeId:
            ///   - before: The SHA of the commit before the activity.
            ///   - after: The SHA of the commit after the activity.
            ///   - ref: The full Git reference, formatted as `refs/heads/<branch name>`.
            ///   - timestamp: The time when the activity occurred.
            ///   - activityType: The type of the activity that was performed.
            ///   - actor:
            public init(
                id: Swift.Int,
                nodeId: Swift.String,
                before: Swift.String,
                after: Swift.String,
                ref: Swift.String,
                timestamp: Foundation.Date,
                activityType: Components.Schemas.Activity.ActivityTypePayload,
                actor: Components.Schemas.NullableSimpleUser? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.before = before
                self.after = after
                self.ref = ref
                self.timestamp = timestamp
                self.activityType = activityType
                self.actor = actor
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case before
                case after
                case ref
                case timestamp
                case activityType = "activity_type"
                case actor
            }
        }
        /// An autolink reference.
        ///
        /// - Remark: Generated from `#/components/schemas/autolink`.
        public struct Autolink: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/autolink/id`.
            public var id: Swift.Int
            /// The prefix of a key that is linkified.
            ///
            /// - Remark: Generated from `#/components/schemas/autolink/key_prefix`.
            public var keyPrefix: Swift.String
            /// A template for the target URL that is generated if a key was found.
            ///
            /// - Remark: Generated from `#/components/schemas/autolink/url_template`.
            public var urlTemplate: Swift.String
            /// Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters.
            ///
            /// - Remark: Generated from `#/components/schemas/autolink/is_alphanumeric`.
            public var isAlphanumeric: Swift.Bool
            /// Creates a new `Autolink`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - keyPrefix: The prefix of a key that is linkified.
            ///   - urlTemplate: A template for the target URL that is generated if a key was found.
            ///   - isAlphanumeric: Whether this autolink reference matches alphanumeric characters. If false, this autolink reference only matches numeric characters.
            public init(
                id: Swift.Int,
                keyPrefix: Swift.String,
                urlTemplate: Swift.String,
                isAlphanumeric: Swift.Bool
            ) {
                self.id = id
                self.keyPrefix = keyPrefix
                self.urlTemplate = urlTemplate
                self.isAlphanumeric = isAlphanumeric
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case keyPrefix = "key_prefix"
                case urlTemplate = "url_template"
                case isAlphanumeric = "is_alphanumeric"
            }
        }
        /// Check Dependabot security updates
        ///
        /// - Remark: Generated from `#/components/schemas/check-automated-security-fixes`.
        public struct CheckAutomatedSecurityFixes: Codable, Hashable, Sendable {
            /// Whether Dependabot security updates are enabled for the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/check-automated-security-fixes/enabled`.
            public var enabled: Swift.Bool
            /// Whether Dependabot security updates are paused for the repository.
            ///
            /// - Remark: Generated from `#/components/schemas/check-automated-security-fixes/paused`.
            public var paused: Swift.Bool
            /// Creates a new `CheckAutomatedSecurityFixes`.
            ///
            /// - Parameters:
            ///   - enabled: Whether Dependabot security updates are enabled for the repository.
            ///   - paused: Whether Dependabot security updates are paused for the repository.
            public init(
                enabled: Swift.Bool,
                paused: Swift.Bool
            ) {
                self.enabled = enabled
                self.paused = paused
            }
            public enum CodingKeys: String, CodingKey {
                case enabled
                case paused
            }
        }
        /// Protected Branch Required Status Check
        ///
        /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check`.
        public struct ProtectedBranchRequiredStatusCheck: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/url`.
            public var url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/enforcement_level`.
            public var enforcementLevel: Swift.String?
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/contexts`.
            public var contexts: [Swift.String]
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/ChecksPayload`.
            public struct ChecksPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/ChecksPayload/context`.
                public var context: Swift.String
                /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/ChecksPayload/app_id`.
                public var appId: Swift.Int?
                /// Creates a new `ChecksPayloadPayload`.
                ///
                /// - Parameters:
                ///   - context:
                ///   - appId:
                public init(
                    context: Swift.String,
                    appId: Swift.Int? = nil
                ) {
                    self.context = context
                    self.appId = appId
                }
                public enum CodingKeys: String, CodingKey {
                    case context
                    case appId = "app_id"
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/checks`.
            public typealias ChecksPayload = [Components.Schemas.ProtectedBranchRequiredStatusCheck.ChecksPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/checks`.
            public var checks: Components.Schemas.ProtectedBranchRequiredStatusCheck.ChecksPayload
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/contexts_url`.
            public var contextsUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/protected-branch-required-status-check/strict`.
            public var strict: Swift.Bool?
            /// Creates a new `ProtectedBranchRequiredStatusCheck`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - enforcementLevel:
            ///   - contexts:
            ///   - checks:
            ///   - contextsUrl:
            ///   - strict:
            public init(
                url: Swift.String? = nil,
                enforcementLevel: Swift.String? = nil,
                contexts: [Swift.String],
                checks: Components.Schemas.ProtectedBranchRequiredStatusCheck.ChecksPayload,
                contextsUrl: Swift.String? = nil,
                strict: Swift.Bool? = nil
            ) {
                self.url = url
                self.enforcementLevel = enforcementLevel
                self.contexts = contexts
                self.checks = checks
                self.contextsUrl = contextsUrl
                self.strict = strict
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case enforcementLevel = "enforcement_level"
                case contexts
                case checks
                case contextsUrl = "contexts_url"
                case strict
            }
        }
        /// Protected Branch Admin Enforced
        ///
        /// - Remark: Generated from `#/components/schemas/protected-branch-admin-enforced`.
        public struct ProtectedBranchAdminEnforced: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/protected-branch-admin-enforced/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/protected-branch-admin-enforced/enabled`.
            public var enabled: Swift.Bool
            /// Creates a new `ProtectedBranchAdminEnforced`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - enabled:
            public init(
                url: Swift.String,
                enabled: Swift.Bool
            ) {
                self.url = url
                self.enabled = enabled
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case enabled
            }
        }
        /// Protected Branch Pull Request Review
        ///
        /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review`.
        public struct ProtectedBranchPullRequestReview: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/url`.
            public var url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions`.
            public struct DismissalRestrictionsPayload: Codable, Hashable, Sendable {
                /// The list of users with review dismissal access.
                ///
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions/users`.
                public var users: [Components.Schemas.SimpleUser]?
                /// The list of teams with review dismissal access.
                ///
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions/teams`.
                public var teams: [Components.Schemas.Team]?
                /// The list of apps with review dismissal access.
                ///
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions/apps`.
                public var apps: [Components.Schemas.Integration]?
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions/url`.
                public var url: Swift.String?
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions/users_url`.
                public var usersUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions/teams_url`.
                public var teamsUrl: Swift.String?
                /// Creates a new `DismissalRestrictionsPayload`.
                ///
                /// - Parameters:
                ///   - users: The list of users with review dismissal access.
                ///   - teams: The list of teams with review dismissal access.
                ///   - apps: The list of apps with review dismissal access.
                ///   - url:
                ///   - usersUrl:
                ///   - teamsUrl:
                public init(
                    users: [Components.Schemas.SimpleUser]? = nil,
                    teams: [Components.Schemas.Team]? = nil,
                    apps: [Components.Schemas.Integration]? = nil,
                    url: Swift.String? = nil,
                    usersUrl: Swift.String? = nil,
                    teamsUrl: Swift.String? = nil
                ) {
                    self.users = users
                    self.teams = teams
                    self.apps = apps
                    self.url = url
                    self.usersUrl = usersUrl
                    self.teamsUrl = teamsUrl
                }
                public enum CodingKeys: String, CodingKey {
                    case users
                    case teams
                    case apps
                    case url
                    case usersUrl = "users_url"
                    case teamsUrl = "teams_url"
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismissal_restrictions`.
            public var dismissalRestrictions: Components.Schemas.ProtectedBranchPullRequestReview.DismissalRestrictionsPayload?
            /// Allow specific users, teams, or apps to bypass pull request requirements.
            ///
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/bypass_pull_request_allowances`.
            public struct BypassPullRequestAllowancesPayload: Codable, Hashable, Sendable {
                /// The list of users allowed to bypass pull request requirements.
                ///
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/bypass_pull_request_allowances/users`.
                public var users: [Components.Schemas.SimpleUser]?
                /// The list of teams allowed to bypass pull request requirements.
                ///
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/bypass_pull_request_allowances/teams`.
                public var teams: [Components.Schemas.Team]?
                /// The list of apps allowed to bypass pull request requirements.
                ///
                /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/bypass_pull_request_allowances/apps`.
                public var apps: [Components.Schemas.Integration]?
                /// Creates a new `BypassPullRequestAllowancesPayload`.
                ///
                /// - Parameters:
                ///   - users: The list of users allowed to bypass pull request requirements.
                ///   - teams: The list of teams allowed to bypass pull request requirements.
                ///   - apps: The list of apps allowed to bypass pull request requirements.
                public init(
                    users: [Components.Schemas.SimpleUser]? = nil,
                    teams: [Components.Schemas.Team]? = nil,
                    apps: [Components.Schemas.Integration]? = nil
                ) {
                    self.users = users
                    self.teams = teams
                    self.apps = apps
                }
                public enum CodingKeys: String, CodingKey {
                    case users
                    case teams
                    case apps
                }
            }
            /// Allow specific users, teams, or apps to bypass pull request requirements.
            ///
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/bypass_pull_request_allowances`.
            public var bypassPullRequestAllowances: Components.Schemas.ProtectedBranchPullRequestReview.BypassPullRequestAllowancesPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/dismiss_stale_reviews`.
            public var dismissStaleReviews: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/require_code_owner_reviews`.
            public var requireCodeOwnerReviews: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/required_approving_review_count`.
            public var requiredApprovingReviewCount: Swift.Int?
            /// Whether the most recent push must be approved by someone other than the person who pushed it.
            ///
            /// - Remark: Generated from `#/components/schemas/protected-branch-pull-request-review/require_last_push_approval`.
            public var requireLastPushApproval: Swift.Bool?
            /// Creates a new `ProtectedBranchPullRequestReview`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - dismissalRestrictions:
            ///   - bypassPullRequestAllowances: Allow specific users, teams, or apps to bypass pull request requirements.
            ///   - dismissStaleReviews:
            ///   - requireCodeOwnerReviews:
            ///   - requiredApprovingReviewCount:
            ///   - requireLastPushApproval: Whether the most recent push must be approved by someone other than the person who pushed it.
            public init(
                url: Swift.String? = nil,
                dismissalRestrictions: Components.Schemas.ProtectedBranchPullRequestReview.DismissalRestrictionsPayload? = nil,
                bypassPullRequestAllowances: Components.Schemas.ProtectedBranchPullRequestReview.BypassPullRequestAllowancesPayload? = nil,
                dismissStaleReviews: Swift.Bool,
                requireCodeOwnerReviews: Swift.Bool,
                requiredApprovingReviewCount: Swift.Int? = nil,
                requireLastPushApproval: Swift.Bool? = nil
            ) {
                self.url = url
                self.dismissalRestrictions = dismissalRestrictions
                self.bypassPullRequestAllowances = bypassPullRequestAllowances
                self.dismissStaleReviews = dismissStaleReviews
                self.requireCodeOwnerReviews = requireCodeOwnerReviews
                self.requiredApprovingReviewCount = requiredApprovingReviewCount
                self.requireLastPushApproval = requireLastPushApproval
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case dismissalRestrictions = "dismissal_restrictions"
                case bypassPullRequestAllowances = "bypass_pull_request_allowances"
                case dismissStaleReviews = "dismiss_stale_reviews"
                case requireCodeOwnerReviews = "require_code_owner_reviews"
                case requiredApprovingReviewCount = "required_approving_review_count"
                case requireLastPushApproval = "require_last_push_approval"
            }
        }
        /// Branch Restriction Policy
        ///
        /// - Remark: Generated from `#/components/schemas/branch-restriction-policy`.
        public struct BranchRestrictionPolicy: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/users_url`.
            public var usersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/teams_url`.
            public var teamsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/apps_url`.
            public var appsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload`.
            public struct UsersPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/login`.
                public var login: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/id`.
                public var id: Swift.Int64?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/node_id`.
                public var nodeId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/avatar_url`.
                public var avatarUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/gravatar_id`.
                public var gravatarId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/url`.
                public var url: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/html_url`.
                public var htmlUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/followers_url`.
                public var followersUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/following_url`.
                public var followingUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/gists_url`.
                public var gistsUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/starred_url`.
                public var starredUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/subscriptions_url`.
                public var subscriptionsUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/organizations_url`.
                public var organizationsUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/repos_url`.
                public var reposUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/events_url`.
                public var eventsUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/received_events_url`.
                public var receivedEventsUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/type`.
                public var _type: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/site_admin`.
                public var siteAdmin: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/UsersPayload/user_view_type`.
                public var userViewType: Swift.String?
                /// Creates a new `UsersPayloadPayload`.
                ///
                /// - Parameters:
                ///   - login:
                ///   - id:
                ///   - nodeId:
                ///   - avatarUrl:
                ///   - gravatarId:
                ///   - url:
                ///   - htmlUrl:
                ///   - followersUrl:
                ///   - followingUrl:
                ///   - gistsUrl:
                ///   - starredUrl:
                ///   - subscriptionsUrl:
                ///   - organizationsUrl:
                ///   - reposUrl:
                ///   - eventsUrl:
                ///   - receivedEventsUrl:
                ///   - _type:
                ///   - siteAdmin:
                ///   - userViewType:
                public init(
                    login: Swift.String? = nil,
                    id: Swift.Int64? = nil,
                    nodeId: Swift.String? = nil,
                    avatarUrl: Swift.String? = nil,
                    gravatarId: Swift.String? = nil,
                    url: Swift.String? = nil,
                    htmlUrl: Swift.String? = nil,
                    followersUrl: Swift.String? = nil,
                    followingUrl: Swift.String? = nil,
                    gistsUrl: Swift.String? = nil,
                    starredUrl: Swift.String? = nil,
                    subscriptionsUrl: Swift.String? = nil,
                    organizationsUrl: Swift.String? = nil,
                    reposUrl: Swift.String? = nil,
                    eventsUrl: Swift.String? = nil,
                    receivedEventsUrl: Swift.String? = nil,
                    _type: Swift.String? = nil,
                    siteAdmin: Swift.Bool? = nil,
                    userViewType: Swift.String? = nil
                ) {
                    self.login = login
                    self.id = id
                    self.nodeId = nodeId
                    self.avatarUrl = avatarUrl
                    self.gravatarId = gravatarId
                    self.url = url
                    self.htmlUrl = htmlUrl
                    self.followersUrl = followersUrl
                    self.followingUrl = followingUrl
                    self.gistsUrl = gistsUrl
                    self.starredUrl = starredUrl
                    self.subscriptionsUrl = subscriptionsUrl
                    self.organizationsUrl = organizationsUrl
                    self.reposUrl = reposUrl
                    self.eventsUrl = eventsUrl
                    self.receivedEventsUrl = receivedEventsUrl
                    self._type = _type
                    self.siteAdmin = siteAdmin
                    self.userViewType = userViewType
                }
                public enum CodingKeys: String, CodingKey {
                    case login
                    case id
                    case nodeId = "node_id"
                    case avatarUrl = "avatar_url"
                    case gravatarId = "gravatar_id"
                    case url
                    case htmlUrl = "html_url"
                    case followersUrl = "followers_url"
                    case followingUrl = "following_url"
                    case gistsUrl = "gists_url"
                    case starredUrl = "starred_url"
                    case subscriptionsUrl = "subscriptions_url"
                    case organizationsUrl = "organizations_url"
                    case reposUrl = "repos_url"
                    case eventsUrl = "events_url"
                    case receivedEventsUrl = "received_events_url"
                    case _type = "type"
                    case siteAdmin = "site_admin"
                    case userViewType = "user_view_type"
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/users`.
            public typealias UsersPayload = [Components.Schemas.BranchRestrictionPolicy.UsersPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/users`.
            public var users: Components.Schemas.BranchRestrictionPolicy.UsersPayload
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload`.
            public struct TeamsPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/id`.
                public var id: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/node_id`.
                public var nodeId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/url`.
                public var url: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/html_url`.
                public var htmlUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/name`.
                public var name: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/slug`.
                public var slug: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/description`.
                public var description: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/privacy`.
                public var privacy: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/notification_setting`.
                public var notificationSetting: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/permission`.
                public var permission: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/members_url`.
                public var membersUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/repositories_url`.
                public var repositoriesUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/TeamsPayload/parent`.
                public var parent: Swift.String?
                /// Creates a new `TeamsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - id:
                ///   - nodeId:
                ///   - url:
                ///   - htmlUrl:
                ///   - name:
                ///   - slug:
                ///   - description:
                ///   - privacy:
                ///   - notificationSetting:
                ///   - permission:
                ///   - membersUrl:
                ///   - repositoriesUrl:
                ///   - parent:
                public init(
                    id: Swift.Int? = nil,
                    nodeId: Swift.String? = nil,
                    url: Swift.String? = nil,
                    htmlUrl: Swift.String? = nil,
                    name: Swift.String? = nil,
                    slug: Swift.String? = nil,
                    description: Swift.String? = nil,
                    privacy: Swift.String? = nil,
                    notificationSetting: Swift.String? = nil,
                    permission: Swift.String? = nil,
                    membersUrl: Swift.String? = nil,
                    repositoriesUrl: Swift.String? = nil,
                    parent: Swift.String? = nil
                ) {
                    self.id = id
                    self.nodeId = nodeId
                    self.url = url
                    self.htmlUrl = htmlUrl
                    self.name = name
                    self.slug = slug
                    self.description = description
                    self.privacy = privacy
                    self.notificationSetting = notificationSetting
                    self.permission = permission
                    self.membersUrl = membersUrl
                    self.repositoriesUrl = repositoriesUrl
                    self.parent = parent
                }
                public enum CodingKeys: String, CodingKey {
                    case id
                    case nodeId = "node_id"
                    case url
                    case htmlUrl = "html_url"
                    case name
                    case slug
                    case description
                    case privacy
                    case notificationSetting = "notification_setting"
                    case permission
                    case membersUrl = "members_url"
                    case repositoriesUrl = "repositories_url"
                    case parent
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/teams`.
            public typealias TeamsPayload = [Components.Schemas.BranchRestrictionPolicy.TeamsPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/teams`.
            public var teams: Components.Schemas.BranchRestrictionPolicy.TeamsPayload
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload`.
            public struct AppsPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/id`.
                public var id: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/slug`.
                public var slug: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/node_id`.
                public var nodeId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner`.
                public struct OwnerPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/login`.
                    public var login: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/id`.
                    public var id: Swift.Int?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/node_id`.
                    public var nodeId: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/url`.
                    public var url: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/repos_url`.
                    public var reposUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/events_url`.
                    public var eventsUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/hooks_url`.
                    public var hooksUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/issues_url`.
                    public var issuesUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/members_url`.
                    public var membersUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/public_members_url`.
                    public var publicMembersUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/avatar_url`.
                    public var avatarUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/description`.
                    public var description: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/gravatar_id`.
                    public var gravatarId: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/html_url`.
                    public var htmlUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/followers_url`.
                    public var followersUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/following_url`.
                    public var followingUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/gists_url`.
                    public var gistsUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/starred_url`.
                    public var starredUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/subscriptions_url`.
                    public var subscriptionsUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/organizations_url`.
                    public var organizationsUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/received_events_url`.
                    public var receivedEventsUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/type`.
                    public var _type: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/site_admin`.
                    public var siteAdmin: Swift.Bool?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner/user_view_type`.
                    public var userViewType: Swift.String?
                    /// Creates a new `OwnerPayload`.
                    ///
                    /// - Parameters:
                    ///   - login:
                    ///   - id:
                    ///   - nodeId:
                    ///   - url:
                    ///   - reposUrl:
                    ///   - eventsUrl:
                    ///   - hooksUrl:
                    ///   - issuesUrl:
                    ///   - membersUrl:
                    ///   - publicMembersUrl:
                    ///   - avatarUrl:
                    ///   - description:
                    ///   - gravatarId:
                    ///   - htmlUrl:
                    ///   - followersUrl:
                    ///   - followingUrl:
                    ///   - gistsUrl:
                    ///   - starredUrl:
                    ///   - subscriptionsUrl:
                    ///   - organizationsUrl:
                    ///   - receivedEventsUrl:
                    ///   - _type:
                    ///   - siteAdmin:
                    ///   - userViewType:
                    public init(
                        login: Swift.String? = nil,
                        id: Swift.Int? = nil,
                        nodeId: Swift.String? = nil,
                        url: Swift.String? = nil,
                        reposUrl: Swift.String? = nil,
                        eventsUrl: Swift.String? = nil,
                        hooksUrl: Swift.String? = nil,
                        issuesUrl: Swift.String? = nil,
                        membersUrl: Swift.String? = nil,
                        publicMembersUrl: Swift.String? = nil,
                        avatarUrl: Swift.String? = nil,
                        description: Swift.String? = nil,
                        gravatarId: Swift.String? = nil,
                        htmlUrl: Swift.String? = nil,
                        followersUrl: Swift.String? = nil,
                        followingUrl: Swift.String? = nil,
                        gistsUrl: Swift.String? = nil,
                        starredUrl: Swift.String? = nil,
                        subscriptionsUrl: Swift.String? = nil,
                        organizationsUrl: Swift.String? = nil,
                        receivedEventsUrl: Swift.String? = nil,
                        _type: Swift.String? = nil,
                        siteAdmin: Swift.Bool? = nil,
                        userViewType: Swift.String? = nil
                    ) {
                        self.login = login
                        self.id = id
                        self.nodeId = nodeId
                        self.url = url
                        self.reposUrl = reposUrl
                        self.eventsUrl = eventsUrl
                        self.hooksUrl = hooksUrl
                        self.issuesUrl = issuesUrl
                        self.membersUrl = membersUrl
                        self.publicMembersUrl = publicMembersUrl
                        self.avatarUrl = avatarUrl
                        self.description = description
                        self.gravatarId = gravatarId
                        self.htmlUrl = htmlUrl
                        self.followersUrl = followersUrl
                        self.followingUrl = followingUrl
                        self.gistsUrl = gistsUrl
                        self.starredUrl = starredUrl
                        self.subscriptionsUrl = subscriptionsUrl
                        self.organizationsUrl = organizationsUrl
                        self.receivedEventsUrl = receivedEventsUrl
                        self._type = _type
                        self.siteAdmin = siteAdmin
                        self.userViewType = userViewType
                    }
                    public enum CodingKeys: String, CodingKey {
                        case login
                        case id
                        case nodeId = "node_id"
                        case url
                        case reposUrl = "repos_url"
                        case eventsUrl = "events_url"
                        case hooksUrl = "hooks_url"
                        case issuesUrl = "issues_url"
                        case membersUrl = "members_url"
                        case publicMembersUrl = "public_members_url"
                        case avatarUrl = "avatar_url"
                        case description
                        case gravatarId = "gravatar_id"
                        case htmlUrl = "html_url"
                        case followersUrl = "followers_url"
                        case followingUrl = "following_url"
                        case gistsUrl = "gists_url"
                        case starredUrl = "starred_url"
                        case subscriptionsUrl = "subscriptions_url"
                        case organizationsUrl = "organizations_url"
                        case receivedEventsUrl = "received_events_url"
                        case _type = "type"
                        case siteAdmin = "site_admin"
                        case userViewType = "user_view_type"
                    }
                }
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/owner`.
                public var owner: Components.Schemas.BranchRestrictionPolicy.AppsPayloadPayload.OwnerPayload?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/name`.
                public var name: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/client_id`.
                public var clientId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/description`.
                public var description: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/external_url`.
                public var externalUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/html_url`.
                public var htmlUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/created_at`.
                public var createdAt: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/updated_at`.
                public var updatedAt: Swift.String?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/permissions`.
                public struct PermissionsPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/permissions/metadata`.
                    public var metadata: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/permissions/contents`.
                    public var contents: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/permissions/issues`.
                    public var issues: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/permissions/single_file`.
                    public var singleFile: Swift.String?
                    /// Creates a new `PermissionsPayload`.
                    ///
                    /// - Parameters:
                    ///   - metadata:
                    ///   - contents:
                    ///   - issues:
                    ///   - singleFile:
                    public init(
                        metadata: Swift.String? = nil,
                        contents: Swift.String? = nil,
                        issues: Swift.String? = nil,
                        singleFile: Swift.String? = nil
                    ) {
                        self.metadata = metadata
                        self.contents = contents
                        self.issues = issues
                        self.singleFile = singleFile
                    }
                    public enum CodingKeys: String, CodingKey {
                        case metadata
                        case contents
                        case issues
                        case singleFile = "single_file"
                    }
                }
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/permissions`.
                public var permissions: Components.Schemas.BranchRestrictionPolicy.AppsPayloadPayload.PermissionsPayload?
                /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/AppsPayload/events`.
                public var events: [Swift.String]?
                /// Creates a new `AppsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - id:
                ///   - slug:
                ///   - nodeId:
                ///   - owner:
                ///   - name:
                ///   - clientId:
                ///   - description:
                ///   - externalUrl:
                ///   - htmlUrl:
                ///   - createdAt:
                ///   - updatedAt:
                ///   - permissions:
                ///   - events:
                public init(
                    id: Swift.Int? = nil,
                    slug: Swift.String? = nil,
                    nodeId: Swift.String? = nil,
                    owner: Components.Schemas.BranchRestrictionPolicy.AppsPayloadPayload.OwnerPayload? = nil,
                    name: Swift.String? = nil,
                    clientId: Swift.String? = nil,
                    description: Swift.String? = nil,
                    externalUrl: Swift.String? = nil,
                    htmlUrl: Swift.String? = nil,
                    createdAt: Swift.String? = nil,
                    updatedAt: Swift.String? = nil,
                    permissions: Components.Schemas.BranchRestrictionPolicy.AppsPayloadPayload.PermissionsPayload? = nil,
                    events: [Swift.String]? = nil
                ) {
                    self.id = id
                    self.slug = slug
                    self.nodeId = nodeId
                    self.owner = owner
                    self.name = name
                    self.clientId = clientId
                    self.description = description
                    self.externalUrl = externalUrl
                    self.htmlUrl = htmlUrl
                    self.createdAt = createdAt
                    self.updatedAt = updatedAt
                    self.permissions = permissions
                    self.events = events
                }
                public enum CodingKeys: String, CodingKey {
                    case id
                    case slug
                    case nodeId = "node_id"
                    case owner
                    case name
                    case clientId = "client_id"
                    case description
                    case externalUrl = "external_url"
                    case htmlUrl = "html_url"
                    case createdAt = "created_at"
                    case updatedAt = "updated_at"
                    case permissions
                    case events
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/apps`.
            public typealias AppsPayload = [Components.Schemas.BranchRestrictionPolicy.AppsPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/branch-restriction-policy/apps`.
            public var apps: Components.Schemas.BranchRestrictionPolicy.AppsPayload
            /// Creates a new `BranchRestrictionPolicy`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - usersUrl:
            ///   - teamsUrl:
            ///   - appsUrl:
            ///   - users:
            ///   - teams:
            ///   - apps:
            public init(
                url: Swift.String,
                usersUrl: Swift.String,
                teamsUrl: Swift.String,
                appsUrl: Swift.String,
                users: Components.Schemas.BranchRestrictionPolicy.UsersPayload,
                teams: Components.Schemas.BranchRestrictionPolicy.TeamsPayload,
                apps: Components.Schemas.BranchRestrictionPolicy.AppsPayload
            ) {
                self.url = url
                self.usersUrl = usersUrl
                self.teamsUrl = teamsUrl
                self.appsUrl = appsUrl
                self.users = users
                self.teams = teams
                self.apps = apps
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case usersUrl = "users_url"
                case teamsUrl = "teams_url"
                case appsUrl = "apps_url"
                case users
                case teams
                case apps
            }
        }
        /// Branch Protection
        ///
        /// - Remark: Generated from `#/components/schemas/branch-protection`.
        public struct BranchProtection: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/branch-protection/url`.
            public var url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/branch-protection/enabled`.
            public var enabled: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_status_checks`.
            public var requiredStatusChecks: Components.Schemas.ProtectedBranchRequiredStatusCheck?
            /// - Remark: Generated from `#/components/schemas/branch-protection/enforce_admins`.
            public var enforceAdmins: Components.Schemas.ProtectedBranchAdminEnforced?
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_pull_request_reviews`.
            public var requiredPullRequestReviews: Components.Schemas.ProtectedBranchPullRequestReview?
            /// - Remark: Generated from `#/components/schemas/branch-protection/restrictions`.
            public var restrictions: Components.Schemas.BranchRestrictionPolicy?
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_linear_history`.
            public struct RequiredLinearHistoryPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/required_linear_history/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `RequiredLinearHistoryPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_linear_history`.
            public var requiredLinearHistory: Components.Schemas.BranchProtection.RequiredLinearHistoryPayload?
            /// - Remark: Generated from `#/components/schemas/branch-protection/allow_force_pushes`.
            public struct AllowForcePushesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/allow_force_pushes/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `AllowForcePushesPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-protection/allow_force_pushes`.
            public var allowForcePushes: Components.Schemas.BranchProtection.AllowForcePushesPayload?
            /// - Remark: Generated from `#/components/schemas/branch-protection/allow_deletions`.
            public struct AllowDeletionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/allow_deletions/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `AllowDeletionsPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-protection/allow_deletions`.
            public var allowDeletions: Components.Schemas.BranchProtection.AllowDeletionsPayload?
            /// - Remark: Generated from `#/components/schemas/branch-protection/block_creations`.
            public struct BlockCreationsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/block_creations/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `BlockCreationsPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-protection/block_creations`.
            public var blockCreations: Components.Schemas.BranchProtection.BlockCreationsPayload?
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_conversation_resolution`.
            public struct RequiredConversationResolutionPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/required_conversation_resolution/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `RequiredConversationResolutionPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_conversation_resolution`.
            public var requiredConversationResolution: Components.Schemas.BranchProtection.RequiredConversationResolutionPayload?
            /// - Remark: Generated from `#/components/schemas/branch-protection/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/branch-protection/protection_url`.
            public var protectionUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_signatures`.
            public struct RequiredSignaturesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/required_signatures/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/branch-protection/required_signatures/enabled`.
                public var enabled: Swift.Bool
                /// Creates a new `RequiredSignaturesPayload`.
                ///
                /// - Parameters:
                ///   - url:
                ///   - enabled:
                public init(
                    url: Swift.String,
                    enabled: Swift.Bool
                ) {
                    self.url = url
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case url
                    case enabled
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-protection/required_signatures`.
            public var requiredSignatures: Components.Schemas.BranchProtection.RequiredSignaturesPayload?
            /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
            ///
            /// - Remark: Generated from `#/components/schemas/branch-protection/lock_branch`.
            public struct LockBranchPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/lock_branch/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `LockBranchPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
            }
            /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
            ///
            /// - Remark: Generated from `#/components/schemas/branch-protection/lock_branch`.
            public var lockBranch: Components.Schemas.BranchProtection.LockBranchPayload?
            /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
            ///
            /// - Remark: Generated from `#/components/schemas/branch-protection/allow_fork_syncing`.
            public struct AllowForkSyncingPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-protection/allow_fork_syncing/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `AllowForkSyncingPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
            }
            /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
            ///
            /// - Remark: Generated from `#/components/schemas/branch-protection/allow_fork_syncing`.
            public var allowForkSyncing: Components.Schemas.BranchProtection.AllowForkSyncingPayload?
            /// Creates a new `BranchProtection`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - enabled:
            ///   - requiredStatusChecks:
            ///   - enforceAdmins:
            ///   - requiredPullRequestReviews:
            ///   - restrictions:
            ///   - requiredLinearHistory:
            ///   - allowForcePushes:
            ///   - allowDeletions:
            ///   - blockCreations:
            ///   - requiredConversationResolution:
            ///   - name:
            ///   - protectionUrl:
            ///   - requiredSignatures:
            ///   - lockBranch: Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
            ///   - allowForkSyncing: Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
            public init(
                url: Swift.String? = nil,
                enabled: Swift.Bool? = nil,
                requiredStatusChecks: Components.Schemas.ProtectedBranchRequiredStatusCheck? = nil,
                enforceAdmins: Components.Schemas.ProtectedBranchAdminEnforced? = nil,
                requiredPullRequestReviews: Components.Schemas.ProtectedBranchPullRequestReview? = nil,
                restrictions: Components.Schemas.BranchRestrictionPolicy? = nil,
                requiredLinearHistory: Components.Schemas.BranchProtection.RequiredLinearHistoryPayload? = nil,
                allowForcePushes: Components.Schemas.BranchProtection.AllowForcePushesPayload? = nil,
                allowDeletions: Components.Schemas.BranchProtection.AllowDeletionsPayload? = nil,
                blockCreations: Components.Schemas.BranchProtection.BlockCreationsPayload? = nil,
                requiredConversationResolution: Components.Schemas.BranchProtection.RequiredConversationResolutionPayload? = nil,
                name: Swift.String? = nil,
                protectionUrl: Swift.String? = nil,
                requiredSignatures: Components.Schemas.BranchProtection.RequiredSignaturesPayload? = nil,
                lockBranch: Components.Schemas.BranchProtection.LockBranchPayload? = nil,
                allowForkSyncing: Components.Schemas.BranchProtection.AllowForkSyncingPayload? = nil
            ) {
                self.url = url
                self.enabled = enabled
                self.requiredStatusChecks = requiredStatusChecks
                self.enforceAdmins = enforceAdmins
                self.requiredPullRequestReviews = requiredPullRequestReviews
                self.restrictions = restrictions
                self.requiredLinearHistory = requiredLinearHistory
                self.allowForcePushes = allowForcePushes
                self.allowDeletions = allowDeletions
                self.blockCreations = blockCreations
                self.requiredConversationResolution = requiredConversationResolution
                self.name = name
                self.protectionUrl = protectionUrl
                self.requiredSignatures = requiredSignatures
                self.lockBranch = lockBranch
                self.allowForkSyncing = allowForkSyncing
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case enabled
                case requiredStatusChecks = "required_status_checks"
                case enforceAdmins = "enforce_admins"
                case requiredPullRequestReviews = "required_pull_request_reviews"
                case restrictions
                case requiredLinearHistory = "required_linear_history"
                case allowForcePushes = "allow_force_pushes"
                case allowDeletions = "allow_deletions"
                case blockCreations = "block_creations"
                case requiredConversationResolution = "required_conversation_resolution"
                case name
                case protectionUrl = "protection_url"
                case requiredSignatures = "required_signatures"
                case lockBranch = "lock_branch"
                case allowForkSyncing = "allow_fork_syncing"
            }
        }
        /// Short Branch
        ///
        /// - Remark: Generated from `#/components/schemas/short-branch`.
        public struct ShortBranch: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/short-branch/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/short-branch/commit`.
            public struct CommitPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/short-branch/commit/sha`.
                public var sha: Swift.String
                /// - Remark: Generated from `#/components/schemas/short-branch/commit/url`.
                public var url: Swift.String
                /// Creates a new `CommitPayload`.
                ///
                /// - Parameters:
                ///   - sha:
                ///   - url:
                public init(
                    sha: Swift.String,
                    url: Swift.String
                ) {
                    self.sha = sha
                    self.url = url
                }
                public enum CodingKeys: String, CodingKey {
                    case sha
                    case url
                }
            }
            /// - Remark: Generated from `#/components/schemas/short-branch/commit`.
            public var commit: Components.Schemas.ShortBranch.CommitPayload
            /// - Remark: Generated from `#/components/schemas/short-branch/protected`.
            public var protected: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/short-branch/protection`.
            public var protection: Components.Schemas.BranchProtection?
            /// - Remark: Generated from `#/components/schemas/short-branch/protection_url`.
            public var protectionUrl: Swift.String?
            /// Creates a new `ShortBranch`.
            ///
            /// - Parameters:
            ///   - name:
            ///   - commit:
            ///   - protected:
            ///   - protection:
            ///   - protectionUrl:
            public init(
                name: Swift.String,
                commit: Components.Schemas.ShortBranch.CommitPayload,
                protected: Swift.Bool,
                protection: Components.Schemas.BranchProtection? = nil,
                protectionUrl: Swift.String? = nil
            ) {
                self.name = name
                self.commit = commit
                self.protected = protected
                self.protection = protection
                self.protectionUrl = protectionUrl
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case commit
                case protected
                case protection
                case protectionUrl = "protection_url"
            }
        }
        /// Metaproperties for Git author/committer information.
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-git-user`.
        public struct NullableGitUser: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/nullable-git-user/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-git-user/email`.
            public var email: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-git-user/date`.
            public var date: Swift.String?
            /// Creates a new `NullableGitUser`.
            ///
            /// - Parameters:
            ///   - name:
            ///   - email:
            ///   - date:
            public init(
                name: Swift.String? = nil,
                email: Swift.String? = nil,
                date: Swift.String? = nil
            ) {
                self.name = name
                self.email = email
                self.date = date
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case email
                case date
            }
        }
        /// - Remark: Generated from `#/components/schemas/verification`.
        public struct Verification: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/verification/verified`.
            public var verified: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/verification/reason`.
            public var reason: Swift.String
            /// - Remark: Generated from `#/components/schemas/verification/payload`.
            public var payload: Swift.String?
            /// - Remark: Generated from `#/components/schemas/verification/signature`.
            public var signature: Swift.String?
            /// - Remark: Generated from `#/components/schemas/verification/verified_at`.
            public var verifiedAt: Swift.String?
            /// Creates a new `Verification`.
            ///
            /// - Parameters:
            ///   - verified:
            ///   - reason:
            ///   - payload:
            ///   - signature:
            ///   - verifiedAt:
            public init(
                verified: Swift.Bool,
                reason: Swift.String,
                payload: Swift.String? = nil,
                signature: Swift.String? = nil,
                verifiedAt: Swift.String? = nil
            ) {
                self.verified = verified
                self.reason = reason
                self.payload = payload
                self.signature = signature
                self.verifiedAt = verifiedAt
            }
            public enum CodingKeys: String, CodingKey {
                case verified
                case reason
                case payload
                case signature
                case verifiedAt = "verified_at"
            }
        }
        /// Diff Entry
        ///
        /// - Remark: Generated from `#/components/schemas/diff-entry`.
        public struct DiffEntry: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/diff-entry/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/diff-entry/filename`.
            public var filename: Swift.String
            /// - Remark: Generated from `#/components/schemas/diff-entry/status`.
            @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case added = "added"
                case removed = "removed"
                case modified = "modified"
                case renamed = "renamed"
                case copied = "copied"
                case changed = "changed"
                case unchanged = "unchanged"
            }
            /// - Remark: Generated from `#/components/schemas/diff-entry/status`.
            public var status: Components.Schemas.DiffEntry.StatusPayload
            /// - Remark: Generated from `#/components/schemas/diff-entry/additions`.
            public var additions: Swift.Int
            /// - Remark: Generated from `#/components/schemas/diff-entry/deletions`.
            public var deletions: Swift.Int
            /// - Remark: Generated from `#/components/schemas/diff-entry/changes`.
            public var changes: Swift.Int
            /// - Remark: Generated from `#/components/schemas/diff-entry/blob_url`.
            public var blobUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/diff-entry/raw_url`.
            public var rawUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/diff-entry/contents_url`.
            public var contentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/diff-entry/patch`.
            public var patch: Swift.String?
            /// - Remark: Generated from `#/components/schemas/diff-entry/previous_filename`.
            public var previousFilename: Swift.String?
            /// Creates a new `DiffEntry`.
            ///
            /// - Parameters:
            ///   - sha:
            ///   - filename:
            ///   - status:
            ///   - additions:
            ///   - deletions:
            ///   - changes:
            ///   - blobUrl:
            ///   - rawUrl:
            ///   - contentsUrl:
            ///   - patch:
            ///   - previousFilename:
            public init(
                sha: Swift.String,
                filename: Swift.String,
                status: Components.Schemas.DiffEntry.StatusPayload,
                additions: Swift.Int,
                deletions: Swift.Int,
                changes: Swift.Int,
                blobUrl: Swift.String,
                rawUrl: Swift.String,
                contentsUrl: Swift.String,
                patch: Swift.String? = nil,
                previousFilename: Swift.String? = nil
            ) {
                self.sha = sha
                self.filename = filename
                self.status = status
                self.additions = additions
                self.deletions = deletions
                self.changes = changes
                self.blobUrl = blobUrl
                self.rawUrl = rawUrl
                self.contentsUrl = contentsUrl
                self.patch = patch
                self.previousFilename = previousFilename
            }
            public enum CodingKeys: String, CodingKey {
                case sha
                case filename
                case status
                case additions
                case deletions
                case changes
                case blobUrl = "blob_url"
                case rawUrl = "raw_url"
                case contentsUrl = "contents_url"
                case patch
                case previousFilename = "previous_filename"
            }
        }
        /// Commit
        ///
        /// - Remark: Generated from `#/components/schemas/commit`.
        public struct Commit: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/commit/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit/comments_url`.
            public var commentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit/commit`.
            public struct CommitPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/commit/commit/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/commit/commit/author`.
                public var author: Components.Schemas.NullableGitUser?
                /// - Remark: Generated from `#/components/schemas/commit/commit/committer`.
                public var committer: Components.Schemas.NullableGitUser?
                /// - Remark: Generated from `#/components/schemas/commit/commit/message`.
                public var message: Swift.String
                /// - Remark: Generated from `#/components/schemas/commit/commit/comment_count`.
                public var commentCount: Swift.Int
                /// - Remark: Generated from `#/components/schemas/commit/commit/tree`.
                public struct TreePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/commit/commit/tree/sha`.
                    public var sha: Swift.String
                    /// - Remark: Generated from `#/components/schemas/commit/commit/tree/url`.
                    public var url: Swift.String
                    /// Creates a new `TreePayload`.
                    ///
                    /// - Parameters:
                    ///   - sha:
                    ///   - url:
                    public init(
                        sha: Swift.String,
                        url: Swift.String
                    ) {
                        self.sha = sha
                        self.url = url
                    }
                    public enum CodingKeys: String, CodingKey {
                        case sha
                        case url
                    }
                }
                /// - Remark: Generated from `#/components/schemas/commit/commit/tree`.
                public var tree: Components.Schemas.Commit.CommitPayload.TreePayload
                /// - Remark: Generated from `#/components/schemas/commit/commit/verification`.
                public var verification: Components.Schemas.Verification?
                /// Creates a new `CommitPayload`.
                ///
                /// - Parameters:
                ///   - url:
                ///   - author:
                ///   - committer:
                ///   - message:
                ///   - commentCount:
                ///   - tree:
                ///   - verification:
                public init(
                    url: Swift.String,
                    author: Components.Schemas.NullableGitUser? = nil,
                    committer: Components.Schemas.NullableGitUser? = nil,
                    message: Swift.String,
                    commentCount: Swift.Int,
                    tree: Components.Schemas.Commit.CommitPayload.TreePayload,
                    verification: Components.Schemas.Verification? = nil
                ) {
                    self.url = url
                    self.author = author
                    self.committer = committer
                    self.message = message
                    self.commentCount = commentCount
                    self.tree = tree
                    self.verification = verification
                }
                public enum CodingKeys: String, CodingKey {
                    case url
                    case author
                    case committer
                    case message
                    case commentCount = "comment_count"
                    case tree
                    case verification
                }
            }
            /// - Remark: Generated from `#/components/schemas/commit/commit`.
            public var commit: Components.Schemas.Commit.CommitPayload
            /// - Remark: Generated from `#/components/schemas/commit/author`.
            @frozen public enum AuthorPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/commit/author/case1`.
                case SimpleUser(Components.Schemas.SimpleUser)
                /// - Remark: Generated from `#/components/schemas/commit/author/case2`.
                case EmptyObject(Components.Schemas.EmptyObject)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .SimpleUser(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .EmptyObject(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .SimpleUser(value):
                        try value.encode(to: encoder)
                    case let .EmptyObject(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// - Remark: Generated from `#/components/schemas/commit/author`.
            public var author: Components.Schemas.Commit.AuthorPayload?
            /// - Remark: Generated from `#/components/schemas/commit/committer`.
            @frozen public enum CommitterPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/commit/committer/case1`.
                case SimpleUser(Components.Schemas.SimpleUser)
                /// - Remark: Generated from `#/components/schemas/commit/committer/case2`.
                case EmptyObject(Components.Schemas.EmptyObject)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .SimpleUser(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .EmptyObject(try .init(from: decoder))
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .SimpleUser(value):
                        try value.encode(to: encoder)
                    case let .EmptyObject(value):
                        try value.encode(to: encoder)
                    }
                }
            }
            /// - Remark: Generated from `#/components/schemas/commit/committer`.
            public var committer: Components.Schemas.Commit.CommitterPayload?
            /// - Remark: Generated from `#/components/schemas/commit/ParentsPayload`.
            public struct ParentsPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/commit/ParentsPayload/sha`.
                public var sha: Swift.String
                /// - Remark: Generated from `#/components/schemas/commit/ParentsPayload/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/commit/ParentsPayload/html_url`.
                public var htmlUrl: Swift.String?
                /// Creates a new `ParentsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - sha:
                ///   - url:
                ///   - htmlUrl:
                public init(
                    sha: Swift.String,
                    url: Swift.String,
                    htmlUrl: Swift.String? = nil
                ) {
                    self.sha = sha
                    self.url = url
                    self.htmlUrl = htmlUrl
                }
                public enum CodingKeys: String, CodingKey {
                    case sha
                    case url
                    case htmlUrl = "html_url"
                }
            }
            /// - Remark: Generated from `#/components/schemas/commit/parents`.
            public typealias ParentsPayload = [Components.Schemas.Commit.ParentsPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/commit/parents`.
            public var parents: Components.Schemas.Commit.ParentsPayload
            /// - Remark: Generated from `#/components/schemas/commit/stats`.
            public struct StatsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/commit/stats/additions`.
                public var additions: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/commit/stats/deletions`.
                public var deletions: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/commit/stats/total`.
                public var total: Swift.Int?
                /// Creates a new `StatsPayload`.
                ///
                /// - Parameters:
                ///   - additions:
                ///   - deletions:
                ///   - total:
                public init(
                    additions: Swift.Int? = nil,
                    deletions: Swift.Int? = nil,
                    total: Swift.Int? = nil
                ) {
                    self.additions = additions
                    self.deletions = deletions
                    self.total = total
                }
                public enum CodingKeys: String, CodingKey {
                    case additions
                    case deletions
                    case total
                }
            }
            /// - Remark: Generated from `#/components/schemas/commit/stats`.
            public var stats: Components.Schemas.Commit.StatsPayload?
            /// - Remark: Generated from `#/components/schemas/commit/files`.
            public var files: [Components.Schemas.DiffEntry]?
            /// Creates a new `Commit`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - sha:
            ///   - nodeId:
            ///   - htmlUrl:
            ///   - commentsUrl:
            ///   - commit:
            ///   - author:
            ///   - committer:
            ///   - parents:
            ///   - stats:
            ///   - files:
            public init(
                url: Swift.String,
                sha: Swift.String,
                nodeId: Swift.String,
                htmlUrl: Swift.String,
                commentsUrl: Swift.String,
                commit: Components.Schemas.Commit.CommitPayload,
                author: Components.Schemas.Commit.AuthorPayload? = nil,
                committer: Components.Schemas.Commit.CommitterPayload? = nil,
                parents: Components.Schemas.Commit.ParentsPayload,
                stats: Components.Schemas.Commit.StatsPayload? = nil,
                files: [Components.Schemas.DiffEntry]? = nil
            ) {
                self.url = url
                self.sha = sha
                self.nodeId = nodeId
                self.htmlUrl = htmlUrl
                self.commentsUrl = commentsUrl
                self.commit = commit
                self.author = author
                self.committer = committer
                self.parents = parents
                self.stats = stats
                self.files = files
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case sha
                case nodeId = "node_id"
                case htmlUrl = "html_url"
                case commentsUrl = "comments_url"
                case commit
                case author
                case committer
                case parents
                case stats
                case files
            }
        }
        /// Branch With Protection
        ///
        /// - Remark: Generated from `#/components/schemas/branch-with-protection`.
        public struct BranchWithProtection: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/commit`.
            public var commit: Components.Schemas.Commit
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-with-protection/_links/html`.
                public var html: Swift.String
                /// - Remark: Generated from `#/components/schemas/branch-with-protection/_links/self`.
                public var _self: Swift.String
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - html:
                ///   - _self:
                public init(
                    html: Swift.String,
                    _self: Swift.String
                ) {
                    self.html = html
                    self._self = _self
                }
                public enum CodingKeys: String, CodingKey {
                    case html
                    case _self = "self"
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/_links`.
            public var _links: Components.Schemas.BranchWithProtection._LinksPayload
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/protected`.
            public var protected: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/protection`.
            public var protection: Components.Schemas.BranchProtection
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/protection_url`.
            public var protectionUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/pattern`.
            public var pattern: Swift.String?
            /// - Remark: Generated from `#/components/schemas/branch-with-protection/required_approving_review_count`.
            public var requiredApprovingReviewCount: Swift.Int?
            /// Creates a new `BranchWithProtection`.
            ///
            /// - Parameters:
            ///   - name:
            ///   - commit:
            ///   - _links:
            ///   - protected:
            ///   - protection:
            ///   - protectionUrl:
            ///   - pattern:
            ///   - requiredApprovingReviewCount:
            public init(
                name: Swift.String,
                commit: Components.Schemas.Commit,
                _links: Components.Schemas.BranchWithProtection._LinksPayload,
                protected: Swift.Bool,
                protection: Components.Schemas.BranchProtection,
                protectionUrl: Swift.String,
                pattern: Swift.String? = nil,
                requiredApprovingReviewCount: Swift.Int? = nil
            ) {
                self.name = name
                self.commit = commit
                self._links = _links
                self.protected = protected
                self.protection = protection
                self.protectionUrl = protectionUrl
                self.pattern = pattern
                self.requiredApprovingReviewCount = requiredApprovingReviewCount
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case commit
                case _links
                case protected
                case protection
                case protectionUrl = "protection_url"
                case pattern
                case requiredApprovingReviewCount = "required_approving_review_count"
            }
        }
        /// Status Check Policy
        ///
        /// - Remark: Generated from `#/components/schemas/status-check-policy`.
        public struct StatusCheckPolicy: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/status-check-policy/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/status-check-policy/strict`.
            public var strict: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/status-check-policy/contexts`.
            public var contexts: [Swift.String]
            /// - Remark: Generated from `#/components/schemas/status-check-policy/ChecksPayload`.
            public struct ChecksPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/status-check-policy/ChecksPayload/context`.
                public var context: Swift.String
                /// - Remark: Generated from `#/components/schemas/status-check-policy/ChecksPayload/app_id`.
                public var appId: Swift.Int?
                /// Creates a new `ChecksPayloadPayload`.
                ///
                /// - Parameters:
                ///   - context:
                ///   - appId:
                public init(
                    context: Swift.String,
                    appId: Swift.Int? = nil
                ) {
                    self.context = context
                    self.appId = appId
                }
                public enum CodingKeys: String, CodingKey {
                    case context
                    case appId = "app_id"
                }
            }
            /// - Remark: Generated from `#/components/schemas/status-check-policy/checks`.
            public typealias ChecksPayload = [Components.Schemas.StatusCheckPolicy.ChecksPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/status-check-policy/checks`.
            public var checks: Components.Schemas.StatusCheckPolicy.ChecksPayload
            /// - Remark: Generated from `#/components/schemas/status-check-policy/contexts_url`.
            public var contextsUrl: Swift.String
            /// Creates a new `StatusCheckPolicy`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - strict:
            ///   - contexts:
            ///   - checks:
            ///   - contextsUrl:
            public init(
                url: Swift.String,
                strict: Swift.Bool,
                contexts: [Swift.String],
                checks: Components.Schemas.StatusCheckPolicy.ChecksPayload,
                contextsUrl: Swift.String
            ) {
                self.url = url
                self.strict = strict
                self.contexts = contexts
                self.checks = checks
                self.contextsUrl = contextsUrl
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case strict
                case contexts
                case checks
                case contextsUrl = "contexts_url"
            }
        }
        /// Branch protections protect branches
        ///
        /// - Remark: Generated from `#/components/schemas/protected-branch`.
        public struct ProtectedBranch: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/protected-branch/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_status_checks`.
            public var requiredStatusChecks: Components.Schemas.StatusCheckPolicy?
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews`.
            public struct RequiredPullRequestReviewsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismiss_stale_reviews`.
                public var dismissStaleReviews: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/require_code_owner_reviews`.
                public var requireCodeOwnerReviews: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/required_approving_review_count`.
                public var requiredApprovingReviewCount: Swift.Int?
                /// Whether the most recent push must be approved by someone other than the person who pushed it.
                ///
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/require_last_push_approval`.
                public var requireLastPushApproval: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions`.
                public struct DismissalRestrictionsPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions/url`.
                    public var url: Swift.String
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions/users_url`.
                    public var usersUrl: Swift.String
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions/teams_url`.
                    public var teamsUrl: Swift.String
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions/users`.
                    public var users: [Components.Schemas.SimpleUser]
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions/teams`.
                    public var teams: [Components.Schemas.Team]
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions/apps`.
                    public var apps: [Components.Schemas.Integration]?
                    /// Creates a new `DismissalRestrictionsPayload`.
                    ///
                    /// - Parameters:
                    ///   - url:
                    ///   - usersUrl:
                    ///   - teamsUrl:
                    ///   - users:
                    ///   - teams:
                    ///   - apps:
                    public init(
                        url: Swift.String,
                        usersUrl: Swift.String,
                        teamsUrl: Swift.String,
                        users: [Components.Schemas.SimpleUser],
                        teams: [Components.Schemas.Team],
                        apps: [Components.Schemas.Integration]? = nil
                    ) {
                        self.url = url
                        self.usersUrl = usersUrl
                        self.teamsUrl = teamsUrl
                        self.users = users
                        self.teams = teams
                        self.apps = apps
                    }
                    public enum CodingKeys: String, CodingKey {
                        case url
                        case usersUrl = "users_url"
                        case teamsUrl = "teams_url"
                        case users
                        case teams
                        case apps
                    }
                }
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/dismissal_restrictions`.
                public var dismissalRestrictions: Components.Schemas.ProtectedBranch.RequiredPullRequestReviewsPayload.DismissalRestrictionsPayload?
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/bypass_pull_request_allowances`.
                public struct BypassPullRequestAllowancesPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/bypass_pull_request_allowances/users`.
                    public var users: [Components.Schemas.SimpleUser]
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/bypass_pull_request_allowances/teams`.
                    public var teams: [Components.Schemas.Team]
                    /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/bypass_pull_request_allowances/apps`.
                    public var apps: [Components.Schemas.Integration]?
                    /// Creates a new `BypassPullRequestAllowancesPayload`.
                    ///
                    /// - Parameters:
                    ///   - users:
                    ///   - teams:
                    ///   - apps:
                    public init(
                        users: [Components.Schemas.SimpleUser],
                        teams: [Components.Schemas.Team],
                        apps: [Components.Schemas.Integration]? = nil
                    ) {
                        self.users = users
                        self.teams = teams
                        self.apps = apps
                    }
                    public enum CodingKeys: String, CodingKey {
                        case users
                        case teams
                        case apps
                    }
                }
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews/bypass_pull_request_allowances`.
                public var bypassPullRequestAllowances: Components.Schemas.ProtectedBranch.RequiredPullRequestReviewsPayload.BypassPullRequestAllowancesPayload?
                /// Creates a new `RequiredPullRequestReviewsPayload`.
                ///
                /// - Parameters:
                ///   - url:
                ///   - dismissStaleReviews:
                ///   - requireCodeOwnerReviews:
                ///   - requiredApprovingReviewCount:
                ///   - requireLastPushApproval: Whether the most recent push must be approved by someone other than the person who pushed it.
                ///   - dismissalRestrictions:
                ///   - bypassPullRequestAllowances:
                public init(
                    url: Swift.String,
                    dismissStaleReviews: Swift.Bool? = nil,
                    requireCodeOwnerReviews: Swift.Bool? = nil,
                    requiredApprovingReviewCount: Swift.Int? = nil,
                    requireLastPushApproval: Swift.Bool? = nil,
                    dismissalRestrictions: Components.Schemas.ProtectedBranch.RequiredPullRequestReviewsPayload.DismissalRestrictionsPayload? = nil,
                    bypassPullRequestAllowances: Components.Schemas.ProtectedBranch.RequiredPullRequestReviewsPayload.BypassPullRequestAllowancesPayload? = nil
                ) {
                    self.url = url
                    self.dismissStaleReviews = dismissStaleReviews
                    self.requireCodeOwnerReviews = requireCodeOwnerReviews
                    self.requiredApprovingReviewCount = requiredApprovingReviewCount
                    self.requireLastPushApproval = requireLastPushApproval
                    self.dismissalRestrictions = dismissalRestrictions
                    self.bypassPullRequestAllowances = bypassPullRequestAllowances
                }
                public enum CodingKeys: String, CodingKey {
                    case url
                    case dismissStaleReviews = "dismiss_stale_reviews"
                    case requireCodeOwnerReviews = "require_code_owner_reviews"
                    case requiredApprovingReviewCount = "required_approving_review_count"
                    case requireLastPushApproval = "require_last_push_approval"
                    case dismissalRestrictions = "dismissal_restrictions"
                    case bypassPullRequestAllowances = "bypass_pull_request_allowances"
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_pull_request_reviews`.
            public var requiredPullRequestReviews: Components.Schemas.ProtectedBranch.RequiredPullRequestReviewsPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_signatures`.
            public struct RequiredSignaturesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_signatures/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_signatures/enabled`.
                public var enabled: Swift.Bool
                /// Creates a new `RequiredSignaturesPayload`.
                ///
                /// - Parameters:
                ///   - url:
                ///   - enabled:
                public init(
                    url: Swift.String,
                    enabled: Swift.Bool
                ) {
                    self.url = url
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case url
                    case enabled
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_signatures`.
            public var requiredSignatures: Components.Schemas.ProtectedBranch.RequiredSignaturesPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch/enforce_admins`.
            public struct EnforceAdminsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/enforce_admins/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/protected-branch/enforce_admins/enabled`.
                public var enabled: Swift.Bool
                /// Creates a new `EnforceAdminsPayload`.
                ///
                /// - Parameters:
                ///   - url:
                ///   - enabled:
                public init(
                    url: Swift.String,
                    enabled: Swift.Bool
                ) {
                    self.url = url
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case url
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.url = try container.decode(
                        Swift.String.self,
                        forKey: .url
                    )
                    self.enabled = try container.decode(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "url",
                        "enabled"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/enforce_admins`.
            public var enforceAdmins: Components.Schemas.ProtectedBranch.EnforceAdminsPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_linear_history`.
            public struct RequiredLinearHistoryPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_linear_history/enabled`.
                public var enabled: Swift.Bool
                /// Creates a new `RequiredLinearHistoryPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.enabled = try container.decode(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "enabled"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_linear_history`.
            public var requiredLinearHistory: Components.Schemas.ProtectedBranch.RequiredLinearHistoryPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch/allow_force_pushes`.
            public struct AllowForcePushesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/allow_force_pushes/enabled`.
                public var enabled: Swift.Bool
                /// Creates a new `AllowForcePushesPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.enabled = try container.decode(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "enabled"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/allow_force_pushes`.
            public var allowForcePushes: Components.Schemas.ProtectedBranch.AllowForcePushesPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch/allow_deletions`.
            public struct AllowDeletionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/allow_deletions/enabled`.
                public var enabled: Swift.Bool
                /// Creates a new `AllowDeletionsPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.enabled = try container.decode(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "enabled"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/allow_deletions`.
            public var allowDeletions: Components.Schemas.ProtectedBranch.AllowDeletionsPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch/restrictions`.
            public var restrictions: Components.Schemas.BranchRestrictionPolicy?
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_conversation_resolution`.
            public struct RequiredConversationResolutionPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/required_conversation_resolution/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `RequiredConversationResolutionPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.enabled = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "enabled"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/required_conversation_resolution`.
            public var requiredConversationResolution: Components.Schemas.ProtectedBranch.RequiredConversationResolutionPayload?
            /// - Remark: Generated from `#/components/schemas/protected-branch/block_creations`.
            public struct BlockCreationsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/block_creations/enabled`.
                public var enabled: Swift.Bool
                /// Creates a new `BlockCreationsPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.enabled = try container.decode(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "enabled"
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/protected-branch/block_creations`.
            public var blockCreations: Components.Schemas.ProtectedBranch.BlockCreationsPayload?
            /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
            ///
            /// - Remark: Generated from `#/components/schemas/protected-branch/lock_branch`.
            public struct LockBranchPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/lock_branch/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `LockBranchPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.enabled = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "enabled"
                    ])
                }
            }
            /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
            ///
            /// - Remark: Generated from `#/components/schemas/protected-branch/lock_branch`.
            public var lockBranch: Components.Schemas.ProtectedBranch.LockBranchPayload?
            /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
            ///
            /// - Remark: Generated from `#/components/schemas/protected-branch/allow_fork_syncing`.
            public struct AllowForkSyncingPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/protected-branch/allow_fork_syncing/enabled`.
                public var enabled: Swift.Bool?
                /// Creates a new `AllowForkSyncingPayload`.
                ///
                /// - Parameters:
                ///   - enabled:
                public init(enabled: Swift.Bool? = nil) {
                    self.enabled = enabled
                }
                public enum CodingKeys: String, CodingKey {
                    case enabled
                }
                public init(from decoder: any Decoder) throws {
                    let container = try decoder.container(keyedBy: CodingKeys.self)
                    self.enabled = try container.decodeIfPresent(
                        Swift.Bool.self,
                        forKey: .enabled
                    )
                    try decoder.ensureNoAdditionalProperties(knownKeys: [
                        "enabled"
                    ])
                }
            }
            /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
            ///
            /// - Remark: Generated from `#/components/schemas/protected-branch/allow_fork_syncing`.
            public var allowForkSyncing: Components.Schemas.ProtectedBranch.AllowForkSyncingPayload?
            /// Creates a new `ProtectedBranch`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - requiredStatusChecks:
            ///   - requiredPullRequestReviews:
            ///   - requiredSignatures:
            ///   - enforceAdmins:
            ///   - requiredLinearHistory:
            ///   - allowForcePushes:
            ///   - allowDeletions:
            ///   - restrictions:
            ///   - requiredConversationResolution:
            ///   - blockCreations:
            ///   - lockBranch: Whether to set the branch as read-only. If this is true, users will not be able to push to the branch.
            ///   - allowForkSyncing: Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing.
            public init(
                url: Swift.String,
                requiredStatusChecks: Components.Schemas.StatusCheckPolicy? = nil,
                requiredPullRequestReviews: Components.Schemas.ProtectedBranch.RequiredPullRequestReviewsPayload? = nil,
                requiredSignatures: Components.Schemas.ProtectedBranch.RequiredSignaturesPayload? = nil,
                enforceAdmins: Components.Schemas.ProtectedBranch.EnforceAdminsPayload? = nil,
                requiredLinearHistory: Components.Schemas.ProtectedBranch.RequiredLinearHistoryPayload? = nil,
                allowForcePushes: Components.Schemas.ProtectedBranch.AllowForcePushesPayload? = nil,
                allowDeletions: Components.Schemas.ProtectedBranch.AllowDeletionsPayload? = nil,
                restrictions: Components.Schemas.BranchRestrictionPolicy? = nil,
                requiredConversationResolution: Components.Schemas.ProtectedBranch.RequiredConversationResolutionPayload? = nil,
                blockCreations: Components.Schemas.ProtectedBranch.BlockCreationsPayload? = nil,
                lockBranch: Components.Schemas.ProtectedBranch.LockBranchPayload? = nil,
                allowForkSyncing: Components.Schemas.ProtectedBranch.AllowForkSyncingPayload? = nil
            ) {
                self.url = url
                self.requiredStatusChecks = requiredStatusChecks
                self.requiredPullRequestReviews = requiredPullRequestReviews
                self.requiredSignatures = requiredSignatures
                self.enforceAdmins = enforceAdmins
                self.requiredLinearHistory = requiredLinearHistory
                self.allowForcePushes = allowForcePushes
                self.allowDeletions = allowDeletions
                self.restrictions = restrictions
                self.requiredConversationResolution = requiredConversationResolution
                self.blockCreations = blockCreations
                self.lockBranch = lockBranch
                self.allowForkSyncing = allowForkSyncing
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case requiredStatusChecks = "required_status_checks"
                case requiredPullRequestReviews = "required_pull_request_reviews"
                case requiredSignatures = "required_signatures"
                case enforceAdmins = "enforce_admins"
                case requiredLinearHistory = "required_linear_history"
                case allowForcePushes = "allow_force_pushes"
                case allowDeletions = "allow_deletions"
                case restrictions
                case requiredConversationResolution = "required_conversation_resolution"
                case blockCreations = "block_creations"
                case lockBranch = "lock_branch"
                case allowForkSyncing = "allow_fork_syncing"
            }
        }
        /// A list of errors found in a repo's CODEOWNERS file
        ///
        /// - Remark: Generated from `#/components/schemas/codeowners-errors`.
        public struct CodeownersErrors: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload`.
            public struct ErrorsPayloadPayload: Codable, Hashable, Sendable {
                /// The line number where this errors occurs.
                ///
                /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload/line`.
                public var line: Swift.Int
                /// The column number where this errors occurs.
                ///
                /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload/column`.
                public var column: Swift.Int
                /// The contents of the line where the error occurs.
                ///
                /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload/source`.
                public var source: Swift.String?
                /// The type of error.
                ///
                /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload/kind`.
                public var kind: Swift.String
                /// Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.
                ///
                /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload/suggestion`.
                public var suggestion: Swift.String?
                /// A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).
                ///
                /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload/message`.
                public var message: Swift.String
                /// The path of the file where the error occured.
                ///
                /// - Remark: Generated from `#/components/schemas/codeowners-errors/ErrorsPayload/path`.
                public var path: Swift.String
                /// Creates a new `ErrorsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - line: The line number where this errors occurs.
                ///   - column: The column number where this errors occurs.
                ///   - source: The contents of the line where the error occurs.
                ///   - kind: The type of error.
                ///   - suggestion: Suggested action to fix the error. This will usually be `null`, but is provided for some common errors.
                ///   - message: A human-readable description of the error, combining information from multiple fields, laid out for display in a monospaced typeface (for example, a command-line setting).
                ///   - path: The path of the file where the error occured.
                public init(
                    line: Swift.Int,
                    column: Swift.Int,
                    source: Swift.String? = nil,
                    kind: Swift.String,
                    suggestion: Swift.String? = nil,
                    message: Swift.String,
                    path: Swift.String
                ) {
                    self.line = line
                    self.column = column
                    self.source = source
                    self.kind = kind
                    self.suggestion = suggestion
                    self.message = message
                    self.path = path
                }
                public enum CodingKeys: String, CodingKey {
                    case line
                    case column
                    case source
                    case kind
                    case suggestion
                    case message
                    case path
                }
            }
            /// - Remark: Generated from `#/components/schemas/codeowners-errors/errors`.
            public typealias ErrorsPayload = [Components.Schemas.CodeownersErrors.ErrorsPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/codeowners-errors/errors`.
            public var errors: Components.Schemas.CodeownersErrors.ErrorsPayload
            /// Creates a new `CodeownersErrors`.
            ///
            /// - Parameters:
            ///   - errors:
            public init(errors: Components.Schemas.CodeownersErrors.ErrorsPayload) {
                self.errors = errors
            }
            public enum CodingKeys: String, CodingKey {
                case errors
            }
        }
        /// Collaborator
        ///
        /// - Remark: Generated from `#/components/schemas/collaborator`.
        public struct Collaborator: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/collaborator/login`.
            public var login: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/collaborator/email`.
            public var email: Swift.String?
            /// - Remark: Generated from `#/components/schemas/collaborator/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/collaborator/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/avatar_url`.
            public var avatarUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/gravatar_id`.
            public var gravatarId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/collaborator/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/followers_url`.
            public var followersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/following_url`.
            public var followingUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/gists_url`.
            public var gistsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/starred_url`.
            public var starredUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/subscriptions_url`.
            public var subscriptionsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/organizations_url`.
            public var organizationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/repos_url`.
            public var reposUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/received_events_url`.
            public var receivedEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/type`.
            public var _type: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/site_admin`.
            public var siteAdmin: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/collaborator/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/collaborator/permissions/pull`.
                public var pull: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/collaborator/permissions/triage`.
                public var triage: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/collaborator/permissions/push`.
                public var push: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/collaborator/permissions/maintain`.
                public var maintain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/collaborator/permissions/admin`.
                public var admin: Swift.Bool
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - pull:
                ///   - triage:
                ///   - push:
                ///   - maintain:
                ///   - admin:
                public init(
                    pull: Swift.Bool,
                    triage: Swift.Bool? = nil,
                    push: Swift.Bool,
                    maintain: Swift.Bool? = nil,
                    admin: Swift.Bool
                ) {
                    self.pull = pull
                    self.triage = triage
                    self.push = push
                    self.maintain = maintain
                    self.admin = admin
                }
                public enum CodingKeys: String, CodingKey {
                    case pull
                    case triage
                    case push
                    case maintain
                    case admin
                }
            }
            /// - Remark: Generated from `#/components/schemas/collaborator/permissions`.
            public var permissions: Components.Schemas.Collaborator.PermissionsPayload?
            /// - Remark: Generated from `#/components/schemas/collaborator/role_name`.
            public var roleName: Swift.String
            /// - Remark: Generated from `#/components/schemas/collaborator/user_view_type`.
            public var userViewType: Swift.String?
            /// Creates a new `Collaborator`.
            ///
            /// - Parameters:
            ///   - login:
            ///   - id:
            ///   - email:
            ///   - name:
            ///   - nodeId:
            ///   - avatarUrl:
            ///   - gravatarId:
            ///   - url:
            ///   - htmlUrl:
            ///   - followersUrl:
            ///   - followingUrl:
            ///   - gistsUrl:
            ///   - starredUrl:
            ///   - subscriptionsUrl:
            ///   - organizationsUrl:
            ///   - reposUrl:
            ///   - eventsUrl:
            ///   - receivedEventsUrl:
            ///   - _type:
            ///   - siteAdmin:
            ///   - permissions:
            ///   - roleName:
            ///   - userViewType:
            public init(
                login: Swift.String,
                id: Swift.Int64,
                email: Swift.String? = nil,
                name: Swift.String? = nil,
                nodeId: Swift.String,
                avatarUrl: Swift.String,
                gravatarId: Swift.String? = nil,
                url: Swift.String,
                htmlUrl: Swift.String,
                followersUrl: Swift.String,
                followingUrl: Swift.String,
                gistsUrl: Swift.String,
                starredUrl: Swift.String,
                subscriptionsUrl: Swift.String,
                organizationsUrl: Swift.String,
                reposUrl: Swift.String,
                eventsUrl: Swift.String,
                receivedEventsUrl: Swift.String,
                _type: Swift.String,
                siteAdmin: Swift.Bool,
                permissions: Components.Schemas.Collaborator.PermissionsPayload? = nil,
                roleName: Swift.String,
                userViewType: Swift.String? = nil
            ) {
                self.login = login
                self.id = id
                self.email = email
                self.name = name
                self.nodeId = nodeId
                self.avatarUrl = avatarUrl
                self.gravatarId = gravatarId
                self.url = url
                self.htmlUrl = htmlUrl
                self.followersUrl = followersUrl
                self.followingUrl = followingUrl
                self.gistsUrl = gistsUrl
                self.starredUrl = starredUrl
                self.subscriptionsUrl = subscriptionsUrl
                self.organizationsUrl = organizationsUrl
                self.reposUrl = reposUrl
                self.eventsUrl = eventsUrl
                self.receivedEventsUrl = receivedEventsUrl
                self._type = _type
                self.siteAdmin = siteAdmin
                self.permissions = permissions
                self.roleName = roleName
                self.userViewType = userViewType
            }
            public enum CodingKeys: String, CodingKey {
                case login
                case id
                case email
                case name
                case nodeId = "node_id"
                case avatarUrl = "avatar_url"
                case gravatarId = "gravatar_id"
                case url
                case htmlUrl = "html_url"
                case followersUrl = "followers_url"
                case followingUrl = "following_url"
                case gistsUrl = "gists_url"
                case starredUrl = "starred_url"
                case subscriptionsUrl = "subscriptions_url"
                case organizationsUrl = "organizations_url"
                case reposUrl = "repos_url"
                case eventsUrl = "events_url"
                case receivedEventsUrl = "received_events_url"
                case _type = "type"
                case siteAdmin = "site_admin"
                case permissions
                case roleName = "role_name"
                case userViewType = "user_view_type"
            }
        }
        /// Repository invitations let you manage who you collaborate with.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-invitation`.
        public struct RepositoryInvitation: Codable, Hashable, Sendable {
            /// Unique identifier of the repository invitation.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-invitation/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/repository-invitation/repository`.
            public var repository: Components.Schemas.MinimalRepository
            /// - Remark: Generated from `#/components/schemas/repository-invitation/invitee`.
            public var invitee: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/repository-invitation/inviter`.
            public var inviter: Components.Schemas.NullableSimpleUser?
            /// The permission associated with the invitation.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-invitation/permissions`.
            @frozen public enum PermissionsPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case read = "read"
                case write = "write"
                case admin = "admin"
                case triage = "triage"
                case maintain = "maintain"
            }
            /// The permission associated with the invitation.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-invitation/permissions`.
            public var permissions: Components.Schemas.RepositoryInvitation.PermissionsPayload
            /// - Remark: Generated from `#/components/schemas/repository-invitation/created_at`.
            public var createdAt: Foundation.Date
            /// Whether or not the invitation has expired
            ///
            /// - Remark: Generated from `#/components/schemas/repository-invitation/expired`.
            public var expired: Swift.Bool?
            /// URL for the repository invitation
            ///
            /// - Remark: Generated from `#/components/schemas/repository-invitation/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository-invitation/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository-invitation/node_id`.
            public var nodeId: Swift.String
            /// Creates a new `RepositoryInvitation`.
            ///
            /// - Parameters:
            ///   - id: Unique identifier of the repository invitation.
            ///   - repository:
            ///   - invitee:
            ///   - inviter:
            ///   - permissions: The permission associated with the invitation.
            ///   - createdAt:
            ///   - expired: Whether or not the invitation has expired
            ///   - url: URL for the repository invitation
            ///   - htmlUrl:
            ///   - nodeId:
            public init(
                id: Swift.Int64,
                repository: Components.Schemas.MinimalRepository,
                invitee: Components.Schemas.NullableSimpleUser? = nil,
                inviter: Components.Schemas.NullableSimpleUser? = nil,
                permissions: Components.Schemas.RepositoryInvitation.PermissionsPayload,
                createdAt: Foundation.Date,
                expired: Swift.Bool? = nil,
                url: Swift.String,
                htmlUrl: Swift.String,
                nodeId: Swift.String
            ) {
                self.id = id
                self.repository = repository
                self.invitee = invitee
                self.inviter = inviter
                self.permissions = permissions
                self.createdAt = createdAt
                self.expired = expired
                self.url = url
                self.htmlUrl = htmlUrl
                self.nodeId = nodeId
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case repository
                case invitee
                case inviter
                case permissions
                case createdAt = "created_at"
                case expired
                case url
                case htmlUrl = "html_url"
                case nodeId = "node_id"
            }
        }
        /// Collaborator
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-collaborator`.
        public struct NullableCollaborator: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/login`.
            public var login: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/email`.
            public var email: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/avatar_url`.
            public var avatarUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/gravatar_id`.
            public var gravatarId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/followers_url`.
            public var followersUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/following_url`.
            public var followingUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/gists_url`.
            public var gistsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/starred_url`.
            public var starredUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/subscriptions_url`.
            public var subscriptionsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/organizations_url`.
            public var organizationsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/repos_url`.
            public var reposUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/events_url`.
            public var eventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/received_events_url`.
            public var receivedEventsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/type`.
            public var _type: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/site_admin`.
            public var siteAdmin: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/permissions`.
            public struct PermissionsPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/nullable-collaborator/permissions/pull`.
                public var pull: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/nullable-collaborator/permissions/triage`.
                public var triage: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/nullable-collaborator/permissions/push`.
                public var push: Swift.Bool
                /// - Remark: Generated from `#/components/schemas/nullable-collaborator/permissions/maintain`.
                public var maintain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/nullable-collaborator/permissions/admin`.
                public var admin: Swift.Bool
                /// Creates a new `PermissionsPayload`.
                ///
                /// - Parameters:
                ///   - pull:
                ///   - triage:
                ///   - push:
                ///   - maintain:
                ///   - admin:
                public init(
                    pull: Swift.Bool,
                    triage: Swift.Bool? = nil,
                    push: Swift.Bool,
                    maintain: Swift.Bool? = nil,
                    admin: Swift.Bool
                ) {
                    self.pull = pull
                    self.triage = triage
                    self.push = push
                    self.maintain = maintain
                    self.admin = admin
                }
                public enum CodingKeys: String, CodingKey {
                    case pull
                    case triage
                    case push
                    case maintain
                    case admin
                }
            }
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/permissions`.
            public var permissions: Components.Schemas.NullableCollaborator.PermissionsPayload?
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/role_name`.
            public var roleName: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-collaborator/user_view_type`.
            public var userViewType: Swift.String?
            /// Creates a new `NullableCollaborator`.
            ///
            /// - Parameters:
            ///   - login:
            ///   - id:
            ///   - email:
            ///   - name:
            ///   - nodeId:
            ///   - avatarUrl:
            ///   - gravatarId:
            ///   - url:
            ///   - htmlUrl:
            ///   - followersUrl:
            ///   - followingUrl:
            ///   - gistsUrl:
            ///   - starredUrl:
            ///   - subscriptionsUrl:
            ///   - organizationsUrl:
            ///   - reposUrl:
            ///   - eventsUrl:
            ///   - receivedEventsUrl:
            ///   - _type:
            ///   - siteAdmin:
            ///   - permissions:
            ///   - roleName:
            ///   - userViewType:
            public init(
                login: Swift.String,
                id: Swift.Int64,
                email: Swift.String? = nil,
                name: Swift.String? = nil,
                nodeId: Swift.String,
                avatarUrl: Swift.String,
                gravatarId: Swift.String? = nil,
                url: Swift.String,
                htmlUrl: Swift.String,
                followersUrl: Swift.String,
                followingUrl: Swift.String,
                gistsUrl: Swift.String,
                starredUrl: Swift.String,
                subscriptionsUrl: Swift.String,
                organizationsUrl: Swift.String,
                reposUrl: Swift.String,
                eventsUrl: Swift.String,
                receivedEventsUrl: Swift.String,
                _type: Swift.String,
                siteAdmin: Swift.Bool,
                permissions: Components.Schemas.NullableCollaborator.PermissionsPayload? = nil,
                roleName: Swift.String,
                userViewType: Swift.String? = nil
            ) {
                self.login = login
                self.id = id
                self.email = email
                self.name = name
                self.nodeId = nodeId
                self.avatarUrl = avatarUrl
                self.gravatarId = gravatarId
                self.url = url
                self.htmlUrl = htmlUrl
                self.followersUrl = followersUrl
                self.followingUrl = followingUrl
                self.gistsUrl = gistsUrl
                self.starredUrl = starredUrl
                self.subscriptionsUrl = subscriptionsUrl
                self.organizationsUrl = organizationsUrl
                self.reposUrl = reposUrl
                self.eventsUrl = eventsUrl
                self.receivedEventsUrl = receivedEventsUrl
                self._type = _type
                self.siteAdmin = siteAdmin
                self.permissions = permissions
                self.roleName = roleName
                self.userViewType = userViewType
            }
            public enum CodingKeys: String, CodingKey {
                case login
                case id
                case email
                case name
                case nodeId = "node_id"
                case avatarUrl = "avatar_url"
                case gravatarId = "gravatar_id"
                case url
                case htmlUrl = "html_url"
                case followersUrl = "followers_url"
                case followingUrl = "following_url"
                case gistsUrl = "gists_url"
                case starredUrl = "starred_url"
                case subscriptionsUrl = "subscriptions_url"
                case organizationsUrl = "organizations_url"
                case reposUrl = "repos_url"
                case eventsUrl = "events_url"
                case receivedEventsUrl = "received_events_url"
                case _type = "type"
                case siteAdmin = "site_admin"
                case permissions
                case roleName = "role_name"
                case userViewType = "user_view_type"
            }
        }
        /// Repository Collaborator Permission
        ///
        /// - Remark: Generated from `#/components/schemas/repository-collaborator-permission`.
        public struct RepositoryCollaboratorPermission: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-collaborator-permission/permission`.
            public var permission: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository-collaborator-permission/role_name`.
            public var roleName: Swift.String
            /// - Remark: Generated from `#/components/schemas/repository-collaborator-permission/user`.
            public var user: Components.Schemas.NullableCollaborator?
            /// Creates a new `RepositoryCollaboratorPermission`.
            ///
            /// - Parameters:
            ///   - permission:
            ///   - roleName:
            ///   - user:
            public init(
                permission: Swift.String,
                roleName: Swift.String,
                user: Components.Schemas.NullableCollaborator? = nil
            ) {
                self.permission = permission
                self.roleName = roleName
                self.user = user
            }
            public enum CodingKeys: String, CodingKey {
                case permission
                case roleName = "role_name"
                case user
            }
        }
        /// Commit Comment
        ///
        /// - Remark: Generated from `#/components/schemas/commit-comment`.
        public struct CommitComment: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/commit-comment/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comment/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comment/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/commit-comment/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comment/body`.
            public var body: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comment/path`.
            public var path: Swift.String?
            /// - Remark: Generated from `#/components/schemas/commit-comment/position`.
            public var position: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/commit-comment/line`.
            public var line: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/commit-comment/commit_id`.
            public var commitId: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comment/user`.
            public var user: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/commit-comment/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/commit-comment/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/commit-comment/author_association`.
            public var authorAssociation: Components.Schemas.AuthorAssociation
            /// - Remark: Generated from `#/components/schemas/commit-comment/reactions`.
            public var reactions: Components.Schemas.ReactionRollup?
            /// Creates a new `CommitComment`.
            ///
            /// - Parameters:
            ///   - htmlUrl:
            ///   - url:
            ///   - id:
            ///   - nodeId:
            ///   - body:
            ///   - path:
            ///   - position:
            ///   - line:
            ///   - commitId:
            ///   - user:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - authorAssociation:
            ///   - reactions:
            public init(
                htmlUrl: Swift.String,
                url: Swift.String,
                id: Swift.Int,
                nodeId: Swift.String,
                body: Swift.String,
                path: Swift.String? = nil,
                position: Swift.Int? = nil,
                line: Swift.Int? = nil,
                commitId: Swift.String,
                user: Components.Schemas.NullableSimpleUser? = nil,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                authorAssociation: Components.Schemas.AuthorAssociation,
                reactions: Components.Schemas.ReactionRollup? = nil
            ) {
                self.htmlUrl = htmlUrl
                self.url = url
                self.id = id
                self.nodeId = nodeId
                self.body = body
                self.path = path
                self.position = position
                self.line = line
                self.commitId = commitId
                self.user = user
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.authorAssociation = authorAssociation
                self.reactions = reactions
            }
            public enum CodingKeys: String, CodingKey {
                case htmlUrl = "html_url"
                case url
                case id
                case nodeId = "node_id"
                case body
                case path
                case position
                case line
                case commitId = "commit_id"
                case user
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case authorAssociation = "author_association"
                case reactions
            }
        }
        /// Branch Short
        ///
        /// - Remark: Generated from `#/components/schemas/branch-short`.
        public struct BranchShort: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/branch-short/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/branch-short/commit`.
            public struct CommitPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/branch-short/commit/sha`.
                public var sha: Swift.String
                /// - Remark: Generated from `#/components/schemas/branch-short/commit/url`.
                public var url: Swift.String
                /// Creates a new `CommitPayload`.
                ///
                /// - Parameters:
                ///   - sha:
                ///   - url:
                public init(
                    sha: Swift.String,
                    url: Swift.String
                ) {
                    self.sha = sha
                    self.url = url
                }
                public enum CodingKeys: String, CodingKey {
                    case sha
                    case url
                }
            }
            /// - Remark: Generated from `#/components/schemas/branch-short/commit`.
            public var commit: Components.Schemas.BranchShort.CommitPayload
            /// - Remark: Generated from `#/components/schemas/branch-short/protected`.
            public var protected: Swift.Bool
            /// Creates a new `BranchShort`.
            ///
            /// - Parameters:
            ///   - name:
            ///   - commit:
            ///   - protected:
            public init(
                name: Swift.String,
                commit: Components.Schemas.BranchShort.CommitPayload,
                protected: Swift.Bool
            ) {
                self.name = name
                self.commit = commit
                self.protected = protected
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case commit
                case protected
            }
        }
        /// Hypermedia Link
        ///
        /// - Remark: Generated from `#/components/schemas/link`.
        public struct Link: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/link/href`.
            public var href: Swift.String
            /// Creates a new `Link`.
            ///
            /// - Parameters:
            ///   - href:
            public init(href: Swift.String) {
                self.href = href
            }
            public enum CodingKeys: String, CodingKey {
                case href
            }
        }
        /// The status of auto merging a pull request.
        ///
        /// - Remark: Generated from `#/components/schemas/auto-merge`.
        public struct AutoMerge: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/auto-merge/enabled_by`.
            public var enabledBy: Components.Schemas.SimpleUser
            /// The merge method to use.
            ///
            /// - Remark: Generated from `#/components/schemas/auto-merge/merge_method`.
            @frozen public enum MergeMethodPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case merge = "merge"
                case squash = "squash"
                case rebase = "rebase"
            }
            /// The merge method to use.
            ///
            /// - Remark: Generated from `#/components/schemas/auto-merge/merge_method`.
            public var mergeMethod: Components.Schemas.AutoMerge.MergeMethodPayload
            /// Title for the merge commit message.
            ///
            /// - Remark: Generated from `#/components/schemas/auto-merge/commit_title`.
            public var commitTitle: Swift.String
            /// Commit message for the merge commit.
            ///
            /// - Remark: Generated from `#/components/schemas/auto-merge/commit_message`.
            public var commitMessage: Swift.String
            /// Creates a new `AutoMerge`.
            ///
            /// - Parameters:
            ///   - enabledBy:
            ///   - mergeMethod: The merge method to use.
            ///   - commitTitle: Title for the merge commit message.
            ///   - commitMessage: Commit message for the merge commit.
            public init(
                enabledBy: Components.Schemas.SimpleUser,
                mergeMethod: Components.Schemas.AutoMerge.MergeMethodPayload,
                commitTitle: Swift.String,
                commitMessage: Swift.String
            ) {
                self.enabledBy = enabledBy
                self.mergeMethod = mergeMethod
                self.commitTitle = commitTitle
                self.commitMessage = commitMessage
            }
            public enum CodingKeys: String, CodingKey {
                case enabledBy = "enabled_by"
                case mergeMethod = "merge_method"
                case commitTitle = "commit_title"
                case commitMessage = "commit_message"
            }
        }
        /// Pull Request Simple
        ///
        /// - Remark: Generated from `#/components/schemas/pull-request-simple`.
        public struct PullRequestSimple: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/diff_url`.
            public var diffUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/patch_url`.
            public var patchUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/issue_url`.
            public var issueUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/commits_url`.
            public var commitsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/review_comments_url`.
            public var reviewCommentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/review_comment_url`.
            public var reviewCommentUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/comments_url`.
            public var commentsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/statuses_url`.
            public var statusesUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/number`.
            public var number: Swift.Int
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/state`.
            public var state: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/locked`.
            public var locked: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/title`.
            public var title: Swift.String
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/user`.
            public var user: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/body`.
            public var body: Swift.String?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload`.
            public struct LabelsPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload/id`.
                public var id: Swift.Int64
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload/node_id`.
                public var nodeId: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload/name`.
                public var name: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload/description`.
                public var description: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload/color`.
                public var color: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/LabelsPayload/default`.
                public var _default: Swift.Bool
                /// Creates a new `LabelsPayloadPayload`.
                ///
                /// - Parameters:
                ///   - id:
                ///   - nodeId:
                ///   - url:
                ///   - name:
                ///   - description:
                ///   - color:
                ///   - _default:
                public init(
                    id: Swift.Int64,
                    nodeId: Swift.String,
                    url: Swift.String,
                    name: Swift.String,
                    description: Swift.String,
                    color: Swift.String,
                    _default: Swift.Bool
                ) {
                    self.id = id
                    self.nodeId = nodeId
                    self.url = url
                    self.name = name
                    self.description = description
                    self.color = color
                    self._default = _default
                }
                public enum CodingKeys: String, CodingKey {
                    case id
                    case nodeId = "node_id"
                    case url
                    case name
                    case description
                    case color
                    case _default = "default"
                }
            }
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/labels`.
            public typealias LabelsPayload = [Components.Schemas.PullRequestSimple.LabelsPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/labels`.
            public var labels: Components.Schemas.PullRequestSimple.LabelsPayload
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/milestone`.
            public var milestone: Components.Schemas.NullableMilestone?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/active_lock_reason`.
            public var activeLockReason: Swift.String?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/closed_at`.
            public var closedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/merged_at`.
            public var mergedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/merge_commit_sha`.
            public var mergeCommitSha: Swift.String?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/assignee`.
            public var assignee: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/assignees`.
            public var assignees: [Components.Schemas.SimpleUser]?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/requested_reviewers`.
            public var requestedReviewers: [Components.Schemas.SimpleUser]?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/requested_teams`.
            public var requestedTeams: [Components.Schemas.Team]?
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/head`.
            public struct HeadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/head/label`.
                public var label: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/head/ref`.
                public var ref: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/head/repo`.
                public var repo: Components.Schemas.Repository
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/head/sha`.
                public var sha: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/head/user`.
                public var user: Components.Schemas.NullableSimpleUser?
                /// Creates a new `HeadPayload`.
                ///
                /// - Parameters:
                ///   - label:
                ///   - ref:
                ///   - repo:
                ///   - sha:
                ///   - user:
                public init(
                    label: Swift.String,
                    ref: Swift.String,
                    repo: Components.Schemas.Repository,
                    sha: Swift.String,
                    user: Components.Schemas.NullableSimpleUser? = nil
                ) {
                    self.label = label
                    self.ref = ref
                    self.repo = repo
                    self.sha = sha
                    self.user = user
                }
                public enum CodingKeys: String, CodingKey {
                    case label
                    case ref
                    case repo
                    case sha
                    case user
                }
            }
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/head`.
            public var head: Components.Schemas.PullRequestSimple.HeadPayload
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/base`.
            public struct BasePayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/base/label`.
                public var label: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/base/ref`.
                public var ref: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/base/repo`.
                public var repo: Components.Schemas.Repository
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/base/sha`.
                public var sha: Swift.String
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/base/user`.
                public var user: Components.Schemas.NullableSimpleUser?
                /// Creates a new `BasePayload`.
                ///
                /// - Parameters:
                ///   - label:
                ///   - ref:
                ///   - repo:
                ///   - sha:
                ///   - user:
                public init(
                    label: Swift.String,
                    ref: Swift.String,
                    repo: Components.Schemas.Repository,
                    sha: Swift.String,
                    user: Components.Schemas.NullableSimpleUser? = nil
                ) {
                    self.label = label
                    self.ref = ref
                    self.repo = repo
                    self.sha = sha
                    self.user = user
                }
                public enum CodingKeys: String, CodingKey {
                    case label
                    case ref
                    case repo
                    case sha
                    case user
                }
            }
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/base`.
            public var base: Components.Schemas.PullRequestSimple.BasePayload
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/comments`.
                public var comments: Components.Schemas.Link
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/commits`.
                public var commits: Components.Schemas.Link
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/statuses`.
                public var statuses: Components.Schemas.Link
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/html`.
                public var html: Components.Schemas.Link
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/issue`.
                public var issue: Components.Schemas.Link
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/review_comments`.
                public var reviewComments: Components.Schemas.Link
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/review_comment`.
                public var reviewComment: Components.Schemas.Link
                /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links/self`.
                public var _self: Components.Schemas.Link
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - comments:
                ///   - commits:
                ///   - statuses:
                ///   - html:
                ///   - issue:
                ///   - reviewComments:
                ///   - reviewComment:
                ///   - _self:
                public init(
                    comments: Components.Schemas.Link,
                    commits: Components.Schemas.Link,
                    statuses: Components.Schemas.Link,
                    html: Components.Schemas.Link,
                    issue: Components.Schemas.Link,
                    reviewComments: Components.Schemas.Link,
                    reviewComment: Components.Schemas.Link,
                    _self: Components.Schemas.Link
                ) {
                    self.comments = comments
                    self.commits = commits
                    self.statuses = statuses
                    self.html = html
                    self.issue = issue
                    self.reviewComments = reviewComments
                    self.reviewComment = reviewComment
                    self._self = _self
                }
                public enum CodingKeys: String, CodingKey {
                    case comments
                    case commits
                    case statuses
                    case html
                    case issue
                    case reviewComments = "review_comments"
                    case reviewComment = "review_comment"
                    case _self = "self"
                }
            }
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/_links`.
            public var _links: Components.Schemas.PullRequestSimple._LinksPayload
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/author_association`.
            public var authorAssociation: Components.Schemas.AuthorAssociation
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/auto_merge`.
            public var autoMerge: Components.Schemas.AutoMerge?
            /// Indicates whether or not the pull request is a draft.
            ///
            /// - Remark: Generated from `#/components/schemas/pull-request-simple/draft`.
            public var draft: Swift.Bool?
            /// Creates a new `PullRequestSimple`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - id:
            ///   - nodeId:
            ///   - htmlUrl:
            ///   - diffUrl:
            ///   - patchUrl:
            ///   - issueUrl:
            ///   - commitsUrl:
            ///   - reviewCommentsUrl:
            ///   - reviewCommentUrl:
            ///   - commentsUrl:
            ///   - statusesUrl:
            ///   - number:
            ///   - state:
            ///   - locked:
            ///   - title:
            ///   - user:
            ///   - body:
            ///   - labels:
            ///   - milestone:
            ///   - activeLockReason:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - closedAt:
            ///   - mergedAt:
            ///   - mergeCommitSha:
            ///   - assignee:
            ///   - assignees:
            ///   - requestedReviewers:
            ///   - requestedTeams:
            ///   - head:
            ///   - base:
            ///   - _links:
            ///   - authorAssociation:
            ///   - autoMerge:
            ///   - draft: Indicates whether or not the pull request is a draft.
            public init(
                url: Swift.String,
                id: Swift.Int64,
                nodeId: Swift.String,
                htmlUrl: Swift.String,
                diffUrl: Swift.String,
                patchUrl: Swift.String,
                issueUrl: Swift.String,
                commitsUrl: Swift.String,
                reviewCommentsUrl: Swift.String,
                reviewCommentUrl: Swift.String,
                commentsUrl: Swift.String,
                statusesUrl: Swift.String,
                number: Swift.Int,
                state: Swift.String,
                locked: Swift.Bool,
                title: Swift.String,
                user: Components.Schemas.NullableSimpleUser? = nil,
                body: Swift.String? = nil,
                labels: Components.Schemas.PullRequestSimple.LabelsPayload,
                milestone: Components.Schemas.NullableMilestone? = nil,
                activeLockReason: Swift.String? = nil,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                closedAt: Foundation.Date? = nil,
                mergedAt: Foundation.Date? = nil,
                mergeCommitSha: Swift.String? = nil,
                assignee: Components.Schemas.NullableSimpleUser? = nil,
                assignees: [Components.Schemas.SimpleUser]? = nil,
                requestedReviewers: [Components.Schemas.SimpleUser]? = nil,
                requestedTeams: [Components.Schemas.Team]? = nil,
                head: Components.Schemas.PullRequestSimple.HeadPayload,
                base: Components.Schemas.PullRequestSimple.BasePayload,
                _links: Components.Schemas.PullRequestSimple._LinksPayload,
                authorAssociation: Components.Schemas.AuthorAssociation,
                autoMerge: Components.Schemas.AutoMerge? = nil,
                draft: Swift.Bool? = nil
            ) {
                self.url = url
                self.id = id
                self.nodeId = nodeId
                self.htmlUrl = htmlUrl
                self.diffUrl = diffUrl
                self.patchUrl = patchUrl
                self.issueUrl = issueUrl
                self.commitsUrl = commitsUrl
                self.reviewCommentsUrl = reviewCommentsUrl
                self.reviewCommentUrl = reviewCommentUrl
                self.commentsUrl = commentsUrl
                self.statusesUrl = statusesUrl
                self.number = number
                self.state = state
                self.locked = locked
                self.title = title
                self.user = user
                self.body = body
                self.labels = labels
                self.milestone = milestone
                self.activeLockReason = activeLockReason
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.closedAt = closedAt
                self.mergedAt = mergedAt
                self.mergeCommitSha = mergeCommitSha
                self.assignee = assignee
                self.assignees = assignees
                self.requestedReviewers = requestedReviewers
                self.requestedTeams = requestedTeams
                self.head = head
                self.base = base
                self._links = _links
                self.authorAssociation = authorAssociation
                self.autoMerge = autoMerge
                self.draft = draft
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case id
                case nodeId = "node_id"
                case htmlUrl = "html_url"
                case diffUrl = "diff_url"
                case patchUrl = "patch_url"
                case issueUrl = "issue_url"
                case commitsUrl = "commits_url"
                case reviewCommentsUrl = "review_comments_url"
                case reviewCommentUrl = "review_comment_url"
                case commentsUrl = "comments_url"
                case statusesUrl = "statuses_url"
                case number
                case state
                case locked
                case title
                case user
                case body
                case labels
                case milestone
                case activeLockReason = "active_lock_reason"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case closedAt = "closed_at"
                case mergedAt = "merged_at"
                case mergeCommitSha = "merge_commit_sha"
                case assignee
                case assignees
                case requestedReviewers = "requested_reviewers"
                case requestedTeams = "requested_teams"
                case head
                case base
                case _links
                case authorAssociation = "author_association"
                case autoMerge = "auto_merge"
                case draft
            }
        }
        /// - Remark: Generated from `#/components/schemas/simple-commit-status`.
        public struct SimpleCommitStatus: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/state`.
            public var state: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/context`.
            public var context: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/target_url`.
            public var targetUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/required`.
            public var required: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/avatar_url`.
            public var avatarUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/simple-commit-status/updated_at`.
            public var updatedAt: Foundation.Date
            /// Creates a new `SimpleCommitStatus`.
            ///
            /// - Parameters:
            ///   - description:
            ///   - id:
            ///   - nodeId:
            ///   - state:
            ///   - context:
            ///   - targetUrl:
            ///   - required:
            ///   - avatarUrl:
            ///   - url:
            ///   - createdAt:
            ///   - updatedAt:
            public init(
                description: Swift.String? = nil,
                id: Swift.Int,
                nodeId: Swift.String,
                state: Swift.String,
                context: Swift.String,
                targetUrl: Swift.String? = nil,
                required: Swift.Bool? = nil,
                avatarUrl: Swift.String? = nil,
                url: Swift.String,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date
            ) {
                self.description = description
                self.id = id
                self.nodeId = nodeId
                self.state = state
                self.context = context
                self.targetUrl = targetUrl
                self.required = required
                self.avatarUrl = avatarUrl
                self.url = url
                self.createdAt = createdAt
                self.updatedAt = updatedAt
            }
            public enum CodingKeys: String, CodingKey {
                case description
                case id
                case nodeId = "node_id"
                case state
                case context
                case targetUrl = "target_url"
                case required
                case avatarUrl = "avatar_url"
                case url
                case createdAt = "created_at"
                case updatedAt = "updated_at"
            }
        }
        /// Combined Commit Status
        ///
        /// - Remark: Generated from `#/components/schemas/combined-commit-status`.
        public struct CombinedCommitStatus: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/combined-commit-status/state`.
            public var state: Swift.String
            /// - Remark: Generated from `#/components/schemas/combined-commit-status/statuses`.
            public var statuses: [Components.Schemas.SimpleCommitStatus]
            /// - Remark: Generated from `#/components/schemas/combined-commit-status/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/combined-commit-status/total_count`.
            public var totalCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/combined-commit-status/repository`.
            public var repository: Components.Schemas.MinimalRepository
            /// - Remark: Generated from `#/components/schemas/combined-commit-status/commit_url`.
            public var commitUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/combined-commit-status/url`.
            public var url: Swift.String
            /// Creates a new `CombinedCommitStatus`.
            ///
            /// - Parameters:
            ///   - state:
            ///   - statuses:
            ///   - sha:
            ///   - totalCount:
            ///   - repository:
            ///   - commitUrl:
            ///   - url:
            public init(
                state: Swift.String,
                statuses: [Components.Schemas.SimpleCommitStatus],
                sha: Swift.String,
                totalCount: Swift.Int,
                repository: Components.Schemas.MinimalRepository,
                commitUrl: Swift.String,
                url: Swift.String
            ) {
                self.state = state
                self.statuses = statuses
                self.sha = sha
                self.totalCount = totalCount
                self.repository = repository
                self.commitUrl = commitUrl
                self.url = url
            }
            public enum CodingKeys: String, CodingKey {
                case state
                case statuses
                case sha
                case totalCount = "total_count"
                case repository
                case commitUrl = "commit_url"
                case url
            }
        }
        /// The status of a commit.
        ///
        /// - Remark: Generated from `#/components/schemas/status`.
        public struct Status: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/status/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/status/avatar_url`.
            public var avatarUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/status/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/status/node_id`.
            public var nodeId: Swift.String
            /// - Remark: Generated from `#/components/schemas/status/state`.
            public var state: Swift.String
            /// - Remark: Generated from `#/components/schemas/status/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/status/target_url`.
            public var targetUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/status/context`.
            public var context: Swift.String
            /// - Remark: Generated from `#/components/schemas/status/created_at`.
            public var createdAt: Swift.String
            /// - Remark: Generated from `#/components/schemas/status/updated_at`.
            public var updatedAt: Swift.String
            /// - Remark: Generated from `#/components/schemas/status/creator`.
            public var creator: Components.Schemas.NullableSimpleUser?
            /// Creates a new `Status`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - avatarUrl:
            ///   - id:
            ///   - nodeId:
            ///   - state:
            ///   - description:
            ///   - targetUrl:
            ///   - context:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - creator:
            public init(
                url: Swift.String,
                avatarUrl: Swift.String? = nil,
                id: Swift.Int,
                nodeId: Swift.String,
                state: Swift.String,
                description: Swift.String? = nil,
                targetUrl: Swift.String? = nil,
                context: Swift.String,
                createdAt: Swift.String,
                updatedAt: Swift.String,
                creator: Components.Schemas.NullableSimpleUser? = nil
            ) {
                self.url = url
                self.avatarUrl = avatarUrl
                self.id = id
                self.nodeId = nodeId
                self.state = state
                self.description = description
                self.targetUrl = targetUrl
                self.context = context
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.creator = creator
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case avatarUrl = "avatar_url"
                case id
                case nodeId = "node_id"
                case state
                case description
                case targetUrl = "target_url"
                case context
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case creator
            }
        }
        /// Code of Conduct Simple
        ///
        /// - Remark: Generated from `#/components/schemas/nullable-code-of-conduct-simple`.
        public struct NullableCodeOfConductSimple: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/nullable-code-of-conduct-simple/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-code-of-conduct-simple/key`.
            public var key: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-code-of-conduct-simple/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-code-of-conduct-simple/html_url`.
            public var htmlUrl: Swift.String?
            /// Creates a new `NullableCodeOfConductSimple`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - key:
            ///   - name:
            ///   - htmlUrl:
            public init(
                url: Swift.String,
                key: Swift.String,
                name: Swift.String,
                htmlUrl: Swift.String? = nil
            ) {
                self.url = url
                self.key = key
                self.name = name
                self.htmlUrl = htmlUrl
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case key
                case name
                case htmlUrl = "html_url"
            }
        }
        /// - Remark: Generated from `#/components/schemas/nullable-community-health-file`.
        public struct NullableCommunityHealthFile: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/nullable-community-health-file/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/nullable-community-health-file/html_url`.
            public var htmlUrl: Swift.String
            /// Creates a new `NullableCommunityHealthFile`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - htmlUrl:
            public init(
                url: Swift.String,
                htmlUrl: Swift.String
            ) {
                self.url = url
                self.htmlUrl = htmlUrl
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case htmlUrl = "html_url"
            }
        }
        /// Community Profile
        ///
        /// - Remark: Generated from `#/components/schemas/community-profile`.
        public struct CommunityProfile: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/community-profile/health_percentage`.
            public var healthPercentage: Swift.Int
            /// - Remark: Generated from `#/components/schemas/community-profile/description`.
            public var description: Swift.String?
            /// - Remark: Generated from `#/components/schemas/community-profile/documentation`.
            public var documentation: Swift.String?
            /// - Remark: Generated from `#/components/schemas/community-profile/files`.
            public struct FilesPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/community-profile/files/code_of_conduct`.
                public var codeOfConduct: Components.Schemas.NullableCodeOfConductSimple?
                /// - Remark: Generated from `#/components/schemas/community-profile/files/code_of_conduct_file`.
                public var codeOfConductFile: Components.Schemas.NullableCommunityHealthFile?
                /// - Remark: Generated from `#/components/schemas/community-profile/files/license`.
                public var license: Components.Schemas.NullableLicenseSimple?
                /// - Remark: Generated from `#/components/schemas/community-profile/files/contributing`.
                public var contributing: Components.Schemas.NullableCommunityHealthFile?
                /// - Remark: Generated from `#/components/schemas/community-profile/files/readme`.
                public var readme: Components.Schemas.NullableCommunityHealthFile?
                /// - Remark: Generated from `#/components/schemas/community-profile/files/issue_template`.
                public var issueTemplate: Components.Schemas.NullableCommunityHealthFile?
                /// - Remark: Generated from `#/components/schemas/community-profile/files/pull_request_template`.
                public var pullRequestTemplate: Components.Schemas.NullableCommunityHealthFile?
                /// Creates a new `FilesPayload`.
                ///
                /// - Parameters:
                ///   - codeOfConduct:
                ///   - codeOfConductFile:
                ///   - license:
                ///   - contributing:
                ///   - readme:
                ///   - issueTemplate:
                ///   - pullRequestTemplate:
                public init(
                    codeOfConduct: Components.Schemas.NullableCodeOfConductSimple? = nil,
                    codeOfConductFile: Components.Schemas.NullableCommunityHealthFile? = nil,
                    license: Components.Schemas.NullableLicenseSimple? = nil,
                    contributing: Components.Schemas.NullableCommunityHealthFile? = nil,
                    readme: Components.Schemas.NullableCommunityHealthFile? = nil,
                    issueTemplate: Components.Schemas.NullableCommunityHealthFile? = nil,
                    pullRequestTemplate: Components.Schemas.NullableCommunityHealthFile? = nil
                ) {
                    self.codeOfConduct = codeOfConduct
                    self.codeOfConductFile = codeOfConductFile
                    self.license = license
                    self.contributing = contributing
                    self.readme = readme
                    self.issueTemplate = issueTemplate
                    self.pullRequestTemplate = pullRequestTemplate
                }
                public enum CodingKeys: String, CodingKey {
                    case codeOfConduct = "code_of_conduct"
                    case codeOfConductFile = "code_of_conduct_file"
                    case license
                    case contributing
                    case readme
                    case issueTemplate = "issue_template"
                    case pullRequestTemplate = "pull_request_template"
                }
            }
            /// - Remark: Generated from `#/components/schemas/community-profile/files`.
            public var files: Components.Schemas.CommunityProfile.FilesPayload
            /// - Remark: Generated from `#/components/schemas/community-profile/updated_at`.
            public var updatedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/community-profile/content_reports_enabled`.
            public var contentReportsEnabled: Swift.Bool?
            /// Creates a new `CommunityProfile`.
            ///
            /// - Parameters:
            ///   - healthPercentage:
            ///   - description:
            ///   - documentation:
            ///   - files:
            ///   - updatedAt:
            ///   - contentReportsEnabled:
            public init(
                healthPercentage: Swift.Int,
                description: Swift.String? = nil,
                documentation: Swift.String? = nil,
                files: Components.Schemas.CommunityProfile.FilesPayload,
                updatedAt: Foundation.Date? = nil,
                contentReportsEnabled: Swift.Bool? = nil
            ) {
                self.healthPercentage = healthPercentage
                self.description = description
                self.documentation = documentation
                self.files = files
                self.updatedAt = updatedAt
                self.contentReportsEnabled = contentReportsEnabled
            }
            public enum CodingKeys: String, CodingKey {
                case healthPercentage = "health_percentage"
                case description
                case documentation
                case files
                case updatedAt = "updated_at"
                case contentReportsEnabled = "content_reports_enabled"
            }
        }
        /// Commit Comparison
        ///
        /// - Remark: Generated from `#/components/schemas/commit-comparison`.
        public struct CommitComparison: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/commit-comparison/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comparison/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comparison/permalink_url`.
            public var permalinkUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comparison/diff_url`.
            public var diffUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comparison/patch_url`.
            public var patchUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/commit-comparison/base_commit`.
            public var baseCommit: Components.Schemas.Commit
            /// - Remark: Generated from `#/components/schemas/commit-comparison/merge_base_commit`.
            public var mergeBaseCommit: Components.Schemas.Commit
            /// - Remark: Generated from `#/components/schemas/commit-comparison/status`.
            @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case diverged = "diverged"
                case ahead = "ahead"
                case behind = "behind"
                case identical = "identical"
            }
            /// - Remark: Generated from `#/components/schemas/commit-comparison/status`.
            public var status: Components.Schemas.CommitComparison.StatusPayload
            /// - Remark: Generated from `#/components/schemas/commit-comparison/ahead_by`.
            public var aheadBy: Swift.Int
            /// - Remark: Generated from `#/components/schemas/commit-comparison/behind_by`.
            public var behindBy: Swift.Int
            /// - Remark: Generated from `#/components/schemas/commit-comparison/total_commits`.
            public var totalCommits: Swift.Int
            /// - Remark: Generated from `#/components/schemas/commit-comparison/commits`.
            public var commits: [Components.Schemas.Commit]
            /// - Remark: Generated from `#/components/schemas/commit-comparison/files`.
            public var files: [Components.Schemas.DiffEntry]?
            /// Creates a new `CommitComparison`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - htmlUrl:
            ///   - permalinkUrl:
            ///   - diffUrl:
            ///   - patchUrl:
            ///   - baseCommit:
            ///   - mergeBaseCommit:
            ///   - status:
            ///   - aheadBy:
            ///   - behindBy:
            ///   - totalCommits:
            ///   - commits:
            ///   - files:
            public init(
                url: Swift.String,
                htmlUrl: Swift.String,
                permalinkUrl: Swift.String,
                diffUrl: Swift.String,
                patchUrl: Swift.String,
                baseCommit: Components.Schemas.Commit,
                mergeBaseCommit: Components.Schemas.Commit,
                status: Components.Schemas.CommitComparison.StatusPayload,
                aheadBy: Swift.Int,
                behindBy: Swift.Int,
                totalCommits: Swift.Int,
                commits: [Components.Schemas.Commit],
                files: [Components.Schemas.DiffEntry]? = nil
            ) {
                self.url = url
                self.htmlUrl = htmlUrl
                self.permalinkUrl = permalinkUrl
                self.diffUrl = diffUrl
                self.patchUrl = patchUrl
                self.baseCommit = baseCommit
                self.mergeBaseCommit = mergeBaseCommit
                self.status = status
                self.aheadBy = aheadBy
                self.behindBy = behindBy
                self.totalCommits = totalCommits
                self.commits = commits
                self.files = files
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case htmlUrl = "html_url"
                case permalinkUrl = "permalink_url"
                case diffUrl = "diff_url"
                case patchUrl = "patch_url"
                case baseCommit = "base_commit"
                case mergeBaseCommit = "merge_base_commit"
                case status
                case aheadBy = "ahead_by"
                case behindBy = "behind_by"
                case totalCommits = "total_commits"
                case commits
                case files
            }
        }
        /// Content Tree
        ///
        /// - Remark: Generated from `#/components/schemas/content-tree`.
        public struct ContentTree: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/content-tree/type`.
            public var _type: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-tree/size`.
            public var size: Swift.Int
            /// - Remark: Generated from `#/components/schemas/content-tree/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-tree/path`.
            public var path: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-tree/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-tree/content`.
            public var content: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-tree/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-tree/git_url`.
            public var gitUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-tree/html_url`.
            public var htmlUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-tree/download_url`.
            public var downloadUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload`.
            public struct EntriesPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/type`.
                public var _type: Swift.String
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/size`.
                public var size: Swift.Int
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/name`.
                public var name: Swift.String
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/path`.
                public var path: Swift.String
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/sha`.
                public var sha: Swift.String
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/url`.
                public var url: Swift.String
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/git_url`.
                public var gitUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/html_url`.
                public var htmlUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/download_url`.
                public var downloadUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/_links`.
                public struct _LinksPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/_links/git`.
                    public var git: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/_links/html`.
                    public var html: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/_links/self`.
                    public var _self: Swift.String
                    /// Creates a new `_LinksPayload`.
                    ///
                    /// - Parameters:
                    ///   - git:
                    ///   - html:
                    ///   - _self:
                    public init(
                        git: Swift.String? = nil,
                        html: Swift.String? = nil,
                        _self: Swift.String
                    ) {
                        self.git = git
                        self.html = html
                        self._self = _self
                    }
                    public enum CodingKeys: String, CodingKey {
                        case git
                        case html
                        case _self = "self"
                    }
                }
                /// - Remark: Generated from `#/components/schemas/content-tree/EntriesPayload/_links`.
                public var _links: Components.Schemas.ContentTree.EntriesPayloadPayload._LinksPayload
                /// Creates a new `EntriesPayloadPayload`.
                ///
                /// - Parameters:
                ///   - _type:
                ///   - size:
                ///   - name:
                ///   - path:
                ///   - sha:
                ///   - url:
                ///   - gitUrl:
                ///   - htmlUrl:
                ///   - downloadUrl:
                ///   - _links:
                public init(
                    _type: Swift.String,
                    size: Swift.Int,
                    name: Swift.String,
                    path: Swift.String,
                    sha: Swift.String,
                    url: Swift.String,
                    gitUrl: Swift.String? = nil,
                    htmlUrl: Swift.String? = nil,
                    downloadUrl: Swift.String? = nil,
                    _links: Components.Schemas.ContentTree.EntriesPayloadPayload._LinksPayload
                ) {
                    self._type = _type
                    self.size = size
                    self.name = name
                    self.path = path
                    self.sha = sha
                    self.url = url
                    self.gitUrl = gitUrl
                    self.htmlUrl = htmlUrl
                    self.downloadUrl = downloadUrl
                    self._links = _links
                }
                public enum CodingKeys: String, CodingKey {
                    case _type = "type"
                    case size
                    case name
                    case path
                    case sha
                    case url
                    case gitUrl = "git_url"
                    case htmlUrl = "html_url"
                    case downloadUrl = "download_url"
                    case _links
                }
            }
            /// - Remark: Generated from `#/components/schemas/content-tree/entries`.
            public typealias EntriesPayload = [Components.Schemas.ContentTree.EntriesPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/content-tree/entries`.
            public var entries: Components.Schemas.ContentTree.EntriesPayload?
            /// - Remark: Generated from `#/components/schemas/content-tree/encoding`.
            public var encoding: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-tree/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/content-tree/_links/git`.
                public var git: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-tree/_links/html`.
                public var html: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-tree/_links/self`.
                public var _self: Swift.String
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - git:
                ///   - html:
                ///   - _self:
                public init(
                    git: Swift.String? = nil,
                    html: Swift.String? = nil,
                    _self: Swift.String
                ) {
                    self.git = git
                    self.html = html
                    self._self = _self
                }
                public enum CodingKeys: String, CodingKey {
                    case git
                    case html
                    case _self = "self"
                }
            }
            /// - Remark: Generated from `#/components/schemas/content-tree/_links`.
            public var _links: Components.Schemas.ContentTree._LinksPayload
            /// Creates a new `ContentTree`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - size:
            ///   - name:
            ///   - path:
            ///   - sha:
            ///   - content:
            ///   - url:
            ///   - gitUrl:
            ///   - htmlUrl:
            ///   - downloadUrl:
            ///   - entries:
            ///   - encoding:
            ///   - _links:
            public init(
                _type: Swift.String,
                size: Swift.Int,
                name: Swift.String,
                path: Swift.String,
                sha: Swift.String,
                content: Swift.String? = nil,
                url: Swift.String,
                gitUrl: Swift.String? = nil,
                htmlUrl: Swift.String? = nil,
                downloadUrl: Swift.String? = nil,
                entries: Components.Schemas.ContentTree.EntriesPayload? = nil,
                encoding: Swift.String? = nil,
                _links: Components.Schemas.ContentTree._LinksPayload
            ) {
                self._type = _type
                self.size = size
                self.name = name
                self.path = path
                self.sha = sha
                self.content = content
                self.url = url
                self.gitUrl = gitUrl
                self.htmlUrl = htmlUrl
                self.downloadUrl = downloadUrl
                self.entries = entries
                self.encoding = encoding
                self._links = _links
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case size
                case name
                case path
                case sha
                case content
                case url
                case gitUrl = "git_url"
                case htmlUrl = "html_url"
                case downloadUrl = "download_url"
                case entries
                case encoding
                case _links
            }
        }
        /// - Remark: Generated from `#/components/schemas/ContentDirectory`.
        public struct ContentDirectoryPayload: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case dir = "dir"
                case file = "file"
                case submodule = "submodule"
                case symlink = "symlink"
            }
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/type`.
            public var _type: Components.Schemas.ContentDirectoryPayload._TypePayload
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/size`.
            public var size: Swift.Int
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/path`.
            public var path: Swift.String
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/content`.
            public var content: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/git_url`.
            public var gitUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/html_url`.
            public var htmlUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/download_url`.
            public var downloadUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/ContentDirectory/_links/git`.
                public var git: Swift.String?
                /// - Remark: Generated from `#/components/schemas/ContentDirectory/_links/html`.
                public var html: Swift.String?
                /// - Remark: Generated from `#/components/schemas/ContentDirectory/_links/self`.
                public var _self: Swift.String
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - git:
                ///   - html:
                ///   - _self:
                public init(
                    git: Swift.String? = nil,
                    html: Swift.String? = nil,
                    _self: Swift.String
                ) {
                    self.git = git
                    self.html = html
                    self._self = _self
                }
                public enum CodingKeys: String, CodingKey {
                    case git
                    case html
                    case _self = "self"
                }
            }
            /// - Remark: Generated from `#/components/schemas/ContentDirectory/_links`.
            public var _links: Components.Schemas.ContentDirectoryPayload._LinksPayload
            /// Creates a new `ContentDirectoryPayload`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - size:
            ///   - name:
            ///   - path:
            ///   - content:
            ///   - sha:
            ///   - url:
            ///   - gitUrl:
            ///   - htmlUrl:
            ///   - downloadUrl:
            ///   - _links:
            public init(
                _type: Components.Schemas.ContentDirectoryPayload._TypePayload,
                size: Swift.Int,
                name: Swift.String,
                path: Swift.String,
                content: Swift.String? = nil,
                sha: Swift.String,
                url: Swift.String,
                gitUrl: Swift.String? = nil,
                htmlUrl: Swift.String? = nil,
                downloadUrl: Swift.String? = nil,
                _links: Components.Schemas.ContentDirectoryPayload._LinksPayload
            ) {
                self._type = _type
                self.size = size
                self.name = name
                self.path = path
                self.content = content
                self.sha = sha
                self.url = url
                self.gitUrl = gitUrl
                self.htmlUrl = htmlUrl
                self.downloadUrl = downloadUrl
                self._links = _links
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case size
                case name
                case path
                case content
                case sha
                case url
                case gitUrl = "git_url"
                case htmlUrl = "html_url"
                case downloadUrl = "download_url"
                case _links
            }
        }
        /// A list of directory items
        ///
        /// - Remark: Generated from `#/components/schemas/content-directory`.
        public typealias ContentDirectory = [Components.Schemas.ContentDirectoryPayload]
        /// Content File
        ///
        /// - Remark: Generated from `#/components/schemas/content-file`.
        public struct ContentFile: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/content-file/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case file = "file"
            }
            /// - Remark: Generated from `#/components/schemas/content-file/type`.
            public var _type: Components.Schemas.ContentFile._TypePayload
            /// - Remark: Generated from `#/components/schemas/content-file/encoding`.
            public var encoding: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-file/size`.
            public var size: Swift.Int
            /// - Remark: Generated from `#/components/schemas/content-file/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-file/path`.
            public var path: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-file/content`.
            public var content: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-file/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-file/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-file/git_url`.
            public var gitUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-file/html_url`.
            public var htmlUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-file/download_url`.
            public var downloadUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-file/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/content-file/_links/git`.
                public var git: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-file/_links/html`.
                public var html: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-file/_links/self`.
                public var _self: Swift.String
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - git:
                ///   - html:
                ///   - _self:
                public init(
                    git: Swift.String? = nil,
                    html: Swift.String? = nil,
                    _self: Swift.String
                ) {
                    self.git = git
                    self.html = html
                    self._self = _self
                }
                public enum CodingKeys: String, CodingKey {
                    case git
                    case html
                    case _self = "self"
                }
            }
            /// - Remark: Generated from `#/components/schemas/content-file/_links`.
            public var _links: Components.Schemas.ContentFile._LinksPayload
            /// - Remark: Generated from `#/components/schemas/content-file/target`.
            public var target: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-file/submodule_git_url`.
            public var submoduleGitUrl: Swift.String?
            /// Creates a new `ContentFile`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - encoding:
            ///   - size:
            ///   - name:
            ///   - path:
            ///   - content:
            ///   - sha:
            ///   - url:
            ///   - gitUrl:
            ///   - htmlUrl:
            ///   - downloadUrl:
            ///   - _links:
            ///   - target:
            ///   - submoduleGitUrl:
            public init(
                _type: Components.Schemas.ContentFile._TypePayload,
                encoding: Swift.String,
                size: Swift.Int,
                name: Swift.String,
                path: Swift.String,
                content: Swift.String,
                sha: Swift.String,
                url: Swift.String,
                gitUrl: Swift.String? = nil,
                htmlUrl: Swift.String? = nil,
                downloadUrl: Swift.String? = nil,
                _links: Components.Schemas.ContentFile._LinksPayload,
                target: Swift.String? = nil,
                submoduleGitUrl: Swift.String? = nil
            ) {
                self._type = _type
                self.encoding = encoding
                self.size = size
                self.name = name
                self.path = path
                self.content = content
                self.sha = sha
                self.url = url
                self.gitUrl = gitUrl
                self.htmlUrl = htmlUrl
                self.downloadUrl = downloadUrl
                self._links = _links
                self.target = target
                self.submoduleGitUrl = submoduleGitUrl
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case encoding
                case size
                case name
                case path
                case content
                case sha
                case url
                case gitUrl = "git_url"
                case htmlUrl = "html_url"
                case downloadUrl = "download_url"
                case _links
                case target
                case submoduleGitUrl = "submodule_git_url"
            }
        }
        /// An object describing a symlink
        ///
        /// - Remark: Generated from `#/components/schemas/content-symlink`.
        public struct ContentSymlink: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/content-symlink/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case symlink = "symlink"
            }
            /// - Remark: Generated from `#/components/schemas/content-symlink/type`.
            public var _type: Components.Schemas.ContentSymlink._TypePayload
            /// - Remark: Generated from `#/components/schemas/content-symlink/target`.
            public var target: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-symlink/size`.
            public var size: Swift.Int
            /// - Remark: Generated from `#/components/schemas/content-symlink/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-symlink/path`.
            public var path: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-symlink/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-symlink/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-symlink/git_url`.
            public var gitUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-symlink/html_url`.
            public var htmlUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-symlink/download_url`.
            public var downloadUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-symlink/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/content-symlink/_links/git`.
                public var git: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-symlink/_links/html`.
                public var html: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-symlink/_links/self`.
                public var _self: Swift.String
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - git:
                ///   - html:
                ///   - _self:
                public init(
                    git: Swift.String? = nil,
                    html: Swift.String? = nil,
                    _self: Swift.String
                ) {
                    self.git = git
                    self.html = html
                    self._self = _self
                }
                public enum CodingKeys: String, CodingKey {
                    case git
                    case html
                    case _self = "self"
                }
            }
            /// - Remark: Generated from `#/components/schemas/content-symlink/_links`.
            public var _links: Components.Schemas.ContentSymlink._LinksPayload
            /// Creates a new `ContentSymlink`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - target:
            ///   - size:
            ///   - name:
            ///   - path:
            ///   - sha:
            ///   - url:
            ///   - gitUrl:
            ///   - htmlUrl:
            ///   - downloadUrl:
            ///   - _links:
            public init(
                _type: Components.Schemas.ContentSymlink._TypePayload,
                target: Swift.String,
                size: Swift.Int,
                name: Swift.String,
                path: Swift.String,
                sha: Swift.String,
                url: Swift.String,
                gitUrl: Swift.String? = nil,
                htmlUrl: Swift.String? = nil,
                downloadUrl: Swift.String? = nil,
                _links: Components.Schemas.ContentSymlink._LinksPayload
            ) {
                self._type = _type
                self.target = target
                self.size = size
                self.name = name
                self.path = path
                self.sha = sha
                self.url = url
                self.gitUrl = gitUrl
                self.htmlUrl = htmlUrl
                self.downloadUrl = downloadUrl
                self._links = _links
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case target
                case size
                case name
                case path
                case sha
                case url
                case gitUrl = "git_url"
                case htmlUrl = "html_url"
                case downloadUrl = "download_url"
                case _links
            }
        }
        /// An object describing a submodule
        ///
        /// - Remark: Generated from `#/components/schemas/content-submodule`.
        public struct ContentSubmodule: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/content-submodule/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case submodule = "submodule"
            }
            /// - Remark: Generated from `#/components/schemas/content-submodule/type`.
            public var _type: Components.Schemas.ContentSubmodule._TypePayload
            /// - Remark: Generated from `#/components/schemas/content-submodule/submodule_git_url`.
            public var submoduleGitUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-submodule/size`.
            public var size: Swift.Int
            /// - Remark: Generated from `#/components/schemas/content-submodule/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-submodule/path`.
            public var path: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-submodule/sha`.
            public var sha: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-submodule/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-submodule/git_url`.
            public var gitUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-submodule/html_url`.
            public var htmlUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-submodule/download_url`.
            public var downloadUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/content-submodule/_links`.
            public struct _LinksPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/content-submodule/_links/git`.
                public var git: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-submodule/_links/html`.
                public var html: Swift.String?
                /// - Remark: Generated from `#/components/schemas/content-submodule/_links/self`.
                public var _self: Swift.String
                /// Creates a new `_LinksPayload`.
                ///
                /// - Parameters:
                ///   - git:
                ///   - html:
                ///   - _self:
                public init(
                    git: Swift.String? = nil,
                    html: Swift.String? = nil,
                    _self: Swift.String
                ) {
                    self.git = git
                    self.html = html
                    self._self = _self
                }
                public enum CodingKeys: String, CodingKey {
                    case git
                    case html
                    case _self = "self"
                }
            }
            /// - Remark: Generated from `#/components/schemas/content-submodule/_links`.
            public var _links: Components.Schemas.ContentSubmodule._LinksPayload
            /// Creates a new `ContentSubmodule`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - submoduleGitUrl:
            ///   - size:
            ///   - name:
            ///   - path:
            ///   - sha:
            ///   - url:
            ///   - gitUrl:
            ///   - htmlUrl:
            ///   - downloadUrl:
            ///   - _links:
            public init(
                _type: Components.Schemas.ContentSubmodule._TypePayload,
                submoduleGitUrl: Swift.String,
                size: Swift.Int,
                name: Swift.String,
                path: Swift.String,
                sha: Swift.String,
                url: Swift.String,
                gitUrl: Swift.String? = nil,
                htmlUrl: Swift.String? = nil,
                downloadUrl: Swift.String? = nil,
                _links: Components.Schemas.ContentSubmodule._LinksPayload
            ) {
                self._type = _type
                self.submoduleGitUrl = submoduleGitUrl
                self.size = size
                self.name = name
                self.path = path
                self.sha = sha
                self.url = url
                self.gitUrl = gitUrl
                self.htmlUrl = htmlUrl
                self.downloadUrl = downloadUrl
                self._links = _links
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case submoduleGitUrl = "submodule_git_url"
                case size
                case name
                case path
                case sha
                case url
                case gitUrl = "git_url"
                case htmlUrl = "html_url"
                case downloadUrl = "download_url"
                case _links
            }
        }
        /// File Commit
        ///
        /// - Remark: Generated from `#/components/schemas/file-commit`.
        public struct FileCommit: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/file-commit/content`.
            public struct ContentPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/file-commit/content/name`.
                public var name: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/path`.
                public var path: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/sha`.
                public var sha: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/size`.
                public var size: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/url`.
                public var url: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/html_url`.
                public var htmlUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/git_url`.
                public var gitUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/download_url`.
                public var downloadUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/type`.
                public var _type: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/content/_links`.
                public struct _LinksPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/file-commit/content/_links/self`.
                    public var _self: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/content/_links/git`.
                    public var git: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/content/_links/html`.
                    public var html: Swift.String?
                    /// Creates a new `_LinksPayload`.
                    ///
                    /// - Parameters:
                    ///   - _self:
                    ///   - git:
                    ///   - html:
                    public init(
                        _self: Swift.String? = nil,
                        git: Swift.String? = nil,
                        html: Swift.String? = nil
                    ) {
                        self._self = _self
                        self.git = git
                        self.html = html
                    }
                    public enum CodingKeys: String, CodingKey {
                        case _self = "self"
                        case git
                        case html
                    }
                }
                /// - Remark: Generated from `#/components/schemas/file-commit/content/_links`.
                public var _links: Components.Schemas.FileCommit.ContentPayload._LinksPayload?
                /// Creates a new `ContentPayload`.
                ///
                /// - Parameters:
                ///   - name:
                ///   - path:
                ///   - sha:
                ///   - size:
                ///   - url:
                ///   - htmlUrl:
                ///   - gitUrl:
                ///   - downloadUrl:
                ///   - _type:
                ///   - _links:
                public init(
                    name: Swift.String? = nil,
                    path: Swift.String? = nil,
                    sha: Swift.String? = nil,
                    size: Swift.Int? = nil,
                    url: Swift.String? = nil,
                    htmlUrl: Swift.String? = nil,
                    gitUrl: Swift.String? = nil,
                    downloadUrl: Swift.String? = nil,
                    _type: Swift.String? = nil,
                    _links: Components.Schemas.FileCommit.ContentPayload._LinksPayload? = nil
                ) {
                    self.name = name
                    self.path = path
                    self.sha = sha
                    self.size = size
                    self.url = url
                    self.htmlUrl = htmlUrl
                    self.gitUrl = gitUrl
                    self.downloadUrl = downloadUrl
                    self._type = _type
                    self._links = _links
                }
                public enum CodingKeys: String, CodingKey {
                    case name
                    case path
                    case sha
                    case size
                    case url
                    case htmlUrl = "html_url"
                    case gitUrl = "git_url"
                    case downloadUrl = "download_url"
                    case _type = "type"
                    case _links
                }
            }
            /// - Remark: Generated from `#/components/schemas/file-commit/content`.
            public var content: Components.Schemas.FileCommit.ContentPayload?
            /// - Remark: Generated from `#/components/schemas/file-commit/commit`.
            public struct CommitPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/sha`.
                public var sha: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/node_id`.
                public var nodeId: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/url`.
                public var url: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/html_url`.
                public var htmlUrl: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/author`.
                public struct AuthorPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/author/date`.
                    public var date: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/author/name`.
                    public var name: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/author/email`.
                    public var email: Swift.String?
                    /// Creates a new `AuthorPayload`.
                    ///
                    /// - Parameters:
                    ///   - date:
                    ///   - name:
                    ///   - email:
                    public init(
                        date: Swift.String? = nil,
                        name: Swift.String? = nil,
                        email: Swift.String? = nil
                    ) {
                        self.date = date
                        self.name = name
                        self.email = email
                    }
                    public enum CodingKeys: String, CodingKey {
                        case date
                        case name
                        case email
                    }
                }
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/author`.
                public var author: Components.Schemas.FileCommit.CommitPayload.AuthorPayload?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/committer`.
                public struct CommitterPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/committer/date`.
                    public var date: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/committer/name`.
                    public var name: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/committer/email`.
                    public var email: Swift.String?
                    /// Creates a new `CommitterPayload`.
                    ///
                    /// - Parameters:
                    ///   - date:
                    ///   - name:
                    ///   - email:
                    public init(
                        date: Swift.String? = nil,
                        name: Swift.String? = nil,
                        email: Swift.String? = nil
                    ) {
                        self.date = date
                        self.name = name
                        self.email = email
                    }
                    public enum CodingKeys: String, CodingKey {
                        case date
                        case name
                        case email
                    }
                }
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/committer`.
                public var committer: Components.Schemas.FileCommit.CommitPayload.CommitterPayload?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/message`.
                public var message: Swift.String?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/tree`.
                public struct TreePayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/tree/url`.
                    public var url: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/tree/sha`.
                    public var sha: Swift.String?
                    /// Creates a new `TreePayload`.
                    ///
                    /// - Parameters:
                    ///   - url:
                    ///   - sha:
                    public init(
                        url: Swift.String? = nil,
                        sha: Swift.String? = nil
                    ) {
                        self.url = url
                        self.sha = sha
                    }
                    public enum CodingKeys: String, CodingKey {
                        case url
                        case sha
                    }
                }
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/tree`.
                public var tree: Components.Schemas.FileCommit.CommitPayload.TreePayload?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/ParentsPayload`.
                public struct ParentsPayloadPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/ParentsPayload/url`.
                    public var url: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/ParentsPayload/html_url`.
                    public var htmlUrl: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/ParentsPayload/sha`.
                    public var sha: Swift.String?
                    /// Creates a new `ParentsPayloadPayload`.
                    ///
                    /// - Parameters:
                    ///   - url:
                    ///   - htmlUrl:
                    ///   - sha:
                    public init(
                        url: Swift.String? = nil,
                        htmlUrl: Swift.String? = nil,
                        sha: Swift.String? = nil
                    ) {
                        self.url = url
                        self.htmlUrl = htmlUrl
                        self.sha = sha
                    }
                    public enum CodingKeys: String, CodingKey {
                        case url
                        case htmlUrl = "html_url"
                        case sha
                    }
                }
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/parents`.
                public typealias ParentsPayload = [Components.Schemas.FileCommit.CommitPayload.ParentsPayloadPayload]
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/parents`.
                public var parents: Components.Schemas.FileCommit.CommitPayload.ParentsPayload?
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/verification`.
                public struct VerificationPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/verification/verified`.
                    public var verified: Swift.Bool?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/verification/reason`.
                    public var reason: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/verification/signature`.
                    public var signature: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/verification/payload`.
                    public var payload: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/file-commit/commit/verification/verified_at`.
                    public var verifiedAt: Swift.String?
                    /// Creates a new `VerificationPayload`.
                    ///
                    /// - Parameters:
                    ///   - verified:
                    ///   - reason:
                    ///   - signature:
                    ///   - payload:
                    ///   - verifiedAt:
                    public init(
                        verified: Swift.Bool? = nil,
                        reason: Swift.String? = nil,
                        signature: Swift.String? = nil,
                        payload: Swift.String? = nil,
                        verifiedAt: Swift.String? = nil
                    ) {
                        self.verified = verified
                        self.reason = reason
                        self.signature = signature
                        self.payload = payload
                        self.verifiedAt = verifiedAt
                    }
                    public enum CodingKeys: String, CodingKey {
                        case verified
                        case reason
                        case signature
                        case payload
                        case verifiedAt = "verified_at"
                    }
                }
                /// - Remark: Generated from `#/components/schemas/file-commit/commit/verification`.
                public var verification: Components.Schemas.FileCommit.CommitPayload.VerificationPayload?
                /// Creates a new `CommitPayload`.
                ///
                /// - Parameters:
                ///   - sha:
                ///   - nodeId:
                ///   - url:
                ///   - htmlUrl:
                ///   - author:
                ///   - committer:
                ///   - message:
                ///   - tree:
                ///   - parents:
                ///   - verification:
                public init(
                    sha: Swift.String? = nil,
                    nodeId: Swift.String? = nil,
                    url: Swift.String? = nil,
                    htmlUrl: Swift.String? = nil,
                    author: Components.Schemas.FileCommit.CommitPayload.AuthorPayload? = nil,
                    committer: Components.Schemas.FileCommit.CommitPayload.CommitterPayload? = nil,
                    message: Swift.String? = nil,
                    tree: Components.Schemas.FileCommit.CommitPayload.TreePayload? = nil,
                    parents: Components.Schemas.FileCommit.CommitPayload.ParentsPayload? = nil,
                    verification: Components.Schemas.FileCommit.CommitPayload.VerificationPayload? = nil
                ) {
                    self.sha = sha
                    self.nodeId = nodeId
                    self.url = url
                    self.htmlUrl = htmlUrl
                    self.author = author
                    self.committer = committer
                    self.message = message
                    self.tree = tree
                    self.parents = parents
                    self.verification = verification
                }
                public enum CodingKeys: String, CodingKey {
                    case sha
                    case nodeId = "node_id"
                    case url
                    case htmlUrl = "html_url"
                    case author
                    case committer
                    case message
                    case tree
                    case parents
                    case verification
                }
            }
            /// - Remark: Generated from `#/components/schemas/file-commit/commit`.
            public var commit: Components.Schemas.FileCommit.CommitPayload
            /// Creates a new `FileCommit`.
            ///
            /// - Parameters:
            ///   - content:
            ///   - commit:
            public init(
                content: Components.Schemas.FileCommit.ContentPayload? = nil,
                commit: Components.Schemas.FileCommit.CommitPayload
            ) {
                self.content = content
                self.commit = commit
            }
            public enum CodingKeys: String, CodingKey {
                case content
                case commit
            }
        }
        /// The ID of the push protection bypass placeholder. This value is returned on any push protected routes.
        ///
        /// - Remark: Generated from `#/components/schemas/secret-scanning-push-protection-bypass-placeholder-id`.
        public typealias SecretScanningPushProtectionBypassPlaceholderId = Swift.String
        /// Repository rule violation was detected
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error`.
        public struct RepositoryRuleViolationError: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/message`.
            public var message: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/documentation_url`.
            public var documentationUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/status`.
            public var status: Swift.String?
            /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata`.
            public struct MetadataPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata/secret_scanning`.
                public struct SecretScanningPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata/secret_scanning/BypassPlaceholdersPayload`.
                    public struct BypassPlaceholdersPayloadPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata/secret_scanning/BypassPlaceholdersPayload/placeholder_id`.
                        public var placeholderId: Components.Schemas.SecretScanningPushProtectionBypassPlaceholderId?
                        /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata/secret_scanning/BypassPlaceholdersPayload/token_type`.
                        public var tokenType: Swift.String?
                        /// Creates a new `BypassPlaceholdersPayloadPayload`.
                        ///
                        /// - Parameters:
                        ///   - placeholderId:
                        ///   - tokenType:
                        public init(
                            placeholderId: Components.Schemas.SecretScanningPushProtectionBypassPlaceholderId? = nil,
                            tokenType: Swift.String? = nil
                        ) {
                            self.placeholderId = placeholderId
                            self.tokenType = tokenType
                        }
                        public enum CodingKeys: String, CodingKey {
                            case placeholderId = "placeholder_id"
                            case tokenType = "token_type"
                        }
                    }
                    /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata/secret_scanning/bypass_placeholders`.
                    public typealias BypassPlaceholdersPayload = [Components.Schemas.RepositoryRuleViolationError.MetadataPayload.SecretScanningPayload.BypassPlaceholdersPayloadPayload]
                    /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata/secret_scanning/bypass_placeholders`.
                    public var bypassPlaceholders: Components.Schemas.RepositoryRuleViolationError.MetadataPayload.SecretScanningPayload.BypassPlaceholdersPayload?
                    /// Creates a new `SecretScanningPayload`.
                    ///
                    /// - Parameters:
                    ///   - bypassPlaceholders:
                    public init(bypassPlaceholders: Components.Schemas.RepositoryRuleViolationError.MetadataPayload.SecretScanningPayload.BypassPlaceholdersPayload? = nil) {
                        self.bypassPlaceholders = bypassPlaceholders
                    }
                    public enum CodingKeys: String, CodingKey {
                        case bypassPlaceholders = "bypass_placeholders"
                    }
                }
                /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata/secret_scanning`.
                public var secretScanning: Components.Schemas.RepositoryRuleViolationError.MetadataPayload.SecretScanningPayload?
                /// Creates a new `MetadataPayload`.
                ///
                /// - Parameters:
                ///   - secretScanning:
                public init(secretScanning: Components.Schemas.RepositoryRuleViolationError.MetadataPayload.SecretScanningPayload? = nil) {
                    self.secretScanning = secretScanning
                }
                public enum CodingKeys: String, CodingKey {
                    case secretScanning = "secret_scanning"
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-violation-error/metadata`.
            public var metadata: Components.Schemas.RepositoryRuleViolationError.MetadataPayload?
            /// Creates a new `RepositoryRuleViolationError`.
            ///
            /// - Parameters:
            ///   - message:
            ///   - documentationUrl:
            ///   - status:
            ///   - metadata:
            public init(
                message: Swift.String? = nil,
                documentationUrl: Swift.String? = nil,
                status: Swift.String? = nil,
                metadata: Components.Schemas.RepositoryRuleViolationError.MetadataPayload? = nil
            ) {
                self.message = message
                self.documentationUrl = documentationUrl
                self.status = status
                self.metadata = metadata
            }
            public enum CodingKeys: String, CodingKey {
                case message
                case documentationUrl = "documentation_url"
                case status
                case metadata
            }
        }
        /// Contributor
        ///
        /// - Remark: Generated from `#/components/schemas/contributor`.
        public struct Contributor: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/contributor/login`.
            public var login: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/id`.
            public var id: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/contributor/node_id`.
            public var nodeId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/avatar_url`.
            public var avatarUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/gravatar_id`.
            public var gravatarId: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/url`.
            public var url: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/html_url`.
            public var htmlUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/followers_url`.
            public var followersUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/following_url`.
            public var followingUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/gists_url`.
            public var gistsUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/starred_url`.
            public var starredUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/subscriptions_url`.
            public var subscriptionsUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/organizations_url`.
            public var organizationsUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/repos_url`.
            public var reposUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/events_url`.
            public var eventsUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/received_events_url`.
            public var receivedEventsUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/type`.
            public var _type: Swift.String
            /// - Remark: Generated from `#/components/schemas/contributor/site_admin`.
            public var siteAdmin: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/contributor/contributions`.
            public var contributions: Swift.Int
            /// - Remark: Generated from `#/components/schemas/contributor/email`.
            public var email: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/contributor/user_view_type`.
            public var userViewType: Swift.String?
            /// Creates a new `Contributor`.
            ///
            /// - Parameters:
            ///   - login:
            ///   - id:
            ///   - nodeId:
            ///   - avatarUrl:
            ///   - gravatarId:
            ///   - url:
            ///   - htmlUrl:
            ///   - followersUrl:
            ///   - followingUrl:
            ///   - gistsUrl:
            ///   - starredUrl:
            ///   - subscriptionsUrl:
            ///   - organizationsUrl:
            ///   - reposUrl:
            ///   - eventsUrl:
            ///   - receivedEventsUrl:
            ///   - _type:
            ///   - siteAdmin:
            ///   - contributions:
            ///   - email:
            ///   - name:
            ///   - userViewType:
            public init(
                login: Swift.String? = nil,
                id: Swift.Int? = nil,
                nodeId: Swift.String? = nil,
                avatarUrl: Swift.String? = nil,
                gravatarId: Swift.String? = nil,
                url: Swift.String? = nil,
                htmlUrl: Swift.String? = nil,
                followersUrl: Swift.String? = nil,
                followingUrl: Swift.String? = nil,
                gistsUrl: Swift.String? = nil,
                starredUrl: Swift.String? = nil,
                subscriptionsUrl: Swift.String? = nil,
                organizationsUrl: Swift.String? = nil,
                reposUrl: Swift.String? = nil,
                eventsUrl: Swift.String? = nil,
                receivedEventsUrl: Swift.String? = nil,
                _type: Swift.String,
                siteAdmin: Swift.Bool? = nil,
                contributions: Swift.Int,
                email: Swift.String? = nil,
                name: Swift.String? = nil,
                userViewType: Swift.String? = nil
            ) {
                self.login = login
                self.id = id
                self.nodeId = nodeId
                self.avatarUrl = avatarUrl
                self.gravatarId = gravatarId
                self.url = url
                self.htmlUrl = htmlUrl
                self.followersUrl = followersUrl
                self.followingUrl = followingUrl
                self.gistsUrl = gistsUrl
                self.starredUrl = starredUrl
                self.subscriptionsUrl = subscriptionsUrl
                self.organizationsUrl = organizationsUrl
                self.reposUrl = reposUrl
                self.eventsUrl = eventsUrl
                self.receivedEventsUrl = receivedEventsUrl
                self._type = _type
                self.siteAdmin = siteAdmin
                self.contributions = contributions
                self.email = email
                self.name = name
                self.userViewType = userViewType
            }
            public enum CodingKeys: String, CodingKey {
                case login
                case id
                case nodeId = "node_id"
                case avatarUrl = "avatar_url"
                case gravatarId = "gravatar_id"
                case url
                case htmlUrl = "html_url"
                case followersUrl = "followers_url"
                case followingUrl = "following_url"
                case gistsUrl = "gists_url"
                case starredUrl = "starred_url"
                case subscriptionsUrl = "subscriptions_url"
                case organizationsUrl = "organizations_url"
                case reposUrl = "repos_url"
                case eventsUrl = "events_url"
                case receivedEventsUrl = "received_events_url"
                case _type = "type"
                case siteAdmin = "site_admin"
                case contributions
                case email
                case name
                case userViewType = "user_view_type"
            }
        }
        /// The status of a deployment.
        ///
        /// - Remark: Generated from `#/components/schemas/deployment-status`.
        public struct DeploymentStatus: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/deployment-status/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/deployment-status/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/deployment-status/node_id`.
            public var nodeId: Swift.String
            /// The state of the status.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-status/state`.
            @frozen public enum StatePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case error = "error"
                case failure = "failure"
                case inactive = "inactive"
                case pending = "pending"
                case success = "success"
                case queued = "queued"
                case inProgress = "in_progress"
            }
            /// The state of the status.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-status/state`.
            public var state: Components.Schemas.DeploymentStatus.StatePayload
            /// - Remark: Generated from `#/components/schemas/deployment-status/creator`.
            public var creator: Components.Schemas.NullableSimpleUser?
            /// A short description of the status.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-status/description`.
            public var description: Swift.String
            /// The environment of the deployment that the status is for.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-status/environment`.
            public var environment: Swift.String?
            /// Closing down notice: the URL to associate with this status.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-status/target_url`.
            public var targetUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/deployment-status/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/deployment-status/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/deployment-status/deployment_url`.
            public var deploymentUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/deployment-status/repository_url`.
            public var repositoryUrl: Swift.String
            /// The URL for accessing your environment.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-status/environment_url`.
            public var environmentUrl: Swift.String?
            /// The URL to associate with this status.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-status/log_url`.
            public var logUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/deployment-status/performed_via_github_app`.
            public var performedViaGithubApp: Components.Schemas.NullableIntegration?
            /// Creates a new `DeploymentStatus`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - id:
            ///   - nodeId:
            ///   - state: The state of the status.
            ///   - creator:
            ///   - description: A short description of the status.
            ///   - environment: The environment of the deployment that the status is for.
            ///   - targetUrl: Closing down notice: the URL to associate with this status.
            ///   - createdAt:
            ///   - updatedAt:
            ///   - deploymentUrl:
            ///   - repositoryUrl:
            ///   - environmentUrl: The URL for accessing your environment.
            ///   - logUrl: The URL to associate with this status.
            ///   - performedViaGithubApp:
            public init(
                url: Swift.String,
                id: Swift.Int64,
                nodeId: Swift.String,
                state: Components.Schemas.DeploymentStatus.StatePayload,
                creator: Components.Schemas.NullableSimpleUser? = nil,
                description: Swift.String,
                environment: Swift.String? = nil,
                targetUrl: Swift.String,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                deploymentUrl: Swift.String,
                repositoryUrl: Swift.String,
                environmentUrl: Swift.String? = nil,
                logUrl: Swift.String? = nil,
                performedViaGithubApp: Components.Schemas.NullableIntegration? = nil
            ) {
                self.url = url
                self.id = id
                self.nodeId = nodeId
                self.state = state
                self.creator = creator
                self.description = description
                self.environment = environment
                self.targetUrl = targetUrl
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.deploymentUrl = deploymentUrl
                self.repositoryUrl = repositoryUrl
                self.environmentUrl = environmentUrl
                self.logUrl = logUrl
                self.performedViaGithubApp = performedViaGithubApp
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case id
                case nodeId = "node_id"
                case state
                case creator
                case description
                case environment
                case targetUrl = "target_url"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case deploymentUrl = "deployment_url"
                case repositoryUrl = "repository_url"
                case environmentUrl = "environment_url"
                case logUrl = "log_url"
                case performedViaGithubApp = "performed_via_github_app"
            }
        }
        /// The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).
        ///
        /// - Remark: Generated from `#/components/schemas/wait-timer`.
        public typealias WaitTimer = Swift.Int
        /// The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.
        ///
        /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-settings`.
        public struct DeploymentBranchPolicySettings: Codable, Hashable, Sendable {
            /// Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-settings/protected_branches`.
            public var protectedBranches: Swift.Bool
            /// Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-settings/custom_branch_policies`.
            public var customBranchPolicies: Swift.Bool
            /// Creates a new `DeploymentBranchPolicySettings`.
            ///
            /// - Parameters:
            ///   - protectedBranches: Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.
            ///   - customBranchPolicies: Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.
            public init(
                protectedBranches: Swift.Bool,
                customBranchPolicies: Swift.Bool
            ) {
                self.protectedBranches = protectedBranches
                self.customBranchPolicies = customBranchPolicies
            }
            public enum CodingKeys: String, CodingKey {
                case protectedBranches = "protected_branches"
                case customBranchPolicies = "custom_branch_policies"
            }
        }
        /// Details of a deployment environment
        ///
        /// - Remark: Generated from `#/components/schemas/environment`.
        public struct Environment: Codable, Hashable, Sendable {
            /// The id of the environment.
            ///
            /// - Remark: Generated from `#/components/schemas/environment/id`.
            public var id: Swift.Int64
            /// - Remark: Generated from `#/components/schemas/environment/node_id`.
            public var nodeId: Swift.String
            /// The name of the environment.
            ///
            /// - Remark: Generated from `#/components/schemas/environment/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/environment/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/environment/html_url`.
            public var htmlUrl: Swift.String
            /// The time that the environment was created, in ISO 8601 format.
            ///
            /// - Remark: Generated from `#/components/schemas/environment/created_at`.
            public var createdAt: Foundation.Date
            /// The time that the environment was last updated, in ISO 8601 format.
            ///
            /// - Remark: Generated from `#/components/schemas/environment/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload`.
            public struct ProtectionRulesPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value1`.
                public struct Value1Payload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value1/id`.
                    public var id: Swift.Int
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value1/node_id`.
                    public var nodeId: Swift.String
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value1/type`.
                    public var _type: Swift.String
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value1/wait_timer`.
                    public var waitTimer: Components.Schemas.WaitTimer?
                    /// Creates a new `Value1Payload`.
                    ///
                    /// - Parameters:
                    ///   - id:
                    ///   - nodeId:
                    ///   - _type:
                    ///   - waitTimer:
                    public init(
                        id: Swift.Int,
                        nodeId: Swift.String,
                        _type: Swift.String,
                        waitTimer: Components.Schemas.WaitTimer? = nil
                    ) {
                        self.id = id
                        self.nodeId = nodeId
                        self._type = _type
                        self.waitTimer = waitTimer
                    }
                    public enum CodingKeys: String, CodingKey {
                        case id
                        case nodeId = "node_id"
                        case _type = "type"
                        case waitTimer = "wait_timer"
                    }
                }
                /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value1`.
                public var value1: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value1Payload?
                /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2`.
                public struct Value2Payload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/id`.
                    public var id: Swift.Int
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/node_id`.
                    public var nodeId: Swift.String
                    /// Whether deployments to this environment can be approved by the user who created the deployment.
                    ///
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/prevent_self_review`.
                    public var preventSelfReview: Swift.Bool?
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/type`.
                    public var _type: Swift.String
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/ReviewersPayload`.
                    public struct ReviewersPayloadPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/ReviewersPayload/type`.
                        public var _type: Components.Schemas.DeploymentReviewerType?
                        /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/ReviewersPayload/reviewer`.
                        public struct ReviewerPayload: Codable, Hashable, Sendable {
                            /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/ReviewersPayload/reviewer/value1`.
                            public var value1: Components.Schemas.SimpleUser?
                            /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/ReviewersPayload/reviewer/value2`.
                            public var value2: Components.Schemas.Team?
                            /// Creates a new `ReviewerPayload`.
                            ///
                            /// - Parameters:
                            ///   - value1:
                            ///   - value2:
                            public init(
                                value1: Components.Schemas.SimpleUser? = nil,
                                value2: Components.Schemas.Team? = nil
                            ) {
                                self.value1 = value1
                                self.value2 = value2
                            }
                            public init(from decoder: any Decoder) throws {
                                var errors: [any Error] = []
                                do {
                                    self.value1 = try .init(from: decoder)
                                } catch {
                                    errors.append(error)
                                }
                                do {
                                    self.value2 = try .init(from: decoder)
                                } catch {
                                    errors.append(error)
                                }
                                try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                                    [
                                        self.value1,
                                        self.value2
                                    ],
                                    type: Self.self,
                                    codingPath: decoder.codingPath,
                                    errors: errors
                                )
                            }
                            public func encode(to encoder: any Encoder) throws {
                                try self.value1?.encode(to: encoder)
                                try self.value2?.encode(to: encoder)
                            }
                        }
                        /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/ReviewersPayload/reviewer`.
                        public var reviewer: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value2Payload.ReviewersPayloadPayload.ReviewerPayload?
                        /// Creates a new `ReviewersPayloadPayload`.
                        ///
                        /// - Parameters:
                        ///   - _type:
                        ///   - reviewer:
                        public init(
                            _type: Components.Schemas.DeploymentReviewerType? = nil,
                            reviewer: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value2Payload.ReviewersPayloadPayload.ReviewerPayload? = nil
                        ) {
                            self._type = _type
                            self.reviewer = reviewer
                        }
                        public enum CodingKeys: String, CodingKey {
                            case _type = "type"
                            case reviewer
                        }
                    }
                    /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
                    ///
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/reviewers`.
                    public typealias ReviewersPayload = [Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value2Payload.ReviewersPayloadPayload]
                    /// The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
                    ///
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2/reviewers`.
                    public var reviewers: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value2Payload.ReviewersPayload?
                    /// Creates a new `Value2Payload`.
                    ///
                    /// - Parameters:
                    ///   - id:
                    ///   - nodeId:
                    ///   - preventSelfReview: Whether deployments to this environment can be approved by the user who created the deployment.
                    ///   - _type:
                    ///   - reviewers: The people or teams that may approve jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
                    public init(
                        id: Swift.Int,
                        nodeId: Swift.String,
                        preventSelfReview: Swift.Bool? = nil,
                        _type: Swift.String,
                        reviewers: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value2Payload.ReviewersPayload? = nil
                    ) {
                        self.id = id
                        self.nodeId = nodeId
                        self.preventSelfReview = preventSelfReview
                        self._type = _type
                        self.reviewers = reviewers
                    }
                    public enum CodingKeys: String, CodingKey {
                        case id
                        case nodeId = "node_id"
                        case preventSelfReview = "prevent_self_review"
                        case _type = "type"
                        case reviewers
                    }
                }
                /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value2`.
                public var value2: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value2Payload?
                /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value3`.
                public struct Value3Payload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value3/id`.
                    public var id: Swift.Int
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value3/node_id`.
                    public var nodeId: Swift.String
                    /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value3/type`.
                    public var _type: Swift.String
                    /// Creates a new `Value3Payload`.
                    ///
                    /// - Parameters:
                    ///   - id:
                    ///   - nodeId:
                    ///   - _type:
                    public init(
                        id: Swift.Int,
                        nodeId: Swift.String,
                        _type: Swift.String
                    ) {
                        self.id = id
                        self.nodeId = nodeId
                        self._type = _type
                    }
                    public enum CodingKeys: String, CodingKey {
                        case id
                        case nodeId = "node_id"
                        case _type = "type"
                    }
                }
                /// - Remark: Generated from `#/components/schemas/environment/ProtectionRulesPayload/value3`.
                public var value3: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value3Payload?
                /// Creates a new `ProtectionRulesPayloadPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                ///   - value3:
                public init(
                    value1: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value1Payload? = nil,
                    value2: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value2Payload? = nil,
                    value3: Components.Schemas.Environment.ProtectionRulesPayloadPayload.Value3Payload? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                    self.value3 = value3
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self.value1 = try .init(from: decoder)
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self.value2 = try .init(from: decoder)
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self.value3 = try .init(from: decoder)
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            self.value1,
                            self.value2,
                            self.value3
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1?.encode(to: encoder)
                    try self.value2?.encode(to: encoder)
                    try self.value3?.encode(to: encoder)
                }
            }
            /// Built-in deployment protection rules for the environment.
            ///
            /// - Remark: Generated from `#/components/schemas/environment/protection_rules`.
            public typealias ProtectionRulesPayload = [Components.Schemas.Environment.ProtectionRulesPayloadPayload]
            /// Built-in deployment protection rules for the environment.
            ///
            /// - Remark: Generated from `#/components/schemas/environment/protection_rules`.
            public var protectionRules: Components.Schemas.Environment.ProtectionRulesPayload?
            /// - Remark: Generated from `#/components/schemas/environment/deployment_branch_policy`.
            public var deploymentBranchPolicy: Components.Schemas.DeploymentBranchPolicySettings?
            /// Creates a new `Environment`.
            ///
            /// - Parameters:
            ///   - id: The id of the environment.
            ///   - nodeId:
            ///   - name: The name of the environment.
            ///   - url:
            ///   - htmlUrl:
            ///   - createdAt: The time that the environment was created, in ISO 8601 format.
            ///   - updatedAt: The time that the environment was last updated, in ISO 8601 format.
            ///   - protectionRules: Built-in deployment protection rules for the environment.
            ///   - deploymentBranchPolicy:
            public init(
                id: Swift.Int64,
                nodeId: Swift.String,
                name: Swift.String,
                url: Swift.String,
                htmlUrl: Swift.String,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                protectionRules: Components.Schemas.Environment.ProtectionRulesPayload? = nil,
                deploymentBranchPolicy: Components.Schemas.DeploymentBranchPolicySettings? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.url = url
                self.htmlUrl = htmlUrl
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.protectionRules = protectionRules
                self.deploymentBranchPolicy = deploymentBranchPolicy
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case name
                case url
                case htmlUrl = "html_url"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case protectionRules = "protection_rules"
                case deploymentBranchPolicy = "deployment_branch_policy"
            }
        }
        /// Whether or not a user who created the job is prevented from approving their own job.
        ///
        /// - Remark: Generated from `#/components/schemas/prevent-self-review`.
        public typealias PreventSelfReview = Swift.Bool
        /// Details of a deployment branch or tag policy.
        ///
        /// - Remark: Generated from `#/components/schemas/deployment-branch-policy`.
        public struct DeploymentBranchPolicy: Codable, Hashable, Sendable {
            /// The unique identifier of the branch or tag policy.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy/id`.
            public var id: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy/node_id`.
            public var nodeId: Swift.String?
            /// The name pattern that branches or tags must match in order to deploy to the environment.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy/name`.
            public var name: Swift.String?
            /// Whether this rule targets a branch or tag.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case branch = "branch"
                case tag = "tag"
            }
            /// Whether this rule targets a branch or tag.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy/type`.
            public var _type: Components.Schemas.DeploymentBranchPolicy._TypePayload?
            /// Creates a new `DeploymentBranchPolicy`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of the branch or tag policy.
            ///   - nodeId:
            ///   - name: The name pattern that branches or tags must match in order to deploy to the environment.
            ///   - _type: Whether this rule targets a branch or tag.
            public init(
                id: Swift.Int? = nil,
                nodeId: Swift.String? = nil,
                name: Swift.String? = nil,
                _type: Components.Schemas.DeploymentBranchPolicy._TypePayload? = nil
            ) {
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case name
                case _type = "type"
            }
        }
        /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-name-pattern-with-type`.
        public struct DeploymentBranchPolicyNamePatternWithType: Codable, Hashable, Sendable {
            /// The name pattern that branches or tags must match in order to deploy to the environment.
            ///
            /// Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.
            /// For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-name-pattern-with-type/name`.
            public var name: Swift.String
            /// Whether this rule targets a branch or tag
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-name-pattern-with-type/type`.
            @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case branch = "branch"
                case tag = "tag"
            }
            /// Whether this rule targets a branch or tag
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-name-pattern-with-type/type`.
            public var _type: Components.Schemas.DeploymentBranchPolicyNamePatternWithType._TypePayload?
            /// Creates a new `DeploymentBranchPolicyNamePatternWithType`.
            ///
            /// - Parameters:
            ///   - name: The name pattern that branches or tags must match in order to deploy to the environment.
            ///   - _type: Whether this rule targets a branch or tag
            public init(
                name: Swift.String,
                _type: Components.Schemas.DeploymentBranchPolicyNamePatternWithType._TypePayload? = nil
            ) {
                self.name = name
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case _type = "type"
            }
        }
        /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-name-pattern`.
        public struct DeploymentBranchPolicyNamePattern: Codable, Hashable, Sendable {
            /// The name pattern that branches must match in order to deploy to the environment.
            ///
            /// Wildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.
            /// For more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-branch-policy-name-pattern/name`.
            public var name: Swift.String
            /// Creates a new `DeploymentBranchPolicyNamePattern`.
            ///
            /// - Parameters:
            ///   - name: The name pattern that branches must match in order to deploy to the environment.
            public init(name: Swift.String) {
                self.name = name
            }
            public enum CodingKeys: String, CodingKey {
                case name
            }
        }
        /// A GitHub App that is providing a custom deployment protection rule.
        ///
        /// - Remark: Generated from `#/components/schemas/custom-deployment-rule-app`.
        public struct CustomDeploymentRuleApp: Codable, Hashable, Sendable {
            /// The unique identifier of the deployment protection rule integration.
            ///
            /// - Remark: Generated from `#/components/schemas/custom-deployment-rule-app/id`.
            public var id: Swift.Int
            /// The slugified name of the deployment protection rule integration.
            ///
            /// - Remark: Generated from `#/components/schemas/custom-deployment-rule-app/slug`.
            public var slug: Swift.String
            /// The URL for the endpoint to get details about the app.
            ///
            /// - Remark: Generated from `#/components/schemas/custom-deployment-rule-app/integration_url`.
            public var integrationUrl: Swift.String
            /// The node ID for the deployment protection rule integration.
            ///
            /// - Remark: Generated from `#/components/schemas/custom-deployment-rule-app/node_id`.
            public var nodeId: Swift.String
            /// Creates a new `CustomDeploymentRuleApp`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier of the deployment protection rule integration.
            ///   - slug: The slugified name of the deployment protection rule integration.
            ///   - integrationUrl: The URL for the endpoint to get details about the app.
            ///   - nodeId: The node ID for the deployment protection rule integration.
            public init(
                id: Swift.Int,
                slug: Swift.String,
                integrationUrl: Swift.String,
                nodeId: Swift.String
            ) {
                self.id = id
                self.slug = slug
                self.integrationUrl = integrationUrl
                self.nodeId = nodeId
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case slug
                case integrationUrl = "integration_url"
                case nodeId = "node_id"
            }
        }
        /// Deployment protection rule
        ///
        /// - Remark: Generated from `#/components/schemas/deployment-protection-rule`.
        public struct DeploymentProtectionRule: Codable, Hashable, Sendable {
            /// The unique identifier for the deployment protection rule.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-protection-rule/id`.
            public var id: Swift.Int
            /// The node ID for the deployment protection rule.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-protection-rule/node_id`.
            public var nodeId: Swift.String
            /// Whether the deployment protection rule is enabled for the environment.
            ///
            /// - Remark: Generated from `#/components/schemas/deployment-protection-rule/enabled`.
            public var enabled: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/deployment-protection-rule/app`.
            public var app: Components.Schemas.CustomDeploymentRuleApp
            /// Creates a new `DeploymentProtectionRule`.
            ///
            /// - Parameters:
            ///   - id: The unique identifier for the deployment protection rule.
            ///   - nodeId: The node ID for the deployment protection rule.
            ///   - enabled: Whether the deployment protection rule is enabled for the environment.
            ///   - app:
            public init(
                id: Swift.Int,
                nodeId: Swift.String,
                enabled: Swift.Bool,
                app: Components.Schemas.CustomDeploymentRuleApp
            ) {
                self.id = id
                self.nodeId = nodeId
                self.enabled = enabled
                self.app = app
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case nodeId = "node_id"
                case enabled
                case app
            }
        }
        /// - Remark: Generated from `#/components/schemas/hook-response`.
        public struct HookResponse: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/hook-response/code`.
            public var code: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/hook-response/status`.
            public var status: Swift.String?
            /// - Remark: Generated from `#/components/schemas/hook-response/message`.
            public var message: Swift.String?
            /// Creates a new `HookResponse`.
            ///
            /// - Parameters:
            ///   - code:
            ///   - status:
            ///   - message:
            public init(
                code: Swift.Int? = nil,
                status: Swift.String? = nil,
                message: Swift.String? = nil
            ) {
                self.code = code
                self.status = status
                self.message = message
            }
            public enum CodingKeys: String, CodingKey {
                case code
                case status
                case message
            }
        }
        /// Webhooks for repositories.
        ///
        /// - Remark: Generated from `#/components/schemas/hook`.
        public struct Hook: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/hook/type`.
            public var _type: Swift.String
            /// Unique identifier of the webhook.
            ///
            /// - Remark: Generated from `#/components/schemas/hook/id`.
            public var id: Swift.Int
            /// The name of a valid service, use 'web' for a webhook.
            ///
            /// - Remark: Generated from `#/components/schemas/hook/name`.
            public var name: Swift.String
            /// Determines whether the hook is actually triggered on pushes.
            ///
            /// - Remark: Generated from `#/components/schemas/hook/active`.
            public var active: Swift.Bool
            /// Determines what events the hook is triggered for. Default: ['push'].
            ///
            /// - Remark: Generated from `#/components/schemas/hook/events`.
            public var events: [Swift.String]
            /// - Remark: Generated from `#/components/schemas/hook/config`.
            public var config: Components.Schemas.WebhookConfig
            /// - Remark: Generated from `#/components/schemas/hook/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/hook/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/hook/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/hook/test_url`.
            public var testUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/hook/ping_url`.
            public var pingUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/hook/deliveries_url`.
            public var deliveriesUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/hook/last_response`.
            public var lastResponse: Components.Schemas.HookResponse
            /// Creates a new `Hook`.
            ///
            /// - Parameters:
            ///   - _type:
            ///   - id: Unique identifier of the webhook.
            ///   - name: The name of a valid service, use 'web' for a webhook.
            ///   - active: Determines whether the hook is actually triggered on pushes.
            ///   - events: Determines what events the hook is triggered for. Default: ['push'].
            ///   - config:
            ///   - updatedAt:
            ///   - createdAt:
            ///   - url:
            ///   - testUrl:
            ///   - pingUrl:
            ///   - deliveriesUrl:
            ///   - lastResponse:
            public init(
                _type: Swift.String,
                id: Swift.Int,
                name: Swift.String,
                active: Swift.Bool,
                events: [Swift.String],
                config: Components.Schemas.WebhookConfig,
                updatedAt: Foundation.Date,
                createdAt: Foundation.Date,
                url: Swift.String,
                testUrl: Swift.String,
                pingUrl: Swift.String,
                deliveriesUrl: Swift.String? = nil,
                lastResponse: Components.Schemas.HookResponse
            ) {
                self._type = _type
                self.id = id
                self.name = name
                self.active = active
                self.events = events
                self.config = config
                self.updatedAt = updatedAt
                self.createdAt = createdAt
                self.url = url
                self.testUrl = testUrl
                self.pingUrl = pingUrl
                self.deliveriesUrl = deliveriesUrl
                self.lastResponse = lastResponse
            }
            public enum CodingKeys: String, CodingKey {
                case _type = "type"
                case id
                case name
                case active
                case events
                case config
                case updatedAt = "updated_at"
                case createdAt = "created_at"
                case url
                case testUrl = "test_url"
                case pingUrl = "ping_url"
                case deliveriesUrl = "deliveries_url"
                case lastResponse = "last_response"
            }
        }
        /// An SSH key granting access to a single repository.
        ///
        /// - Remark: Generated from `#/components/schemas/deploy-key`.
        public struct DeployKey: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/deploy-key/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/deploy-key/key`.
            public var key: Swift.String
            /// - Remark: Generated from `#/components/schemas/deploy-key/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/deploy-key/title`.
            public var title: Swift.String
            /// - Remark: Generated from `#/components/schemas/deploy-key/verified`.
            public var verified: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/deploy-key/created_at`.
            public var createdAt: Swift.String
            /// - Remark: Generated from `#/components/schemas/deploy-key/read_only`.
            public var readOnly: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/deploy-key/added_by`.
            public var addedBy: Swift.String?
            /// - Remark: Generated from `#/components/schemas/deploy-key/last_used`.
            public var lastUsed: Swift.String?
            /// - Remark: Generated from `#/components/schemas/deploy-key/enabled`.
            public var enabled: Swift.Bool?
            /// Creates a new `DeployKey`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - key:
            ///   - url:
            ///   - title:
            ///   - verified:
            ///   - createdAt:
            ///   - readOnly:
            ///   - addedBy:
            ///   - lastUsed:
            ///   - enabled:
            public init(
                id: Swift.Int,
                key: Swift.String,
                url: Swift.String,
                title: Swift.String,
                verified: Swift.Bool,
                createdAt: Swift.String,
                readOnly: Swift.Bool,
                addedBy: Swift.String? = nil,
                lastUsed: Swift.String? = nil,
                enabled: Swift.Bool? = nil
            ) {
                self.id = id
                self.key = key
                self.url = url
                self.title = title
                self.verified = verified
                self.createdAt = createdAt
                self.readOnly = readOnly
                self.addedBy = addedBy
                self.lastUsed = lastUsed
                self.enabled = enabled
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case key
                case url
                case title
                case verified
                case createdAt = "created_at"
                case readOnly = "read_only"
                case addedBy = "added_by"
                case lastUsed = "last_used"
                case enabled
            }
        }
        /// Language
        ///
        /// - Remark: Generated from `#/components/schemas/language`.
        public struct Language: Codable, Hashable, Sendable {
            /// A container of undocumented properties.
            public var additionalProperties: [String: Swift.Int]
            /// Creates a new `Language`.
            ///
            /// - Parameters:
            ///   - additionalProperties: A container of undocumented properties.
            public init(additionalProperties: [String: Swift.Int] = .init()) {
                self.additionalProperties = additionalProperties
            }
            public init(from decoder: any Decoder) throws {
                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
            }
            public func encode(to encoder: any Encoder) throws {
                try encoder.encodeAdditionalProperties(additionalProperties)
            }
        }
        /// Results of a successful merge upstream request
        ///
        /// - Remark: Generated from `#/components/schemas/merged-upstream`.
        public struct MergedUpstream: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/merged-upstream/message`.
            public var message: Swift.String?
            /// - Remark: Generated from `#/components/schemas/merged-upstream/merge_type`.
            @frozen public enum MergeTypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case merge = "merge"
                case fastForward = "fast-forward"
                case none = "none"
            }
            /// - Remark: Generated from `#/components/schemas/merged-upstream/merge_type`.
            public var mergeType: Components.Schemas.MergedUpstream.MergeTypePayload?
            /// - Remark: Generated from `#/components/schemas/merged-upstream/base_branch`.
            public var baseBranch: Swift.String?
            /// Creates a new `MergedUpstream`.
            ///
            /// - Parameters:
            ///   - message:
            ///   - mergeType:
            ///   - baseBranch:
            public init(
                message: Swift.String? = nil,
                mergeType: Components.Schemas.MergedUpstream.MergeTypePayload? = nil,
                baseBranch: Swift.String? = nil
            ) {
                self.message = message
                self.mergeType = mergeType
                self.baseBranch = baseBranch
            }
            public enum CodingKeys: String, CodingKey {
                case message
                case mergeType = "merge_type"
                case baseBranch = "base_branch"
            }
        }
        /// - Remark: Generated from `#/components/schemas/pages-source-hash`.
        public struct PagesSourceHash: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/pages-source-hash/branch`.
            public var branch: Swift.String
            /// - Remark: Generated from `#/components/schemas/pages-source-hash/path`.
            public var path: Swift.String
            /// Creates a new `PagesSourceHash`.
            ///
            /// - Parameters:
            ///   - branch:
            ///   - path:
            public init(
                branch: Swift.String,
                path: Swift.String
            ) {
                self.branch = branch
                self.path = path
            }
            public enum CodingKeys: String, CodingKey {
                case branch
                case path
            }
        }
        /// - Remark: Generated from `#/components/schemas/pages-https-certificate`.
        public struct PagesHttpsCertificate: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/pages-https-certificate/state`.
            @frozen public enum StatePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case new = "new"
                case authorizationCreated = "authorization_created"
                case authorizationPending = "authorization_pending"
                case authorized = "authorized"
                case authorizationRevoked = "authorization_revoked"
                case issued = "issued"
                case uploaded = "uploaded"
                case approved = "approved"
                case errored = "errored"
                case badAuthz = "bad_authz"
                case destroyPending = "destroy_pending"
                case dnsChanged = "dns_changed"
            }
            /// - Remark: Generated from `#/components/schemas/pages-https-certificate/state`.
            public var state: Components.Schemas.PagesHttpsCertificate.StatePayload
            /// - Remark: Generated from `#/components/schemas/pages-https-certificate/description`.
            public var description: Swift.String
            /// Array of the domain set and its alternate name (if it is configured)
            ///
            /// - Remark: Generated from `#/components/schemas/pages-https-certificate/domains`.
            public var domains: [Swift.String]
            /// - Remark: Generated from `#/components/schemas/pages-https-certificate/expires_at`.
            public var expiresAt: Swift.String?
            /// Creates a new `PagesHttpsCertificate`.
            ///
            /// - Parameters:
            ///   - state:
            ///   - description:
            ///   - domains: Array of the domain set and its alternate name (if it is configured)
            ///   - expiresAt:
            public init(
                state: Components.Schemas.PagesHttpsCertificate.StatePayload,
                description: Swift.String,
                domains: [Swift.String],
                expiresAt: Swift.String? = nil
            ) {
                self.state = state
                self.description = description
                self.domains = domains
                self.expiresAt = expiresAt
            }
            public enum CodingKeys: String, CodingKey {
                case state
                case description
                case domains
                case expiresAt = "expires_at"
            }
        }
        /// The configuration for GitHub Pages for a repository.
        ///
        /// - Remark: Generated from `#/components/schemas/page`.
        public struct Page: Codable, Hashable, Sendable {
            /// The API address for accessing this Page resource.
            ///
            /// - Remark: Generated from `#/components/schemas/page/url`.
            public var url: Swift.String
            /// The status of the most recent build of the Page.
            ///
            /// - Remark: Generated from `#/components/schemas/page/status`.
            @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case built = "built"
                case building = "building"
                case errored = "errored"
            }
            /// The status of the most recent build of the Page.
            ///
            /// - Remark: Generated from `#/components/schemas/page/status`.
            public var status: Components.Schemas.Page.StatusPayload?
            /// The Pages site's custom domain
            ///
            /// - Remark: Generated from `#/components/schemas/page/cname`.
            public var cname: Swift.String?
            /// The state if the domain is verified
            ///
            /// - Remark: Generated from `#/components/schemas/page/protected_domain_state`.
            @frozen public enum ProtectedDomainStatePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case pending = "pending"
                case verified = "verified"
                case unverified = "unverified"
            }
            /// The state if the domain is verified
            ///
            /// - Remark: Generated from `#/components/schemas/page/protected_domain_state`.
            public var protectedDomainState: Components.Schemas.Page.ProtectedDomainStatePayload?
            /// The timestamp when a pending domain becomes unverified.
            ///
            /// - Remark: Generated from `#/components/schemas/page/pending_domain_unverified_at`.
            public var pendingDomainUnverifiedAt: Foundation.Date?
            /// Whether the Page has a custom 404 page.
            ///
            /// - Remark: Generated from `#/components/schemas/page/custom_404`.
            public var custom404: Swift.Bool
            /// The web address the Page can be accessed from.
            ///
            /// - Remark: Generated from `#/components/schemas/page/html_url`.
            public var htmlUrl: Swift.String?
            /// The process in which the Page will be built.
            ///
            /// - Remark: Generated from `#/components/schemas/page/build_type`.
            @frozen public enum BuildTypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case legacy = "legacy"
                case workflow = "workflow"
            }
            /// The process in which the Page will be built.
            ///
            /// - Remark: Generated from `#/components/schemas/page/build_type`.
            public var buildType: Components.Schemas.Page.BuildTypePayload?
            /// - Remark: Generated from `#/components/schemas/page/source`.
            public var source: Components.Schemas.PagesSourceHash?
            /// Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.
            ///
            /// - Remark: Generated from `#/components/schemas/page/public`.
            public var _public: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/page/https_certificate`.
            public var httpsCertificate: Components.Schemas.PagesHttpsCertificate?
            /// Whether https is enabled on the domain
            ///
            /// - Remark: Generated from `#/components/schemas/page/https_enforced`.
            public var httpsEnforced: Swift.Bool?
            /// Creates a new `Page`.
            ///
            /// - Parameters:
            ///   - url: The API address for accessing this Page resource.
            ///   - status: The status of the most recent build of the Page.
            ///   - cname: The Pages site's custom domain
            ///   - protectedDomainState: The state if the domain is verified
            ///   - pendingDomainUnverifiedAt: The timestamp when a pending domain becomes unverified.
            ///   - custom404: Whether the Page has a custom 404 page.
            ///   - htmlUrl: The web address the Page can be accessed from.
            ///   - buildType: The process in which the Page will be built.
            ///   - source:
            ///   - _public: Whether the GitHub Pages site is publicly visible. If set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site.
            ///   - httpsCertificate:
            ///   - httpsEnforced: Whether https is enabled on the domain
            public init(
                url: Swift.String,
                status: Components.Schemas.Page.StatusPayload? = nil,
                cname: Swift.String? = nil,
                protectedDomainState: Components.Schemas.Page.ProtectedDomainStatePayload? = nil,
                pendingDomainUnverifiedAt: Foundation.Date? = nil,
                custom404: Swift.Bool,
                htmlUrl: Swift.String? = nil,
                buildType: Components.Schemas.Page.BuildTypePayload? = nil,
                source: Components.Schemas.PagesSourceHash? = nil,
                _public: Swift.Bool,
                httpsCertificate: Components.Schemas.PagesHttpsCertificate? = nil,
                httpsEnforced: Swift.Bool? = nil
            ) {
                self.url = url
                self.status = status
                self.cname = cname
                self.protectedDomainState = protectedDomainState
                self.pendingDomainUnverifiedAt = pendingDomainUnverifiedAt
                self.custom404 = custom404
                self.htmlUrl = htmlUrl
                self.buildType = buildType
                self.source = source
                self._public = _public
                self.httpsCertificate = httpsCertificate
                self.httpsEnforced = httpsEnforced
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case status
                case cname
                case protectedDomainState = "protected_domain_state"
                case pendingDomainUnverifiedAt = "pending_domain_unverified_at"
                case custom404 = "custom_404"
                case htmlUrl = "html_url"
                case buildType = "build_type"
                case source
                case _public = "public"
                case httpsCertificate = "https_certificate"
                case httpsEnforced = "https_enforced"
            }
        }
        /// Page Build
        ///
        /// - Remark: Generated from `#/components/schemas/page-build`.
        public struct PageBuild: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/page-build/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/page-build/status`.
            public var status: Swift.String
            /// - Remark: Generated from `#/components/schemas/page-build/error`.
            public struct _ErrorPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/page-build/error/message`.
                public var message: Swift.String?
                /// Creates a new `_ErrorPayload`.
                ///
                /// - Parameters:
                ///   - message:
                public init(message: Swift.String? = nil) {
                    self.message = message
                }
                public enum CodingKeys: String, CodingKey {
                    case message
                }
            }
            /// - Remark: Generated from `#/components/schemas/page-build/error`.
            public var error: Components.Schemas.PageBuild._ErrorPayload
            /// - Remark: Generated from `#/components/schemas/page-build/pusher`.
            public var pusher: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/page-build/commit`.
            public var commit: Swift.String
            /// - Remark: Generated from `#/components/schemas/page-build/duration`.
            public var duration: Swift.Int
            /// - Remark: Generated from `#/components/schemas/page-build/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/page-build/updated_at`.
            public var updatedAt: Foundation.Date
            /// Creates a new `PageBuild`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - status:
            ///   - error:
            ///   - pusher:
            ///   - commit:
            ///   - duration:
            ///   - createdAt:
            ///   - updatedAt:
            public init(
                url: Swift.String,
                status: Swift.String,
                error: Components.Schemas.PageBuild._ErrorPayload,
                pusher: Components.Schemas.NullableSimpleUser? = nil,
                commit: Swift.String,
                duration: Swift.Int,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date
            ) {
                self.url = url
                self.status = status
                self.error = error
                self.pusher = pusher
                self.commit = commit
                self.duration = duration
                self.createdAt = createdAt
                self.updatedAt = updatedAt
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case status
                case error
                case pusher
                case commit
                case duration
                case createdAt = "created_at"
                case updatedAt = "updated_at"
            }
        }
        /// Page Build Status
        ///
        /// - Remark: Generated from `#/components/schemas/page-build-status`.
        public struct PageBuildStatus: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/page-build-status/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/page-build-status/status`.
            public var status: Swift.String
            /// Creates a new `PageBuildStatus`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - status:
            public init(
                url: Swift.String,
                status: Swift.String
            ) {
                self.url = url
                self.status = status
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case status
            }
        }
        /// The GitHub Pages deployment status.
        ///
        /// - Remark: Generated from `#/components/schemas/page-deployment`.
        public struct PageDeployment: Codable, Hashable, Sendable {
            /// The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit.
            ///
            /// - Remark: Generated from `#/components/schemas/page-deployment/id`.
            @frozen public enum IdPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/page-deployment/id/case1`.
                case case1(Swift.Int)
                /// - Remark: Generated from `#/components/schemas/page-deployment/id/case2`.
                case case2(Swift.String)
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self = .case1(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self = .case2(try decoder.decodeFromSingleValueContainer())
                        return
                    } catch {
                        errors.append(error)
                    }
                    throw Swift.DecodingError.failedToDecodeOneOfSchema(
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    switch self {
                    case let .case1(value):
                        try encoder.encodeToSingleValueContainer(value)
                    case let .case2(value):
                        try encoder.encodeToSingleValueContainer(value)
                    }
                }
            }
            /// The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit.
            ///
            /// - Remark: Generated from `#/components/schemas/page-deployment/id`.
            public var id: Components.Schemas.PageDeployment.IdPayload
            /// The URI to monitor GitHub Pages deployment status.
            ///
            /// - Remark: Generated from `#/components/schemas/page-deployment/status_url`.
            public var statusUrl: Swift.String
            /// The URI to the deployed GitHub Pages.
            ///
            /// - Remark: Generated from `#/components/schemas/page-deployment/page_url`.
            public var pageUrl: Swift.String
            /// The URI to the deployed GitHub Pages preview.
            ///
            /// - Remark: Generated from `#/components/schemas/page-deployment/preview_url`.
            public var previewUrl: Swift.String?
            /// Creates a new `PageDeployment`.
            ///
            /// - Parameters:
            ///   - id: The ID of the GitHub Pages deployment. This is the Git SHA of the deployed commit.
            ///   - statusUrl: The URI to monitor GitHub Pages deployment status.
            ///   - pageUrl: The URI to the deployed GitHub Pages.
            ///   - previewUrl: The URI to the deployed GitHub Pages preview.
            public init(
                id: Components.Schemas.PageDeployment.IdPayload,
                statusUrl: Swift.String,
                pageUrl: Swift.String,
                previewUrl: Swift.String? = nil
            ) {
                self.id = id
                self.statusUrl = statusUrl
                self.pageUrl = pageUrl
                self.previewUrl = previewUrl
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case statusUrl = "status_url"
                case pageUrl = "page_url"
                case previewUrl = "preview_url"
            }
        }
        /// - Remark: Generated from `#/components/schemas/pages-deployment-status`.
        public struct PagesDeploymentStatus: Codable, Hashable, Sendable {
            /// The current status of the deployment.
            ///
            /// - Remark: Generated from `#/components/schemas/pages-deployment-status/status`.
            @frozen public enum StatusPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case deploymentInProgress = "deployment_in_progress"
                case syncingFiles = "syncing_files"
                case finishedFileSync = "finished_file_sync"
                case updatingPages = "updating_pages"
                case purgingCdn = "purging_cdn"
                case deploymentCancelled = "deployment_cancelled"
                case deploymentFailed = "deployment_failed"
                case deploymentContentFailed = "deployment_content_failed"
                case deploymentAttemptError = "deployment_attempt_error"
                case deploymentLost = "deployment_lost"
                case succeed = "succeed"
            }
            /// The current status of the deployment.
            ///
            /// - Remark: Generated from `#/components/schemas/pages-deployment-status/status`.
            public var status: Components.Schemas.PagesDeploymentStatus.StatusPayload?
            /// Creates a new `PagesDeploymentStatus`.
            ///
            /// - Parameters:
            ///   - status: The current status of the deployment.
            public init(status: Components.Schemas.PagesDeploymentStatus.StatusPayload? = nil) {
                self.status = status
            }
            public enum CodingKeys: String, CodingKey {
                case status
            }
        }
        /// Pages Health Check Status
        ///
        /// - Remark: Generated from `#/components/schemas/pages-health-check`.
        public struct PagesHealthCheck: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/pages-health-check/domain`.
            public struct DomainPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/host`.
                public var host: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/uri`.
                public var uri: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/nameservers`.
                public var nameservers: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/dns_resolves`.
                public var dnsResolves: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_proxied`.
                public var isProxied: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_cloudflare_ip`.
                public var isCloudflareIp: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_fastly_ip`.
                public var isFastlyIp: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_old_ip_address`.
                public var isOldIpAddress: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_a_record`.
                public var isARecord: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/has_cname_record`.
                public var hasCnameRecord: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/has_mx_records_present`.
                public var hasMxRecordsPresent: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_valid_domain`.
                public var isValidDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_apex_domain`.
                public var isApexDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/should_be_a_record`.
                public var shouldBeARecord: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_cname_to_github_user_domain`.
                public var isCnameToGithubUserDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_cname_to_pages_dot_github_dot_com`.
                public var isCnameToPagesDotGithubDotCom: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_cname_to_fastly`.
                public var isCnameToFastly: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_pointed_to_github_pages_ip`.
                public var isPointedToGithubPagesIp: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_non_github_pages_ip_present`.
                public var isNonGithubPagesIpPresent: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_pages_domain`.
                public var isPagesDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_served_by_pages`.
                public var isServedByPages: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_valid`.
                public var isValid: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/reason`.
                public var reason: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/responds_to_https`.
                public var respondsToHttps: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/enforces_https`.
                public var enforcesHttps: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/https_error`.
                public var httpsError: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/is_https_eligible`.
                public var isHttpsEligible: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/domain/caa_error`.
                public var caaError: Swift.String?
                /// Creates a new `DomainPayload`.
                ///
                /// - Parameters:
                ///   - host:
                ///   - uri:
                ///   - nameservers:
                ///   - dnsResolves:
                ///   - isProxied:
                ///   - isCloudflareIp:
                ///   - isFastlyIp:
                ///   - isOldIpAddress:
                ///   - isARecord:
                ///   - hasCnameRecord:
                ///   - hasMxRecordsPresent:
                ///   - isValidDomain:
                ///   - isApexDomain:
                ///   - shouldBeARecord:
                ///   - isCnameToGithubUserDomain:
                ///   - isCnameToPagesDotGithubDotCom:
                ///   - isCnameToFastly:
                ///   - isPointedToGithubPagesIp:
                ///   - isNonGithubPagesIpPresent:
                ///   - isPagesDomain:
                ///   - isServedByPages:
                ///   - isValid:
                ///   - reason:
                ///   - respondsToHttps:
                ///   - enforcesHttps:
                ///   - httpsError:
                ///   - isHttpsEligible:
                ///   - caaError:
                public init(
                    host: Swift.String? = nil,
                    uri: Swift.String? = nil,
                    nameservers: Swift.String? = nil,
                    dnsResolves: Swift.Bool? = nil,
                    isProxied: Swift.Bool? = nil,
                    isCloudflareIp: Swift.Bool? = nil,
                    isFastlyIp: Swift.Bool? = nil,
                    isOldIpAddress: Swift.Bool? = nil,
                    isARecord: Swift.Bool? = nil,
                    hasCnameRecord: Swift.Bool? = nil,
                    hasMxRecordsPresent: Swift.Bool? = nil,
                    isValidDomain: Swift.Bool? = nil,
                    isApexDomain: Swift.Bool? = nil,
                    shouldBeARecord: Swift.Bool? = nil,
                    isCnameToGithubUserDomain: Swift.Bool? = nil,
                    isCnameToPagesDotGithubDotCom: Swift.Bool? = nil,
                    isCnameToFastly: Swift.Bool? = nil,
                    isPointedToGithubPagesIp: Swift.Bool? = nil,
                    isNonGithubPagesIpPresent: Swift.Bool? = nil,
                    isPagesDomain: Swift.Bool? = nil,
                    isServedByPages: Swift.Bool? = nil,
                    isValid: Swift.Bool? = nil,
                    reason: Swift.String? = nil,
                    respondsToHttps: Swift.Bool? = nil,
                    enforcesHttps: Swift.Bool? = nil,
                    httpsError: Swift.String? = nil,
                    isHttpsEligible: Swift.Bool? = nil,
                    caaError: Swift.String? = nil
                ) {
                    self.host = host
                    self.uri = uri
                    self.nameservers = nameservers
                    self.dnsResolves = dnsResolves
                    self.isProxied = isProxied
                    self.isCloudflareIp = isCloudflareIp
                    self.isFastlyIp = isFastlyIp
                    self.isOldIpAddress = isOldIpAddress
                    self.isARecord = isARecord
                    self.hasCnameRecord = hasCnameRecord
                    self.hasMxRecordsPresent = hasMxRecordsPresent
                    self.isValidDomain = isValidDomain
                    self.isApexDomain = isApexDomain
                    self.shouldBeARecord = shouldBeARecord
                    self.isCnameToGithubUserDomain = isCnameToGithubUserDomain
                    self.isCnameToPagesDotGithubDotCom = isCnameToPagesDotGithubDotCom
                    self.isCnameToFastly = isCnameToFastly
                    self.isPointedToGithubPagesIp = isPointedToGithubPagesIp
                    self.isNonGithubPagesIpPresent = isNonGithubPagesIpPresent
                    self.isPagesDomain = isPagesDomain
                    self.isServedByPages = isServedByPages
                    self.isValid = isValid
                    self.reason = reason
                    self.respondsToHttps = respondsToHttps
                    self.enforcesHttps = enforcesHttps
                    self.httpsError = httpsError
                    self.isHttpsEligible = isHttpsEligible
                    self.caaError = caaError
                }
                public enum CodingKeys: String, CodingKey {
                    case host
                    case uri
                    case nameservers
                    case dnsResolves = "dns_resolves"
                    case isProxied = "is_proxied"
                    case isCloudflareIp = "is_cloudflare_ip"
                    case isFastlyIp = "is_fastly_ip"
                    case isOldIpAddress = "is_old_ip_address"
                    case isARecord = "is_a_record"
                    case hasCnameRecord = "has_cname_record"
                    case hasMxRecordsPresent = "has_mx_records_present"
                    case isValidDomain = "is_valid_domain"
                    case isApexDomain = "is_apex_domain"
                    case shouldBeARecord = "should_be_a_record"
                    case isCnameToGithubUserDomain = "is_cname_to_github_user_domain"
                    case isCnameToPagesDotGithubDotCom = "is_cname_to_pages_dot_github_dot_com"
                    case isCnameToFastly = "is_cname_to_fastly"
                    case isPointedToGithubPagesIp = "is_pointed_to_github_pages_ip"
                    case isNonGithubPagesIpPresent = "is_non_github_pages_ip_present"
                    case isPagesDomain = "is_pages_domain"
                    case isServedByPages = "is_served_by_pages"
                    case isValid = "is_valid"
                    case reason
                    case respondsToHttps = "responds_to_https"
                    case enforcesHttps = "enforces_https"
                    case httpsError = "https_error"
                    case isHttpsEligible = "is_https_eligible"
                    case caaError = "caa_error"
                }
            }
            /// - Remark: Generated from `#/components/schemas/pages-health-check/domain`.
            public var domain: Components.Schemas.PagesHealthCheck.DomainPayload?
            /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain`.
            public struct AltDomainPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/host`.
                public var host: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/uri`.
                public var uri: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/nameservers`.
                public var nameservers: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/dns_resolves`.
                public var dnsResolves: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_proxied`.
                public var isProxied: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_cloudflare_ip`.
                public var isCloudflareIp: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_fastly_ip`.
                public var isFastlyIp: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_old_ip_address`.
                public var isOldIpAddress: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_a_record`.
                public var isARecord: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/has_cname_record`.
                public var hasCnameRecord: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/has_mx_records_present`.
                public var hasMxRecordsPresent: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_valid_domain`.
                public var isValidDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_apex_domain`.
                public var isApexDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/should_be_a_record`.
                public var shouldBeARecord: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_cname_to_github_user_domain`.
                public var isCnameToGithubUserDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_cname_to_pages_dot_github_dot_com`.
                public var isCnameToPagesDotGithubDotCom: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_cname_to_fastly`.
                public var isCnameToFastly: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_pointed_to_github_pages_ip`.
                public var isPointedToGithubPagesIp: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_non_github_pages_ip_present`.
                public var isNonGithubPagesIpPresent: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_pages_domain`.
                public var isPagesDomain: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_served_by_pages`.
                public var isServedByPages: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_valid`.
                public var isValid: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/reason`.
                public var reason: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/responds_to_https`.
                public var respondsToHttps: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/enforces_https`.
                public var enforcesHttps: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/https_error`.
                public var httpsError: Swift.String?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/is_https_eligible`.
                public var isHttpsEligible: Swift.Bool?
                /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain/caa_error`.
                public var caaError: Swift.String?
                /// Creates a new `AltDomainPayload`.
                ///
                /// - Parameters:
                ///   - host:
                ///   - uri:
                ///   - nameservers:
                ///   - dnsResolves:
                ///   - isProxied:
                ///   - isCloudflareIp:
                ///   - isFastlyIp:
                ///   - isOldIpAddress:
                ///   - isARecord:
                ///   - hasCnameRecord:
                ///   - hasMxRecordsPresent:
                ///   - isValidDomain:
                ///   - isApexDomain:
                ///   - shouldBeARecord:
                ///   - isCnameToGithubUserDomain:
                ///   - isCnameToPagesDotGithubDotCom:
                ///   - isCnameToFastly:
                ///   - isPointedToGithubPagesIp:
                ///   - isNonGithubPagesIpPresent:
                ///   - isPagesDomain:
                ///   - isServedByPages:
                ///   - isValid:
                ///   - reason:
                ///   - respondsToHttps:
                ///   - enforcesHttps:
                ///   - httpsError:
                ///   - isHttpsEligible:
                ///   - caaError:
                public init(
                    host: Swift.String? = nil,
                    uri: Swift.String? = nil,
                    nameservers: Swift.String? = nil,
                    dnsResolves: Swift.Bool? = nil,
                    isProxied: Swift.Bool? = nil,
                    isCloudflareIp: Swift.Bool? = nil,
                    isFastlyIp: Swift.Bool? = nil,
                    isOldIpAddress: Swift.Bool? = nil,
                    isARecord: Swift.Bool? = nil,
                    hasCnameRecord: Swift.Bool? = nil,
                    hasMxRecordsPresent: Swift.Bool? = nil,
                    isValidDomain: Swift.Bool? = nil,
                    isApexDomain: Swift.Bool? = nil,
                    shouldBeARecord: Swift.Bool? = nil,
                    isCnameToGithubUserDomain: Swift.Bool? = nil,
                    isCnameToPagesDotGithubDotCom: Swift.Bool? = nil,
                    isCnameToFastly: Swift.Bool? = nil,
                    isPointedToGithubPagesIp: Swift.Bool? = nil,
                    isNonGithubPagesIpPresent: Swift.Bool? = nil,
                    isPagesDomain: Swift.Bool? = nil,
                    isServedByPages: Swift.Bool? = nil,
                    isValid: Swift.Bool? = nil,
                    reason: Swift.String? = nil,
                    respondsToHttps: Swift.Bool? = nil,
                    enforcesHttps: Swift.Bool? = nil,
                    httpsError: Swift.String? = nil,
                    isHttpsEligible: Swift.Bool? = nil,
                    caaError: Swift.String? = nil
                ) {
                    self.host = host
                    self.uri = uri
                    self.nameservers = nameservers
                    self.dnsResolves = dnsResolves
                    self.isProxied = isProxied
                    self.isCloudflareIp = isCloudflareIp
                    self.isFastlyIp = isFastlyIp
                    self.isOldIpAddress = isOldIpAddress
                    self.isARecord = isARecord
                    self.hasCnameRecord = hasCnameRecord
                    self.hasMxRecordsPresent = hasMxRecordsPresent
                    self.isValidDomain = isValidDomain
                    self.isApexDomain = isApexDomain
                    self.shouldBeARecord = shouldBeARecord
                    self.isCnameToGithubUserDomain = isCnameToGithubUserDomain
                    self.isCnameToPagesDotGithubDotCom = isCnameToPagesDotGithubDotCom
                    self.isCnameToFastly = isCnameToFastly
                    self.isPointedToGithubPagesIp = isPointedToGithubPagesIp
                    self.isNonGithubPagesIpPresent = isNonGithubPagesIpPresent
                    self.isPagesDomain = isPagesDomain
                    self.isServedByPages = isServedByPages
                    self.isValid = isValid
                    self.reason = reason
                    self.respondsToHttps = respondsToHttps
                    self.enforcesHttps = enforcesHttps
                    self.httpsError = httpsError
                    self.isHttpsEligible = isHttpsEligible
                    self.caaError = caaError
                }
                public enum CodingKeys: String, CodingKey {
                    case host
                    case uri
                    case nameservers
                    case dnsResolves = "dns_resolves"
                    case isProxied = "is_proxied"
                    case isCloudflareIp = "is_cloudflare_ip"
                    case isFastlyIp = "is_fastly_ip"
                    case isOldIpAddress = "is_old_ip_address"
                    case isARecord = "is_a_record"
                    case hasCnameRecord = "has_cname_record"
                    case hasMxRecordsPresent = "has_mx_records_present"
                    case isValidDomain = "is_valid_domain"
                    case isApexDomain = "is_apex_domain"
                    case shouldBeARecord = "should_be_a_record"
                    case isCnameToGithubUserDomain = "is_cname_to_github_user_domain"
                    case isCnameToPagesDotGithubDotCom = "is_cname_to_pages_dot_github_dot_com"
                    case isCnameToFastly = "is_cname_to_fastly"
                    case isPointedToGithubPagesIp = "is_pointed_to_github_pages_ip"
                    case isNonGithubPagesIpPresent = "is_non_github_pages_ip_present"
                    case isPagesDomain = "is_pages_domain"
                    case isServedByPages = "is_served_by_pages"
                    case isValid = "is_valid"
                    case reason
                    case respondsToHttps = "responds_to_https"
                    case enforcesHttps = "enforces_https"
                    case httpsError = "https_error"
                    case isHttpsEligible = "is_https_eligible"
                    case caaError = "caa_error"
                }
            }
            /// - Remark: Generated from `#/components/schemas/pages-health-check/alt_domain`.
            public var altDomain: Components.Schemas.PagesHealthCheck.AltDomainPayload?
            /// Creates a new `PagesHealthCheck`.
            ///
            /// - Parameters:
            ///   - domain:
            ///   - altDomain:
            public init(
                domain: Components.Schemas.PagesHealthCheck.DomainPayload? = nil,
                altDomain: Components.Schemas.PagesHealthCheck.AltDomainPayload? = nil
            ) {
                self.domain = domain
                self.altDomain = altDomain
            }
            public enum CodingKeys: String, CodingKey {
                case domain
                case altDomain = "alt_domain"
            }
        }
        /// Data related to a release.
        ///
        /// - Remark: Generated from `#/components/schemas/release-asset`.
        public struct ReleaseAsset: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/release-asset/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/release-asset/browser_download_url`.
            public var browserDownloadUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/release-asset/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/release-asset/node_id`.
            public var nodeId: Swift.String
            /// The file name of the asset.
            ///
            /// - Remark: Generated from `#/components/schemas/release-asset/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/release-asset/label`.
            public var label: Swift.String?
            /// State of the release asset.
            ///
            /// - Remark: Generated from `#/components/schemas/release-asset/state`.
            @frozen public enum StatePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case uploaded = "uploaded"
                case open = "open"
            }
            /// State of the release asset.
            ///
            /// - Remark: Generated from `#/components/schemas/release-asset/state`.
            public var state: Components.Schemas.ReleaseAsset.StatePayload
            /// - Remark: Generated from `#/components/schemas/release-asset/content_type`.
            public var contentType: Swift.String
            /// - Remark: Generated from `#/components/schemas/release-asset/size`.
            public var size: Swift.Int
            /// - Remark: Generated from `#/components/schemas/release-asset/download_count`.
            public var downloadCount: Swift.Int
            /// - Remark: Generated from `#/components/schemas/release-asset/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/release-asset/updated_at`.
            public var updatedAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/release-asset/uploader`.
            public var uploader: Components.Schemas.NullableSimpleUser?
            /// Creates a new `ReleaseAsset`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - browserDownloadUrl:
            ///   - id:
            ///   - nodeId:
            ///   - name: The file name of the asset.
            ///   - label:
            ///   - state: State of the release asset.
            ///   - contentType:
            ///   - size:
            ///   - downloadCount:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - uploader:
            public init(
                url: Swift.String,
                browserDownloadUrl: Swift.String,
                id: Swift.Int,
                nodeId: Swift.String,
                name: Swift.String,
                label: Swift.String? = nil,
                state: Components.Schemas.ReleaseAsset.StatePayload,
                contentType: Swift.String,
                size: Swift.Int,
                downloadCount: Swift.Int,
                createdAt: Foundation.Date,
                updatedAt: Foundation.Date,
                uploader: Components.Schemas.NullableSimpleUser? = nil
            ) {
                self.url = url
                self.browserDownloadUrl = browserDownloadUrl
                self.id = id
                self.nodeId = nodeId
                self.name = name
                self.label = label
                self.state = state
                self.contentType = contentType
                self.size = size
                self.downloadCount = downloadCount
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.uploader = uploader
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case browserDownloadUrl = "browser_download_url"
                case id
                case nodeId = "node_id"
                case name
                case label
                case state
                case contentType = "content_type"
                case size
                case downloadCount = "download_count"
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case uploader
            }
        }
        /// A release.
        ///
        /// - Remark: Generated from `#/components/schemas/release`.
        public struct Release: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/release/url`.
            public var url: Swift.String
            /// - Remark: Generated from `#/components/schemas/release/html_url`.
            public var htmlUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/release/assets_url`.
            public var assetsUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/release/upload_url`.
            public var uploadUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/release/tarball_url`.
            public var tarballUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/release/zipball_url`.
            public var zipballUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/release/id`.
            public var id: Swift.Int
            /// - Remark: Generated from `#/components/schemas/release/node_id`.
            public var nodeId: Swift.String
            /// The name of the tag.
            ///
            /// - Remark: Generated from `#/components/schemas/release/tag_name`.
            public var tagName: Swift.String
            /// Specifies the commitish value that determines where the Git tag is created from.
            ///
            /// - Remark: Generated from `#/components/schemas/release/target_commitish`.
            public var targetCommitish: Swift.String
            /// - Remark: Generated from `#/components/schemas/release/name`.
            public var name: Swift.String?
            /// - Remark: Generated from `#/components/schemas/release/body`.
            public var body: Swift.String?
            /// true to create a draft (unpublished) release, false to create a published one.
            ///
            /// - Remark: Generated from `#/components/schemas/release/draft`.
            public var draft: Swift.Bool
            /// Whether to identify the release as a prerelease or a full release.
            ///
            /// - Remark: Generated from `#/components/schemas/release/prerelease`.
            public var prerelease: Swift.Bool
            /// - Remark: Generated from `#/components/schemas/release/created_at`.
            public var createdAt: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/release/published_at`.
            public var publishedAt: Foundation.Date?
            /// - Remark: Generated from `#/components/schemas/release/author`.
            public var author: Components.Schemas.SimpleUser
            /// - Remark: Generated from `#/components/schemas/release/assets`.
            public var assets: [Components.Schemas.ReleaseAsset]
            /// - Remark: Generated from `#/components/schemas/release/body_html`.
            public var bodyHtml: Swift.String?
            /// - Remark: Generated from `#/components/schemas/release/body_text`.
            public var bodyText: Swift.String?
            /// - Remark: Generated from `#/components/schemas/release/mentions_count`.
            public var mentionsCount: Swift.Int?
            /// The URL of the release discussion.
            ///
            /// - Remark: Generated from `#/components/schemas/release/discussion_url`.
            public var discussionUrl: Swift.String?
            /// - Remark: Generated from `#/components/schemas/release/reactions`.
            public var reactions: Components.Schemas.ReactionRollup?
            /// Creates a new `Release`.
            ///
            /// - Parameters:
            ///   - url:
            ///   - htmlUrl:
            ///   - assetsUrl:
            ///   - uploadUrl:
            ///   - tarballUrl:
            ///   - zipballUrl:
            ///   - id:
            ///   - nodeId:
            ///   - tagName: The name of the tag.
            ///   - targetCommitish: Specifies the commitish value that determines where the Git tag is created from.
            ///   - name:
            ///   - body:
            ///   - draft: true to create a draft (unpublished) release, false to create a published one.
            ///   - prerelease: Whether to identify the release as a prerelease or a full release.
            ///   - createdAt:
            ///   - publishedAt:
            ///   - author:
            ///   - assets:
            ///   - bodyHtml:
            ///   - bodyText:
            ///   - mentionsCount:
            ///   - discussionUrl: The URL of the release discussion.
            ///   - reactions:
            public init(
                url: Swift.String,
                htmlUrl: Swift.String,
                assetsUrl: Swift.String,
                uploadUrl: Swift.String,
                tarballUrl: Swift.String? = nil,
                zipballUrl: Swift.String? = nil,
                id: Swift.Int,
                nodeId: Swift.String,
                tagName: Swift.String,
                targetCommitish: Swift.String,
                name: Swift.String? = nil,
                body: Swift.String? = nil,
                draft: Swift.Bool,
                prerelease: Swift.Bool,
                createdAt: Foundation.Date,
                publishedAt: Foundation.Date? = nil,
                author: Components.Schemas.SimpleUser,
                assets: [Components.Schemas.ReleaseAsset],
                bodyHtml: Swift.String? = nil,
                bodyText: Swift.String? = nil,
                mentionsCount: Swift.Int? = nil,
                discussionUrl: Swift.String? = nil,
                reactions: Components.Schemas.ReactionRollup? = nil
            ) {
                self.url = url
                self.htmlUrl = htmlUrl
                self.assetsUrl = assetsUrl
                self.uploadUrl = uploadUrl
                self.tarballUrl = tarballUrl
                self.zipballUrl = zipballUrl
                self.id = id
                self.nodeId = nodeId
                self.tagName = tagName
                self.targetCommitish = targetCommitish
                self.name = name
                self.body = body
                self.draft = draft
                self.prerelease = prerelease
                self.createdAt = createdAt
                self.publishedAt = publishedAt
                self.author = author
                self.assets = assets
                self.bodyHtml = bodyHtml
                self.bodyText = bodyText
                self.mentionsCount = mentionsCount
                self.discussionUrl = discussionUrl
                self.reactions = reactions
            }
            public enum CodingKeys: String, CodingKey {
                case url
                case htmlUrl = "html_url"
                case assetsUrl = "assets_url"
                case uploadUrl = "upload_url"
                case tarballUrl = "tarball_url"
                case zipballUrl = "zipball_url"
                case id
                case nodeId = "node_id"
                case tagName = "tag_name"
                case targetCommitish = "target_commitish"
                case name
                case body
                case draft
                case prerelease
                case createdAt = "created_at"
                case publishedAt = "published_at"
                case author
                case assets
                case bodyHtml = "body_html"
                case bodyText = "body_text"
                case mentionsCount = "mentions_count"
                case discussionUrl = "discussion_url"
                case reactions
            }
        }
        /// Generated name and body describing a release
        ///
        /// - Remark: Generated from `#/components/schemas/release-notes-content`.
        public struct ReleaseNotesContent: Codable, Hashable, Sendable {
            /// The generated name of the release
            ///
            /// - Remark: Generated from `#/components/schemas/release-notes-content/name`.
            public var name: Swift.String
            /// The generated body describing the contents of the release supporting markdown formatting
            ///
            /// - Remark: Generated from `#/components/schemas/release-notes-content/body`.
            public var body: Swift.String
            /// Creates a new `ReleaseNotesContent`.
            ///
            /// - Parameters:
            ///   - name: The generated name of the release
            ///   - body: The generated body describing the contents of the release supporting markdown formatting
            public init(
                name: Swift.String,
                body: Swift.String
            ) {
                self.name = name
                self.body = body
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case body
            }
        }
        /// User-defined metadata to store domain-specific information limited to 8 keys with scalar values.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-ruleset-info`.
        public struct RepositoryRuleRulesetInfo: Codable, Hashable, Sendable {
            /// The type of source for the ruleset that includes this rule.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-ruleset-info/ruleset_source_type`.
            @frozen public enum RulesetSourceTypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case repository = "Repository"
                case organization = "Organization"
            }
            /// The type of source for the ruleset that includes this rule.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-ruleset-info/ruleset_source_type`.
            public var rulesetSourceType: Components.Schemas.RepositoryRuleRulesetInfo.RulesetSourceTypePayload?
            /// The name of the source of the ruleset that includes this rule.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-ruleset-info/ruleset_source`.
            public var rulesetSource: Swift.String?
            /// The ID of the ruleset that includes this rule.
            ///
            /// - Remark: Generated from `#/components/schemas/repository-rule-ruleset-info/ruleset_id`.
            public var rulesetId: Swift.Int?
            /// Creates a new `RepositoryRuleRulesetInfo`.
            ///
            /// - Parameters:
            ///   - rulesetSourceType: The type of source for the ruleset that includes this rule.
            ///   - rulesetSource: The name of the source of the ruleset that includes this rule.
            ///   - rulesetId: The ID of the ruleset that includes this rule.
            public init(
                rulesetSourceType: Components.Schemas.RepositoryRuleRulesetInfo.RulesetSourceTypePayload? = nil,
                rulesetSource: Swift.String? = nil,
                rulesetId: Swift.Int? = nil
            ) {
                self.rulesetSourceType = rulesetSourceType
                self.rulesetSource = rulesetSource
                self.rulesetId = rulesetId
            }
            public enum CodingKeys: String, CodingKey {
                case rulesetSourceType = "ruleset_source_type"
                case rulesetSource = "ruleset_source"
                case rulesetId = "ruleset_id"
            }
        }
        /// A repository rule with ruleset details.
        ///
        /// - Remark: Generated from `#/components/schemas/repository-rule-detailed`.
        @frozen public enum RepositoryRuleDetailed: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case1`.
            public struct Case1Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case1/value1`.
                public var value1: Components.Schemas.RepositoryRuleCreation
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case1/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case1Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleCreation,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case1`.
            case case1(Components.Schemas.RepositoryRuleDetailed.Case1Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case2`.
            public struct Case2Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case2/value1`.
                public var value1: Components.Schemas.RepositoryRuleUpdate
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case2/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case2Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleUpdate,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case2`.
            case case2(Components.Schemas.RepositoryRuleDetailed.Case2Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case3`.
            public struct Case3Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case3/value1`.
                public var value1: Components.Schemas.RepositoryRuleDeletion
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case3/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case3Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleDeletion,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case3`.
            case case3(Components.Schemas.RepositoryRuleDetailed.Case3Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case4`.
            public struct Case4Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case4/value1`.
                public var value1: Components.Schemas.RepositoryRuleRequiredLinearHistory
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case4/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case4Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleRequiredLinearHistory,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case4`.
            case case4(Components.Schemas.RepositoryRuleDetailed.Case4Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case5`.
            public struct Case5Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case5/value1`.
                public var value1: Components.Schemas.RepositoryRuleMergeQueue
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case5/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case5Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleMergeQueue,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case5`.
            case case5(Components.Schemas.RepositoryRuleDetailed.Case5Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case6`.
            public struct Case6Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case6/value1`.
                public var value1: Components.Schemas.RepositoryRuleRequiredDeployments
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case6/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case6Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleRequiredDeployments,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case6`.
            case case6(Components.Schemas.RepositoryRuleDetailed.Case6Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case7`.
            public struct Case7Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case7/value1`.
                public var value1: Components.Schemas.RepositoryRuleRequiredSignatures
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case7/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case7Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleRequiredSignatures,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case7`.
            case case7(Components.Schemas.RepositoryRuleDetailed.Case7Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case8`.
            public struct Case8Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case8/value1`.
                public var value1: Components.Schemas.RepositoryRulePullRequest
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case8/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case8Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRulePullRequest,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case8`.
            case case8(Components.Schemas.RepositoryRuleDetailed.Case8Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case9`.
            public struct Case9Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case9/value1`.
                public var value1: Components.Schemas.RepositoryRuleRequiredStatusChecks
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case9/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case9Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleRequiredStatusChecks,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case9`.
            case case9(Components.Schemas.RepositoryRuleDetailed.Case9Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case10`.
            public struct Case10Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case10/value1`.
                public var value1: Components.Schemas.RepositoryRuleNonFastForward
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case10/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case10Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleNonFastForward,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case10`.
            case case10(Components.Schemas.RepositoryRuleDetailed.Case10Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case11`.
            public struct Case11Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case11/value1`.
                public var value1: Components.Schemas.RepositoryRuleCommitMessagePattern
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case11/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case11Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleCommitMessagePattern,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case11`.
            case case11(Components.Schemas.RepositoryRuleDetailed.Case11Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case12`.
            public struct Case12Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case12/value1`.
                public var value1: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case12/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case12Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleCommitAuthorEmailPattern,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case12`.
            case case12(Components.Schemas.RepositoryRuleDetailed.Case12Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case13`.
            public struct Case13Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case13/value1`.
                public var value1: Components.Schemas.RepositoryRuleCommitterEmailPattern
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case13/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case13Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleCommitterEmailPattern,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case13`.
            case case13(Components.Schemas.RepositoryRuleDetailed.Case13Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case14`.
            public struct Case14Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case14/value1`.
                public var value1: Components.Schemas.RepositoryRuleBranchNamePattern
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case14/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case14Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleBranchNamePattern,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case14`.
            case case14(Components.Schemas.RepositoryRuleDetailed.Case14Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case15`.
            public struct Case15Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case15/value1`.
                public var value1: Components.Schemas.RepositoryRuleTagNamePattern
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case15/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case15Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleTagNamePattern,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case15`.
            case case15(Components.Schemas.RepositoryRuleDetailed.Case15Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case16`.
            public struct Case16Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case16/value1`.
                public var value1: Components.Schemas.RepositoryRuleFilePathRestriction
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case16/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case16Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleFilePathRestriction,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case16`.
            case case16(Components.Schemas.RepositoryRuleDetailed.Case16Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case17`.
            public struct Case17Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case17/value1`.
                public var value1: Components.Schemas.RepositoryRuleMaxFilePathLength
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case17/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case17Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleMaxFilePathLength,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case17`.
            case case17(Components.Schemas.RepositoryRuleDetailed.Case17Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case18`.
            public struct Case18Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case18/value1`.
                public var value1: Components.Schemas.RepositoryRuleFileExtensionRestriction
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case18/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case18Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleFileExtensionRestriction,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case18`.
            case case18(Components.Schemas.RepositoryRuleDetailed.Case18Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case19`.
            public struct Case19Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case19/value1`.
                public var value1: Components.Schemas.RepositoryRuleMaxFileSize
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case19/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case19Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleMaxFileSize,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case19`.
            case case19(Components.Schemas.RepositoryRuleDetailed.Case19Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case20`.
            public struct Case20Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case20/value1`.
                public var value1: Components.Schemas.RepositoryRuleWorkflows
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case20/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case20Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleWorkflows,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case20`.
            case case20(Components.Schemas.RepositoryRuleDetailed.Case20Payload)
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case21`.
            public struct Case21Payload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case21/value1`.
                public var value1: Components.Schemas.RepositoryRuleCodeScanning
                /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case21/value2`.
                public var value2: Components.Schemas.RepositoryRuleRulesetInfo
                /// Creates a new `Case21Payload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Components.Schemas.RepositoryRuleCodeScanning,
                    value2: Components.Schemas.RepositoryRuleRulesetInfo
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    self.value1 = try .init(from: decoder)
                    self.value2 = try .init(from: decoder)
                }
                public func encode(to encoder: any Encoder) throws {
                    try self.value1.encode(to: encoder)
                    try self.value2.encode(to: encoder)
                }
            }
            /// - Remark: Generated from `#/components/schemas/repository-rule-detailed/case21`.
            case case21(Components.Schemas.RepositoryRuleDetailed.Case21Payload)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .case1(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case2(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case3(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case4(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case5(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case6(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case7(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case8(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case9(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case10(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case11(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case12(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case13(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case14(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case15(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case16(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case17(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case18(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case19(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case20(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case21(try .init(from: decoder))
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .case1(value):
                    try value.encode(to: encoder)
                case let .case2(value):
                    try value.encode(to: encoder)
                case let .case3(value):
                    try value.encode(to: encoder)
                case let .case4(value):
                    try value.encode(to: encoder)
                case let .case5(value):
                    try value.encode(to: encoder)
                case let .case6(value):
                    try value.encode(to: encoder)
                case let .case7(value):
                    try value.encode(to: encoder)
                case let .case8(value):
                    try value.encode(to: encoder)
                case let .case9(value):
                    try value.encode(to: encoder)
                case let .case10(value):
                    try value.encode(to: encoder)
                case let .case11(value):
                    try value.encode(to: encoder)
                case let .case12(value):
                    try value.encode(to: encoder)
                case let .case13(value):
                    try value.encode(to: encoder)
                case let .case14(value):
                    try value.encode(to: encoder)
                case let .case15(value):
                    try value.encode(to: encoder)
                case let .case16(value):
                    try value.encode(to: encoder)
                case let .case17(value):
                    try value.encode(to: encoder)
                case let .case18(value):
                    try value.encode(to: encoder)
                case let .case19(value):
                    try value.encode(to: encoder)
                case let .case20(value):
                    try value.encode(to: encoder)
                case let .case21(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// Code Frequency Stat
        ///
        /// - Remark: Generated from `#/components/schemas/code-frequency-stat`.
        public typealias CodeFrequencyStat = [Swift.Int]
        /// Commit Activity
        ///
        /// - Remark: Generated from `#/components/schemas/commit-activity`.
        public struct CommitActivity: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/commit-activity/days`.
            public var days: [Swift.Int]
            /// - Remark: Generated from `#/components/schemas/commit-activity/total`.
            public var total: Swift.Int
            /// - Remark: Generated from `#/components/schemas/commit-activity/week`.
            public var week: Swift.Int
            /// Creates a new `CommitActivity`.
            ///
            /// - Parameters:
            ///   - days:
            ///   - total:
            ///   - week:
            public init(
                days: [Swift.Int],
                total: Swift.Int,
                week: Swift.Int
            ) {
                self.days = days
                self.total = total
                self.week = week
            }
            public enum CodingKeys: String, CodingKey {
                case days
                case total
                case week
            }
        }
        /// Contributor Activity
        ///
        /// - Remark: Generated from `#/components/schemas/contributor-activity`.
        public struct ContributorActivity: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/contributor-activity/author`.
            public var author: Components.Schemas.NullableSimpleUser?
            /// - Remark: Generated from `#/components/schemas/contributor-activity/total`.
            public var total: Swift.Int
            /// - Remark: Generated from `#/components/schemas/contributor-activity/WeeksPayload`.
            public struct WeeksPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/contributor-activity/WeeksPayload/w`.
                public var w: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/contributor-activity/WeeksPayload/a`.
                public var a: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/contributor-activity/WeeksPayload/d`.
                public var d: Swift.Int?
                /// - Remark: Generated from `#/components/schemas/contributor-activity/WeeksPayload/c`.
                public var c: Swift.Int?
                /// Creates a new `WeeksPayloadPayload`.
                ///
                /// - Parameters:
                ///   - w:
                ///   - a:
                ///   - d:
                ///   - c:
                public init(
                    w: Swift.Int? = nil,
                    a: Swift.Int? = nil,
                    d: Swift.Int? = nil,
                    c: Swift.Int? = nil
                ) {
                    self.w = w
                    self.a = a
                    self.d = d
                    self.c = c
                }
                public enum CodingKeys: String, CodingKey {
                    case w
                    case a
                    case d
                    case c
                }
            }
            /// - Remark: Generated from `#/components/schemas/contributor-activity/weeks`.
            public typealias WeeksPayload = [Components.Schemas.ContributorActivity.WeeksPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/contributor-activity/weeks`.
            public var weeks: Components.Schemas.ContributorActivity.WeeksPayload
            /// Creates a new `ContributorActivity`.
            ///
            /// - Parameters:
            ///   - author:
            ///   - total:
            ///   - weeks:
            public init(
                author: Components.Schemas.NullableSimpleUser? = nil,
                total: Swift.Int,
                weeks: Components.Schemas.ContributorActivity.WeeksPayload
            ) {
                self.author = author
                self.total = total
                self.weeks = weeks
            }
            public enum CodingKeys: String, CodingKey {
                case author
                case total
                case weeks
            }
        }
        /// - Remark: Generated from `#/components/schemas/participation-stats`.
        public struct ParticipationStats: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/participation-stats/all`.
            public var all: [Swift.Int]
            /// - Remark: Generated from `#/components/schemas/participation-stats/owner`.
            public var owner: [Swift.Int]
            /// Creates a new `ParticipationStats`.
            ///
            /// - Parameters:
            ///   - all:
            ///   - owner:
            public init(
                all: [Swift.Int],
                owner: [Swift.Int]
            ) {
                self.all = all
                self.owner = owner
            }
            public enum CodingKeys: String, CodingKey {
                case all
                case owner
            }
        }
        /// Tag
        ///
        /// - Remark: Generated from `#/components/schemas/tag`.
        public struct Tag: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/tag/name`.
            public var name: Swift.String
            /// - Remark: Generated from `#/components/schemas/tag/commit`.
            public struct CommitPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/tag/commit/sha`.
                public var sha: Swift.String
                /// - Remark: Generated from `#/components/schemas/tag/commit/url`.
                public var url: Swift.String
                /// Creates a new `CommitPayload`.
                ///
                /// - Parameters:
                ///   - sha:
                ///   - url:
                public init(
                    sha: Swift.String,
                    url: Swift.String
                ) {
                    self.sha = sha
                    self.url = url
                }
                public enum CodingKeys: String, CodingKey {
                    case sha
                    case url
                }
            }
            /// - Remark: Generated from `#/components/schemas/tag/commit`.
            public var commit: Components.Schemas.Tag.CommitPayload
            /// - Remark: Generated from `#/components/schemas/tag/zipball_url`.
            public var zipballUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/tag/tarball_url`.
            public var tarballUrl: Swift.String
            /// - Remark: Generated from `#/components/schemas/tag/node_id`.
            public var nodeId: Swift.String
            /// Creates a new `Tag`.
            ///
            /// - Parameters:
            ///   - name:
            ///   - commit:
            ///   - zipballUrl:
            ///   - tarballUrl:
            ///   - nodeId:
            public init(
                name: Swift.String,
                commit: Components.Schemas.Tag.CommitPayload,
                zipballUrl: Swift.String,
                tarballUrl: Swift.String,
                nodeId: Swift.String
            ) {
                self.name = name
                self.commit = commit
                self.zipballUrl = zipballUrl
                self.tarballUrl = tarballUrl
                self.nodeId = nodeId
            }
            public enum CodingKeys: String, CodingKey {
                case name
                case commit
                case zipballUrl = "zipball_url"
                case tarballUrl = "tarball_url"
                case nodeId = "node_id"
            }
        }
        /// Tag protection
        ///
        /// - Remark: Generated from `#/components/schemas/tag-protection`.
        public struct TagProtection: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/tag-protection/id`.
            public var id: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/tag-protection/created_at`.
            public var createdAt: Swift.String?
            /// - Remark: Generated from `#/components/schemas/tag-protection/updated_at`.
            public var updatedAt: Swift.String?
            /// - Remark: Generated from `#/components/schemas/tag-protection/enabled`.
            public var enabled: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/tag-protection/pattern`.
            public var pattern: Swift.String
            /// Creates a new `TagProtection`.
            ///
            /// - Parameters:
            ///   - id:
            ///   - createdAt:
            ///   - updatedAt:
            ///   - enabled:
            ///   - pattern:
            public init(
                id: Swift.Int? = nil,
                createdAt: Swift.String? = nil,
                updatedAt: Swift.String? = nil,
                enabled: Swift.Bool? = nil,
                pattern: Swift.String
            ) {
                self.id = id
                self.createdAt = createdAt
                self.updatedAt = updatedAt
                self.enabled = enabled
                self.pattern = pattern
            }
            public enum CodingKeys: String, CodingKey {
                case id
                case createdAt = "created_at"
                case updatedAt = "updated_at"
                case enabled
                case pattern
            }
        }
        /// A topic aggregates entities that are related to a subject.
        ///
        /// - Remark: Generated from `#/components/schemas/topic`.
        public struct Topic: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/topic/names`.
            public var names: [Swift.String]
            /// Creates a new `Topic`.
            ///
            /// - Parameters:
            ///   - names:
            public init(names: [Swift.String]) {
                self.names = names
            }
            public enum CodingKeys: String, CodingKey {
                case names
            }
        }
        /// - Remark: Generated from `#/components/schemas/traffic`.
        public struct Traffic: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/traffic/timestamp`.
            public var timestamp: Foundation.Date
            /// - Remark: Generated from `#/components/schemas/traffic/uniques`.
            public var uniques: Swift.Int
            /// - Remark: Generated from `#/components/schemas/traffic/count`.
            public var count: Swift.Int
            /// Creates a new `Traffic`.
            ///
            /// - Parameters:
            ///   - timestamp:
            ///   - uniques:
            ///   - count:
            public init(
                timestamp: Foundation.Date,
                uniques: Swift.Int,
                count: Swift.Int
            ) {
                self.timestamp = timestamp
                self.uniques = uniques
                self.count = count
            }
            public enum CodingKeys: String, CodingKey {
                case timestamp
                case uniques
                case count
            }
        }
        /// Clone Traffic
        ///
        /// - Remark: Generated from `#/components/schemas/clone-traffic`.
        public struct CloneTraffic: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/clone-traffic/count`.
            public var count: Swift.Int
            /// - Remark: Generated from `#/components/schemas/clone-traffic/uniques`.
            public var uniques: Swift.Int
            /// - Remark: Generated from `#/components/schemas/clone-traffic/clones`.
            public var clones: [Components.Schemas.Traffic]
            /// Creates a new `CloneTraffic`.
            ///
            /// - Parameters:
            ///   - count:
            ///   - uniques:
            ///   - clones:
            public init(
                count: Swift.Int,
                uniques: Swift.Int,
                clones: [Components.Schemas.Traffic]
            ) {
                self.count = count
                self.uniques = uniques
                self.clones = clones
            }
            public enum CodingKeys: String, CodingKey {
                case count
                case uniques
                case clones
            }
        }
        /// Content Traffic
        ///
        /// - Remark: Generated from `#/components/schemas/content-traffic`.
        public struct ContentTraffic: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/content-traffic/path`.
            public var path: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-traffic/title`.
            public var title: Swift.String
            /// - Remark: Generated from `#/components/schemas/content-traffic/count`.
            public var count: Swift.Int
            /// - Remark: Generated from `#/components/schemas/content-traffic/uniques`.
            public var uniques: Swift.Int
            /// Creates a new `ContentTraffic`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - title:
            ///   - count:
            ///   - uniques:
            public init(
                path: Swift.String,
                title: Swift.String,
                count: Swift.Int,
                uniques: Swift.Int
            ) {
                self.path = path
                self.title = title
                self.count = count
                self.uniques = uniques
            }
            public enum CodingKeys: String, CodingKey {
                case path
                case title
                case count
                case uniques
            }
        }
        /// Referrer Traffic
        ///
        /// - Remark: Generated from `#/components/schemas/referrer-traffic`.
        public struct ReferrerTraffic: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/referrer-traffic/referrer`.
            public var referrer: Swift.String
            /// - Remark: Generated from `#/components/schemas/referrer-traffic/count`.
            public var count: Swift.Int
            /// - Remark: Generated from `#/components/schemas/referrer-traffic/uniques`.
            public var uniques: Swift.Int
            /// Creates a new `ReferrerTraffic`.
            ///
            /// - Parameters:
            ///   - referrer:
            ///   - count:
            ///   - uniques:
            public init(
                referrer: Swift.String,
                count: Swift.Int,
                uniques: Swift.Int
            ) {
                self.referrer = referrer
                self.count = count
                self.uniques = uniques
            }
            public enum CodingKeys: String, CodingKey {
                case referrer
                case count
                case uniques
            }
        }
        /// View Traffic
        ///
        /// - Remark: Generated from `#/components/schemas/view-traffic`.
        public struct ViewTraffic: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/view-traffic/count`.
            public var count: Swift.Int
            /// - Remark: Generated from `#/components/schemas/view-traffic/uniques`.
            public var uniques: Swift.Int
            /// - Remark: Generated from `#/components/schemas/view-traffic/views`.
            public var views: [Components.Schemas.Traffic]
            /// Creates a new `ViewTraffic`.
            ///
            /// - Parameters:
            ///   - count:
            ///   - uniques:
            ///   - views:
            public init(
                count: Swift.Int,
                uniques: Swift.Int,
                views: [Components.Schemas.Traffic]
            ) {
                self.count = count
                self.uniques = uniques
                self.views = views
            }
            public enum CodingKeys: String, CodingKey {
                case count
                case uniques
                case views
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {
        /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
        ///
        /// - Remark: Generated from `#/components/parameters/pagination-before`.
        public typealias PaginationBefore = Swift.String
        /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
        ///
        /// - Remark: Generated from `#/components/parameters/pagination-after`.
        public typealias PaginationAfter = Swift.String
        /// The direction to sort the results by.
        ///
        /// - Remark: Generated from `#/components/parameters/direction`.
        @frozen public enum Direction: String, Codable, Hashable, Sendable, CaseIterable {
            case asc = "asc"
            case desc = "desc"
        }
        /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
        ///
        /// - Remark: Generated from `#/components/parameters/per-page`.
        public typealias PerPage = Swift.Int
        /// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
        ///
        /// - Remark: Generated from `#/components/parameters/cursor`.
        public typealias Cursor = Swift.String
        /// - Remark: Generated from `#/components/parameters/delivery-id`.
        public typealias DeliveryId = Swift.Int
        /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
        ///
        /// - Remark: Generated from `#/components/parameters/page`.
        public typealias Page = Swift.Int
        /// The unique identifier of the comment.
        ///
        /// - Remark: Generated from `#/components/parameters/comment-id`.
        public typealias CommentId = Swift.Int64
        /// The account owner of the repository. The name is not case sensitive.
        ///
        /// - Remark: Generated from `#/components/parameters/owner`.
        public typealias Owner = Swift.String
        /// The name of the repository without the `.git` extension. The name is not case sensitive.
        ///
        /// - Remark: Generated from `#/components/parameters/repo`.
        public typealias Repo = Swift.String
        /// The organization name. The name is not case sensitive.
        ///
        /// - Remark: Generated from `#/components/parameters/org`.
        public typealias Org = Swift.String
        /// The handle for the GitHub user account.
        ///
        /// - Remark: Generated from `#/components/parameters/username`.
        public typealias Username = Swift.String
        /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
        ///
        /// - Remark: Generated from `#/components/parameters/hook-id`.
        public typealias HookId = Swift.Int
        /// The unique identifier of the invitation.
        ///
        /// - Remark: Generated from `#/components/parameters/invitation-id`.
        public typealias InvitationId = Swift.Int
        /// A comma-separated list of rule targets to filter by.
        /// If provided, only rulesets that apply to the specified targets will be returned.
        /// For example, `branch,tag,push`.
        ///
        ///
        /// - Remark: Generated from `#/components/parameters/ruleset-targets`.
        public typealias RulesetTargets = Swift.String
        /// The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
        ///
        /// - Remark: Generated from `#/components/parameters/ref-in-query`.
        public typealias RefInQuery = Swift.String
        /// The name of the repository to filter on.
        ///
        /// - Remark: Generated from `#/components/parameters/repository-name-in-query`.
        public typealias RepositoryNameInQuery = Swift.String
        /// The time period to filter by.
        ///
        /// For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
        ///
        /// - Remark: Generated from `#/components/parameters/time-period`.
        @frozen public enum TimePeriod: String, Codable, Hashable, Sendable, CaseIterable {
            case hour = "hour"
            case day = "day"
            case week = "week"
            case month = "month"
        }
        /// The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
        ///
        /// - Remark: Generated from `#/components/parameters/actor-name-in-query`.
        public typealias ActorNameInQuery = Swift.String
        /// The rule results to filter on. When specified, only suites with this result will be returned.
        ///
        /// - Remark: Generated from `#/components/parameters/rule-suite-result`.
        @frozen public enum RuleSuiteResult: String, Codable, Hashable, Sendable, CaseIterable {
            case pass = "pass"
            case fail = "fail"
            case bypass = "bypass"
            case all = "all"
        }
        /// The unique identifier of the rule suite result.
        /// To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
        /// for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
        /// for organizations.
        ///
        /// - Remark: Generated from `#/components/parameters/rule-suite-id`.
        public typealias RuleSuiteId = Swift.Int
        /// The unique identifier of the autolink.
        ///
        /// - Remark: Generated from `#/components/parameters/autolink-id`.
        public typealias AutolinkId = Swift.Int
        /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
        ///
        /// - Remark: Generated from `#/components/parameters/branch`.
        public typealias Branch = Swift.String
        /// The SHA of the commit.
        ///
        /// - Remark: Generated from `#/components/parameters/commit-sha`.
        public typealias CommitSha = Swift.String
        /// The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
        ///
        /// - Remark: Generated from `#/components/parameters/commit-ref`.
        public typealias CommitRef = Swift.String
        /// deployment_id parameter
        ///
        /// - Remark: Generated from `#/components/parameters/deployment-id`.
        public typealias DeploymentId = Swift.Int
        /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
        ///
        /// - Remark: Generated from `#/components/parameters/environment-name`.
        public typealias EnvironmentName = Swift.String
        /// The unique identifier of the branch policy.
        ///
        /// - Remark: Generated from `#/components/parameters/branch-policy-id`.
        public typealias BranchPolicyId = Swift.Int
        /// The unique identifier of the protection rule.
        ///
        /// - Remark: Generated from `#/components/parameters/protection-rule-id`.
        public typealias ProtectionRuleId = Swift.Int
        /// The unique identifier of the key.
        ///
        /// - Remark: Generated from `#/components/parameters/key-id`.
        public typealias KeyId = Swift.Int
        /// The ID of the Pages deployment. You can also give the commit SHA of the deployment.
        ///
        /// - Remark: Generated from `#/components/parameters/pages-deployment-id`.
        @frozen public enum PagesDeploymentId: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/parameters/pages-deployment-id/case1`.
            case case1(Swift.Int)
            /// - Remark: Generated from `#/components/parameters/pages-deployment-id/case2`.
            case case2(Swift.String)
            public init(from decoder: any Decoder) throws {
                var errors: [any Error] = []
                do {
                    self = .case1(try decoder.decodeFromSingleValueContainer())
                    return
                } catch {
                    errors.append(error)
                }
                do {
                    self = .case2(try decoder.decodeFromSingleValueContainer())
                    return
                } catch {
                    errors.append(error)
                }
                throw Swift.DecodingError.failedToDecodeOneOfSchema(
                    type: Self.self,
                    codingPath: decoder.codingPath,
                    errors: errors
                )
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .case1(value):
                    try encoder.encodeToSingleValueContainer(value)
                case let .case2(value):
                    try encoder.encodeToSingleValueContainer(value)
                }
            }
        }
        /// The unique identifier of the asset.
        ///
        /// - Remark: Generated from `#/components/parameters/asset-id`.
        public typealias AssetId = Swift.Int
        /// The unique identifier of the release.
        ///
        /// - Remark: Generated from `#/components/parameters/release-id`.
        public typealias ReleaseId = Swift.Int
        /// The unique identifier of the tag protection.
        ///
        /// - Remark: Generated from `#/components/parameters/tag-protection-id`.
        public typealias TagProtectionId = Swift.Int
        /// The time frame to display results for.
        ///
        /// - Remark: Generated from `#/components/parameters/per`.
        @frozen public enum Per: String, Codable, Hashable, Sendable, CaseIterable {
            case day = "day"
            case week = "week"
        }
        /// A repository ID. Only return repositories with an ID greater than this ID.
        ///
        /// - Remark: Generated from `#/components/parameters/since-repo`.
        public typealias SinceRepo = Swift.Int
        /// Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
        ///
        /// - Remark: Generated from `#/components/parameters/since-repo-date`.
        public typealias SinceRepoDate = Foundation.Date
        /// Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
        ///
        /// - Remark: Generated from `#/components/parameters/before-repo-date`.
        public typealias BeforeRepoDate = Foundation.Date
    }
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {
        public struct ValidationFailedSimple: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/validation_failed_simple/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/validation_failed_simple/content/application\/json`.
                case json(Components.Schemas.ValidationErrorSimple)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ValidationErrorSimple {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.ValidationFailedSimple.Body
            /// Creates a new `ValidationFailedSimple`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.ValidationFailedSimple.Body) {
                self.body = body
            }
        }
        public struct NotFound: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/not_found/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/not_found/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.NotFound.Body
            /// Creates a new `NotFound`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.NotFound.Body) {
                self.body = body
            }
        }
        public struct BadRequest: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/bad_request/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/bad_request/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/json",
                                body: self
                            )
                        }
                    }
                }
                /// - Remark: Generated from `#/components/responses/bad_request/content/application\/scim+json`.
                case applicationScimJson(Components.Schemas.ScimError)
                /// The associated value of the enum case if `self` is `.applicationScimJson`.
                ///
                /// - Throws: An error if `self` is not `.applicationScimJson`.
                /// - SeeAlso: `.applicationScimJson`.
                public var applicationScimJson: Components.Schemas.ScimError {
                    get throws {
                        switch self {
                        case let .applicationScimJson(body):
                            return body
                        default:
                            try throwUnexpectedResponseBody(
                                expectedContent: "application/scim+json",
                                body: self
                            )
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.BadRequest.Body
            /// Creates a new `BadRequest`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.BadRequest.Body) {
                self.body = body
            }
        }
        public struct ValidationFailed: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/validation_failed/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/validation_failed/content/application\/json`.
                case json(Components.Schemas.ValidationError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.ValidationError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.ValidationFailed.Body
            /// Creates a new `ValidationFailed`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.ValidationFailed.Body) {
                self.body = body
            }
        }
        public struct Accepted: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/accepted/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/accepted/content/application\/json`.
                case json(OpenAPIRuntime.OpenAPIObjectContainer)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: OpenAPIRuntime.OpenAPIObjectContainer {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.Accepted.Body
            /// Creates a new `Accepted`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.Accepted.Body) {
                self.body = body
            }
        }
        public struct NotModified: Sendable, Hashable {
            /// Creates a new `NotModified`.
            public init() {}
        }
        public struct RequiresAuthentication: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/requires_authentication/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/requires_authentication/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.RequiresAuthentication.Body
            /// Creates a new `RequiresAuthentication`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.RequiresAuthentication.Body) {
                self.body = body
            }
        }
        public struct Forbidden: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/forbidden/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/forbidden/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.Forbidden.Body
            /// Creates a new `Forbidden`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.Forbidden.Body) {
                self.body = body
            }
        }
        public struct InternalError: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/internal_error/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/internal_error/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.InternalError.Body
            /// Creates a new `InternalError`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.InternalError.Body) {
                self.body = body
            }
        }
        public struct Conflict: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/conflict/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/conflict/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.Conflict.Body
            /// Creates a new `Conflict`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.Conflict.Body) {
                self.body = body
            }
        }
        public struct NoContent: Sendable, Hashable {
            /// Creates a new `NoContent`.
            public init() {}
        }
        public struct ServiceUnavailable: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/service_unavailable/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/service_unavailable/content/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/responses/service_unavailable/content/json/code`.
                    public var code: Swift.String?
                    /// - Remark: Generated from `#/components/responses/service_unavailable/content/json/message`.
                    public var message: Swift.String?
                    /// - Remark: Generated from `#/components/responses/service_unavailable/content/json/documentation_url`.
                    public var documentationUrl: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - code:
                    ///   - message:
                    ///   - documentationUrl:
                    public init(
                        code: Swift.String? = nil,
                        message: Swift.String? = nil,
                        documentationUrl: Swift.String? = nil
                    ) {
                        self.code = code
                        self.message = message
                        self.documentationUrl = documentationUrl
                    }
                    public enum CodingKeys: String, CodingKey {
                        case code
                        case message
                        case documentationUrl = "documentation_url"
                    }
                }
                /// - Remark: Generated from `#/components/responses/service_unavailable/content/application\/json`.
                case json(Components.Responses.ServiceUnavailable.Body.JsonPayload)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Responses.ServiceUnavailable.Body.JsonPayload {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.ServiceUnavailable.Body
            /// Creates a new `ServiceUnavailable`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.ServiceUnavailable.Body) {
                self.body = body
            }
        }
        public struct MovedPermanently: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/moved_permanently/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/moved_permanently/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.MovedPermanently.Body
            /// Creates a new `MovedPermanently`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.MovedPermanently.Body) {
                self.body = body
            }
        }
        public struct TemporaryRedirect: Sendable, Hashable {
            /// - Remark: Generated from `#/components/responses/temporary_redirect/content`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/components/responses/temporary_redirect/content/application\/json`.
                case json(Components.Schemas.BasicError)
                /// The associated value of the enum case if `self` is `.json`.
                ///
                /// - Throws: An error if `self` is not `.json`.
                /// - SeeAlso: `.json`.
                public var json: Components.Schemas.BasicError {
                    get throws {
                        switch self {
                        case let .json(body):
                            return body
                        }
                    }
                }
            }
            /// Received HTTP response body
            public var body: Components.Responses.TemporaryRedirect.Body
            /// Creates a new `TemporaryRedirect`.
            ///
            /// - Parameters:
            ///   - body: Received HTTP response body
            public init(body: Components.Responses.TemporaryRedirect.Body) {
                self.body = body
            }
        }
        public struct Found: Sendable, Hashable {
            /// Creates a new `Found`.
            public init() {}
        }
    }
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {
        /// - Remark: Generated from `#/components/headers/link`.
        public typealias Link = Swift.String
    }
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// List organization repositories
    ///
    /// Lists repositories for the specified organization.
    ///
    /// > [!NOTE]
    /// > In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/repos`.
    /// - Remark: Generated from `#/paths//orgs/{org}/repos/get(repos/list-for-org)`.
    public enum ReposListForOrg {
        public static let id: Swift.String = "repos/list-for-org"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/path/org`.
                public var org: Components.Parameters.Org
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                public init(org: Components.Parameters.Org) {
                    self.org = org
                }
            }
            public var path: Operations.ReposListForOrg.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/type`.
                @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case all = "all"
                    case _public = "public"
                    case _private = "private"
                    case forks = "forks"
                    case sources = "sources"
                    case member = "member"
                }
                /// Specifies the types of repositories you want returned.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/type`.
                public var _type: Operations.ReposListForOrg.Input.Query._TypePayload?
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/sort`.
                @frozen public enum SortPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case created = "created"
                    case updated = "updated"
                    case pushed = "pushed"
                    case fullName = "full_name"
                }
                /// The property to sort the results by.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/sort`.
                public var sort: Operations.ReposListForOrg.Input.Query.SortPayload?
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/direction`.
                @frozen public enum DirectionPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case asc = "asc"
                    case desc = "desc"
                }
                /// The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/direction`.
                public var direction: Operations.ReposListForOrg.Input.Query.DirectionPayload?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _type: Specifies the types of repositories you want returned.
                ///   - sort: The property to sort the results by.
                ///   - direction: The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    _type: Operations.ReposListForOrg.Input.Query._TypePayload? = nil,
                    sort: Operations.ReposListForOrg.Input.Query.SortPayload? = nil,
                    direction: Operations.ReposListForOrg.Input.Query.DirectionPayload? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self._type = _type
                    self.sort = sort
                    self.direction = direction
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListForOrg.Input.Query
            /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForOrg.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForOrg.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListForOrg.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListForOrg.Input.Path,
                query: Operations.ReposListForOrg.Input.Query = .init(),
                headers: Operations.ReposListForOrg.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListForOrg.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.MinimalRepository])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.MinimalRepository] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListForOrg.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListForOrg.Output.Ok.Headers = .init(),
                    body: Operations.ReposListForOrg.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/repos/get(repos/list-for-org)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListForOrg.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListForOrg.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create an organization repository
    ///
    /// Creates a new repository in the specified organization. The authenticated user must be a member of the organization.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /orgs/{org}/repos`.
    /// - Remark: Generated from `#/paths//orgs/{org}/repos/post(repos/create-in-org)`.
    public enum ReposCreateInOrg {
        public static let id: Swift.String = "repos/create-in-org"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/path/org`.
                public var org: Components.Parameters.Org
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                public init(org: Components.Parameters.Org) {
                    self.org = org
                }
            }
            public var path: Operations.ReposCreateInOrg.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateInOrg.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateInOrg.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateInOrg.Input.Headers
            /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/name`.
                    public var name: Swift.String
                    /// A short description of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/description`.
                    public var description: Swift.String?
                    /// A URL with more information about the repository.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/homepage`.
                    public var homepage: Swift.String?
                    /// Whether the repository is private.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/private`.
                    public var _private: Swift.Bool?
                    /// The visibility of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/visibility`.
                    @frozen public enum VisibilityPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case _public = "public"
                        case _private = "private"
                    }
                    /// The visibility of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/visibility`.
                    public var visibility: Operations.ReposCreateInOrg.Input.Body.JsonPayload.VisibilityPayload?
                    /// Either `true` to enable issues for this repository or `false` to disable them.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/has_issues`.
                    public var hasIssues: Swift.Bool?
                    /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/has_projects`.
                    public var hasProjects: Swift.Bool?
                    /// Either `true` to enable the wiki for this repository or `false` to disable it.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/has_wiki`.
                    public var hasWiki: Swift.Bool?
                    /// Whether downloads are enabled.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/has_downloads`.
                    public var hasDownloads: Swift.Bool?
                    /// Either `true` to make this repo available as a template repository or `false` to prevent it.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/is_template`.
                    public var isTemplate: Swift.Bool?
                    /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/team_id`.
                    public var teamId: Swift.Int?
                    /// Pass `true` to create an initial commit with empty README.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/auto_init`.
                    public var autoInit: Swift.Bool?
                    /// Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/gitignore_template`.
                    public var gitignoreTemplate: Swift.String?
                    /// Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/license_template`.
                    public var licenseTemplate: Swift.String?
                    /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/allow_squash_merge`.
                    public var allowSquashMerge: Swift.Bool?
                    /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/allow_merge_commit`.
                    public var allowMergeCommit: Swift.Bool?
                    /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/allow_rebase_merge`.
                    public var allowRebaseMerge: Swift.Bool?
                    /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/allow_auto_merge`.
                    public var allowAutoMerge: Swift.Bool?
                    /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/delete_branch_on_merge`.
                    public var deleteBranchOnMerge: Swift.Bool?
                    /// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/use_squash_pr_title_as_default`.
                    @available(*, deprecated)
                    public var useSquashPrTitleAsDefault: Swift.Bool?
                    /// Required when using `squash_merge_commit_message`.
                    ///
                    /// The default value for a squash merge commit title:
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/squash_merge_commit_title`.
                    @frozen public enum SquashMergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prTitle = "PR_TITLE"
                        case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
                    }
                    /// Required when using `squash_merge_commit_message`.
                    ///
                    /// The default value for a squash merge commit title:
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/squash_merge_commit_title`.
                    public var squashMergeCommitTitle: Operations.ReposCreateInOrg.Input.Body.JsonPayload.SquashMergeCommitTitlePayload?
                    /// The default value for a squash merge commit message:
                    ///
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/squash_merge_commit_message`.
                    @frozen public enum SquashMergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prBody = "PR_BODY"
                        case commitMessages = "COMMIT_MESSAGES"
                        case blank = "BLANK"
                    }
                    /// The default value for a squash merge commit message:
                    ///
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/squash_merge_commit_message`.
                    public var squashMergeCommitMessage: Operations.ReposCreateInOrg.Input.Body.JsonPayload.SquashMergeCommitMessagePayload?
                    /// Required when using `merge_commit_message`.
                    ///
                    /// The default value for a merge commit title.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/merge_commit_title`.
                    @frozen public enum MergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prTitle = "PR_TITLE"
                        case mergeMessage = "MERGE_MESSAGE"
                    }
                    /// Required when using `merge_commit_message`.
                    ///
                    /// The default value for a merge commit title.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/merge_commit_title`.
                    public var mergeCommitTitle: Operations.ReposCreateInOrg.Input.Body.JsonPayload.MergeCommitTitlePayload?
                    /// The default value for a merge commit message.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/merge_commit_message`.
                    @frozen public enum MergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prBody = "PR_BODY"
                        case prTitle = "PR_TITLE"
                        case blank = "BLANK"
                    }
                    /// The default value for a merge commit message.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/merge_commit_message`.
                    public var mergeCommitMessage: Operations.ReposCreateInOrg.Input.Body.JsonPayload.MergeCommitMessagePayload?
                    /// The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/custom_properties`.
                    public struct CustomPropertiesPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                        /// Creates a new `CustomPropertiesPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/json/custom_properties`.
                    public var customProperties: Operations.ReposCreateInOrg.Input.Body.JsonPayload.CustomPropertiesPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The name of the repository.
                    ///   - description: A short description of the repository.
                    ///   - homepage: A URL with more information about the repository.
                    ///   - _private: Whether the repository is private.
                    ///   - visibility: The visibility of the repository.
                    ///   - hasIssues: Either `true` to enable issues for this repository or `false` to disable them.
                    ///   - hasProjects: Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
                    ///   - hasWiki: Either `true` to enable the wiki for this repository or `false` to disable it.
                    ///   - hasDownloads: Whether downloads are enabled.
                    ///   - isTemplate: Either `true` to make this repo available as a template repository or `false` to prevent it.
                    ///   - teamId: The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
                    ///   - autoInit: Pass `true` to create an initial commit with empty README.
                    ///   - gitignoreTemplate: Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".
                    ///   - licenseTemplate: Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".
                    ///   - allowSquashMerge: Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
                    ///   - allowMergeCommit: Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
                    ///   - allowRebaseMerge: Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
                    ///   - allowAutoMerge: Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
                    ///   - deleteBranchOnMerge: Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion. **The authenticated user must be an organization owner to set this property to `true`.**
                    ///   - useSquashPrTitleAsDefault: Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
                    ///   - squashMergeCommitTitle: Required when using `squash_merge_commit_message`.
                    ///   - squashMergeCommitMessage: The default value for a squash merge commit message:
                    ///   - mergeCommitTitle: Required when using `merge_commit_message`.
                    ///   - mergeCommitMessage: The default value for a merge commit message.
                    ///   - customProperties: The custom properties for the new repository. The keys are the custom property names, and the values are the corresponding custom property values.
                    public init(
                        name: Swift.String,
                        description: Swift.String? = nil,
                        homepage: Swift.String? = nil,
                        _private: Swift.Bool? = nil,
                        visibility: Operations.ReposCreateInOrg.Input.Body.JsonPayload.VisibilityPayload? = nil,
                        hasIssues: Swift.Bool? = nil,
                        hasProjects: Swift.Bool? = nil,
                        hasWiki: Swift.Bool? = nil,
                        hasDownloads: Swift.Bool? = nil,
                        isTemplate: Swift.Bool? = nil,
                        teamId: Swift.Int? = nil,
                        autoInit: Swift.Bool? = nil,
                        gitignoreTemplate: Swift.String? = nil,
                        licenseTemplate: Swift.String? = nil,
                        allowSquashMerge: Swift.Bool? = nil,
                        allowMergeCommit: Swift.Bool? = nil,
                        allowRebaseMerge: Swift.Bool? = nil,
                        allowAutoMerge: Swift.Bool? = nil,
                        deleteBranchOnMerge: Swift.Bool? = nil,
                        useSquashPrTitleAsDefault: Swift.Bool? = nil,
                        squashMergeCommitTitle: Operations.ReposCreateInOrg.Input.Body.JsonPayload.SquashMergeCommitTitlePayload? = nil,
                        squashMergeCommitMessage: Operations.ReposCreateInOrg.Input.Body.JsonPayload.SquashMergeCommitMessagePayload? = nil,
                        mergeCommitTitle: Operations.ReposCreateInOrg.Input.Body.JsonPayload.MergeCommitTitlePayload? = nil,
                        mergeCommitMessage: Operations.ReposCreateInOrg.Input.Body.JsonPayload.MergeCommitMessagePayload? = nil,
                        customProperties: Operations.ReposCreateInOrg.Input.Body.JsonPayload.CustomPropertiesPayload? = nil
                    ) {
                        self.name = name
                        self.description = description
                        self.homepage = homepage
                        self._private = _private
                        self.visibility = visibility
                        self.hasIssues = hasIssues
                        self.hasProjects = hasProjects
                        self.hasWiki = hasWiki
                        self.hasDownloads = hasDownloads
                        self.isTemplate = isTemplate
                        self.teamId = teamId
                        self.autoInit = autoInit
                        self.gitignoreTemplate = gitignoreTemplate
                        self.licenseTemplate = licenseTemplate
                        self.allowSquashMerge = allowSquashMerge
                        self.allowMergeCommit = allowMergeCommit
                        self.allowRebaseMerge = allowRebaseMerge
                        self.allowAutoMerge = allowAutoMerge
                        self.deleteBranchOnMerge = deleteBranchOnMerge
                        self.useSquashPrTitleAsDefault = useSquashPrTitleAsDefault
                        self.squashMergeCommitTitle = squashMergeCommitTitle
                        self.squashMergeCommitMessage = squashMergeCommitMessage
                        self.mergeCommitTitle = mergeCommitTitle
                        self.mergeCommitMessage = mergeCommitMessage
                        self.customProperties = customProperties
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case description
                        case homepage
                        case _private = "private"
                        case visibility
                        case hasIssues = "has_issues"
                        case hasProjects = "has_projects"
                        case hasWiki = "has_wiki"
                        case hasDownloads = "has_downloads"
                        case isTemplate = "is_template"
                        case teamId = "team_id"
                        case autoInit = "auto_init"
                        case gitignoreTemplate = "gitignore_template"
                        case licenseTemplate = "license_template"
                        case allowSquashMerge = "allow_squash_merge"
                        case allowMergeCommit = "allow_merge_commit"
                        case allowRebaseMerge = "allow_rebase_merge"
                        case allowAutoMerge = "allow_auto_merge"
                        case deleteBranchOnMerge = "delete_branch_on_merge"
                        case useSquashPrTitleAsDefault = "use_squash_pr_title_as_default"
                        case squashMergeCommitTitle = "squash_merge_commit_title"
                        case squashMergeCommitMessage = "squash_merge_commit_message"
                        case mergeCommitTitle = "merge_commit_title"
                        case mergeCommitMessage = "merge_commit_message"
                        case customProperties = "custom_properties"
                    }
                }
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateInOrg.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateInOrg.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateInOrg.Input.Path,
                headers: Operations.ReposCreateInOrg.Input.Headers = .init(),
                body: Operations.ReposCreateInOrg.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateInOrg.Output.Created.Headers
                /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/repos/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.FullRepository)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FullRepository {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateInOrg.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateInOrg.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateInOrg.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/repos/post(repos/create-in-org)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateInOrg.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateInOrg.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/repos/post(repos/create-in-org)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/repos/post(repos/create-in-org)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get all organization repository rulesets
    ///
    /// Get all the repository rulesets for an organization.
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/get(repos/get-org-rulesets)`.
    public enum ReposGetOrgRulesets {
        public static let id: Swift.String = "repos/get-org-rulesets"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/path/org`.
                public var org: Components.Parameters.Org
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                public init(org: Components.Parameters.Org) {
                    self.org = org
                }
            }
            public var path: Operations.ReposGetOrgRulesets.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// A comma-separated list of rule targets to filter by.
                /// If provided, only rulesets that apply to the specified targets will be returned.
                /// For example, `branch,tag,push`.
                ///
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/query/targets`.
                public var targets: Components.Parameters.RulesetTargets?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - targets: A comma-separated list of rule targets to filter by.
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil,
                    targets: Components.Parameters.RulesetTargets? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                    self.targets = targets
                }
            }
            public var query: Operations.ReposGetOrgRulesets.Input.Query
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRulesets.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRulesets.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetOrgRulesets.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetOrgRulesets.Input.Path,
                query: Operations.ReposGetOrgRulesets.Input.Query = .init(),
                headers: Operations.ReposGetOrgRulesets.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.RepositoryRuleset])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.RepositoryRuleset] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetOrgRulesets.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetOrgRulesets.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/get(repos/get-org-rulesets)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetOrgRulesets.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetOrgRulesets.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/get(repos/get-org-rulesets)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/get(repos/get-org-rulesets)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create an organization repository ruleset
    ///
    /// Create a repository ruleset for an organization.
    ///
    /// - Remark: HTTP `POST /orgs/{org}/rulesets`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/post(repos/create-org-ruleset)`.
    public enum ReposCreateOrgRuleset {
        public static let id: Swift.String = "repos/create-org-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/path/org`.
                public var org: Components.Parameters.Org
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                public init(org: Components.Parameters.Org) {
                    self.org = org
                }
            }
            public var path: Operations.ReposCreateOrgRuleset.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrgRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrgRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateOrgRuleset.Input.Headers
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json/name`.
                    public var name: Swift.String
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json/target`.
                    @frozen public enum TargetPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case branch = "branch"
                        case tag = "tag"
                        case push = "push"
                        case repository = "repository"
                    }
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json/target`.
                    public var target: Operations.ReposCreateOrgRuleset.Input.Body.JsonPayload.TargetPayload?
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json/enforcement`.
                    public var enforcement: Components.Schemas.RepositoryRuleEnforcement
                    /// The actors that can bypass the rules in this ruleset
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json/bypass_actors`.
                    public var bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]?
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json/conditions`.
                    public var conditions: Components.Schemas.OrgRulesetConditions?
                    /// An array of rules within the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/json/rules`.
                    public var rules: [Components.Schemas.RepositoryRule]?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The name of the ruleset.
                    ///   - target: The target of the ruleset
                    ///   - enforcement:
                    ///   - bypassActors: The actors that can bypass the rules in this ruleset
                    ///   - conditions:
                    ///   - rules: An array of rules within the ruleset.
                    public init(
                        name: Swift.String,
                        target: Operations.ReposCreateOrgRuleset.Input.Body.JsonPayload.TargetPayload? = nil,
                        enforcement: Components.Schemas.RepositoryRuleEnforcement,
                        bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]? = nil,
                        conditions: Components.Schemas.OrgRulesetConditions? = nil,
                        rules: [Components.Schemas.RepositoryRule]? = nil
                    ) {
                        self.name = name
                        self.target = target
                        self.enforcement = enforcement
                        self.bypassActors = bypassActors
                        self.conditions = conditions
                        self.rules = rules
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case target
                        case enforcement
                        case bypassActors = "bypass_actors"
                        case conditions
                        case rules
                    }
                }
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateOrgRuleset.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateOrgRuleset.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateOrgRuleset.Input.Path,
                headers: Operations.ReposCreateOrgRuleset.Input.Headers = .init(),
                body: Operations.ReposCreateOrgRuleset.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.RepositoryRuleset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryRuleset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateOrgRuleset.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateOrgRuleset.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/post(repos/create-org-ruleset)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateOrgRuleset.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateOrgRuleset.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/post(repos/create-org-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/post(repos/create-org-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List organization rule suites
    ///
    /// Lists suites of rule evaluations at the organization level.
    /// For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/rule-suites`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/get(repos/get-org-rule-suites)`.
    public enum ReposGetOrgRuleSuites {
        public static let id: Swift.String = "repos/get-org-rule-suites"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/path/org`.
                public var org: Components.Parameters.Org
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                public init(org: Components.Parameters.Org) {
                    self.org = org
                }
            }
            public var path: Operations.ReposGetOrgRuleSuites.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query/ref`.
                public var ref: Components.Parameters.RefInQuery?
                /// The name of the repository to filter on.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query/repository_name`.
                public var repositoryName: Components.Parameters.RepositoryNameInQuery?
                /// - Remark: Generated from `#/components/parameters/time-period`.
                @frozen public enum TimePeriod: String, Codable, Hashable, Sendable, CaseIterable {
                    case hour = "hour"
                    case day = "day"
                    case week = "week"
                    case month = "month"
                }
                /// The time period to filter by.
                ///
                /// For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query/time_period`.
                public var timePeriod: Components.Parameters.TimePeriod?
                /// The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query/actor_name`.
                public var actorName: Components.Parameters.ActorNameInQuery?
                /// - Remark: Generated from `#/components/parameters/rule-suite-result`.
                @frozen public enum RuleSuiteResult: String, Codable, Hashable, Sendable, CaseIterable {
                    case pass = "pass"
                    case fail = "fail"
                    case bypass = "bypass"
                    case all = "all"
                }
                /// The rule results to filter on. When specified, only suites with this result will be returned.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query/rule_suite_result`.
                public var ruleSuiteResult: Components.Parameters.RuleSuiteResult?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - ref: The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
                ///   - repositoryName: The name of the repository to filter on.
                ///   - timePeriod: The time period to filter by.
                ///   - actorName: The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
                ///   - ruleSuiteResult: The rule results to filter on. When specified, only suites with this result will be returned.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    ref: Components.Parameters.RefInQuery? = nil,
                    repositoryName: Components.Parameters.RepositoryNameInQuery? = nil,
                    timePeriod: Components.Parameters.TimePeriod? = nil,
                    actorName: Components.Parameters.ActorNameInQuery? = nil,
                    ruleSuiteResult: Components.Parameters.RuleSuiteResult? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.ref = ref
                    self.repositoryName = repositoryName
                    self.timePeriod = timePeriod
                    self.actorName = actorName
                    self.ruleSuiteResult = ruleSuiteResult
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposGetOrgRuleSuites.Input.Query
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRuleSuites.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRuleSuites.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetOrgRuleSuites.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetOrgRuleSuites.Input.Path,
                query: Operations.ReposGetOrgRuleSuites.Input.Query = .init(),
                headers: Operations.ReposGetOrgRuleSuites.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RuleSuites)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RuleSuites {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetOrgRuleSuites.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetOrgRuleSuites.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/get(repos/get-org-rule-suites)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetOrgRuleSuites.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetOrgRuleSuites.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/get(repos/get-org-rule-suites)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/get(repos/get-org-rule-suites)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get an organization rule suite
    ///
    /// Gets information about a suite of rule evaluations from within an organization.
    /// For more information, see "[Managing rulesets for repositories in your organization](https://docs.github.com/organizations/managing-organization-settings/managing-rulesets-for-repositories-in-your-organization#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-org-rule-suite)`.
    public enum ReposGetOrgRuleSuite {
        public static let id: Swift.String = "repos/get-org-rule-suite"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/{rule_suite_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/{rule_suite_id}/GET/path/org`.
                public var org: Components.Parameters.Org
                /// The unique identifier of the rule suite result.
                /// To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
                /// for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
                /// for organizations.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/{rule_suite_id}/GET/path/rule_suite_id`.
                public var ruleSuiteId: Components.Parameters.RuleSuiteId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                ///   - ruleSuiteId: The unique identifier of the rule suite result.
                public init(
                    org: Components.Parameters.Org,
                    ruleSuiteId: Components.Parameters.RuleSuiteId
                ) {
                    self.org = org
                    self.ruleSuiteId = ruleSuiteId
                }
            }
            public var path: Operations.ReposGetOrgRuleSuite.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/{rule_suite_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRuleSuite.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRuleSuite.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetOrgRuleSuite.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetOrgRuleSuite.Input.Path,
                headers: Operations.ReposGetOrgRuleSuite.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/{rule_suite_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/rule-suites/{rule_suite_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RuleSuite)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RuleSuite {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetOrgRuleSuite.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetOrgRuleSuite.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-org-rule-suite)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetOrgRuleSuite.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetOrgRuleSuite.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-org-rule-suite)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-org-rule-suite)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get an organization repository ruleset
    ///
    /// Get a repository ruleset for an organization.
    ///
    /// **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
    /// making the API request has write access to the ruleset.
    ///
    /// - Remark: HTTP `GET /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/get(repos/get-org-ruleset)`.
    public enum ReposGetOrgRuleset {
        public static let id: Swift.String = "repos/get-org-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/GET/path/org`.
                public var org: Components.Parameters.Org
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/GET/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                public init(
                    org: Components.Parameters.Org,
                    rulesetId: Swift.Int
                ) {
                    self.org = org
                    self.rulesetId = rulesetId
                }
            }
            public var path: Operations.ReposGetOrgRuleset.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetOrgRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetOrgRuleset.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetOrgRuleset.Input.Path,
                headers: Operations.ReposGetOrgRuleset.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RepositoryRuleset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryRuleset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetOrgRuleset.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetOrgRuleset.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/get(repos/get-org-ruleset)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetOrgRuleset.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetOrgRuleset.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/get(repos/get-org-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/get(repos/get-org-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update an organization repository ruleset
    ///
    /// Update a ruleset for an organization.
    ///
    /// - Remark: HTTP `PUT /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/put(repos/update-org-ruleset)`.
    public enum ReposUpdateOrgRuleset {
        public static let id: Swift.String = "repos/update-org-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/path/org`.
                public var org: Components.Parameters.Org
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                public init(
                    org: Components.Parameters.Org,
                    rulesetId: Swift.Int
                ) {
                    self.org = org
                    self.rulesetId = rulesetId
                }
            }
            public var path: Operations.ReposUpdateOrgRuleset.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateOrgRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateOrgRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateOrgRuleset.Input.Headers
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json/name`.
                    public var name: Swift.String?
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json/target`.
                    @frozen public enum TargetPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case branch = "branch"
                        case tag = "tag"
                        case push = "push"
                        case repository = "repository"
                    }
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json/target`.
                    public var target: Operations.ReposUpdateOrgRuleset.Input.Body.JsonPayload.TargetPayload?
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json/enforcement`.
                    public var enforcement: Components.Schemas.RepositoryRuleEnforcement?
                    /// The actors that can bypass the rules in this ruleset
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json/bypass_actors`.
                    public var bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]?
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json/conditions`.
                    public var conditions: Components.Schemas.OrgRulesetConditions?
                    /// An array of rules within the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/json/rules`.
                    public var rules: [Components.Schemas.RepositoryRule]?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The name of the ruleset.
                    ///   - target: The target of the ruleset
                    ///   - enforcement:
                    ///   - bypassActors: The actors that can bypass the rules in this ruleset
                    ///   - conditions:
                    ///   - rules: An array of rules within the ruleset.
                    public init(
                        name: Swift.String? = nil,
                        target: Operations.ReposUpdateOrgRuleset.Input.Body.JsonPayload.TargetPayload? = nil,
                        enforcement: Components.Schemas.RepositoryRuleEnforcement? = nil,
                        bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]? = nil,
                        conditions: Components.Schemas.OrgRulesetConditions? = nil,
                        rules: [Components.Schemas.RepositoryRule]? = nil
                    ) {
                        self.name = name
                        self.target = target
                        self.enforcement = enforcement
                        self.bypassActors = bypassActors
                        self.conditions = conditions
                        self.rules = rules
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case target
                        case enforcement
                        case bypassActors = "bypass_actors"
                        case conditions
                        case rules
                    }
                }
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateOrgRuleset.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateOrgRuleset.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateOrgRuleset.Input.Path,
                headers: Operations.ReposUpdateOrgRuleset.Input.Headers = .init(),
                body: Operations.ReposUpdateOrgRuleset.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/PUT/responses/200/content/application\/json`.
                    case json(Components.Schemas.RepositoryRuleset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryRuleset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateOrgRuleset.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateOrgRuleset.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/put(repos/update-org-ruleset)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateOrgRuleset.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateOrgRuleset.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/put(repos/update-org-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/put(repos/update-org-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete an organization repository ruleset
    ///
    /// Delete a ruleset for an organization.
    ///
    /// - Remark: HTTP `DELETE /orgs/{org}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/delete(repos/delete-org-ruleset)`.
    public enum ReposDeleteOrgRuleset {
        public static let id: Swift.String = "repos/delete-org-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The organization name. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/DELETE/path/org`.
                public var org: Components.Parameters.Org
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/DELETE/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - org: The organization name. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                public init(
                    org: Components.Parameters.Org,
                    rulesetId: Swift.Int
                ) {
                    self.org = org
                    self.rulesetId = rulesetId
                }
            }
            public var path: Operations.ReposDeleteOrgRuleset.Input.Path
            /// - Remark: Generated from `#/paths/orgs/{org}/rulesets/{ruleset_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteOrgRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteOrgRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteOrgRuleset.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteOrgRuleset.Input.Path,
                headers: Operations.ReposDeleteOrgRuleset.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/delete(repos/delete-org-ruleset)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteOrgRuleset.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/delete(repos/delete-org-ruleset)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteOrgRuleset.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/delete(repos/delete-org-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//orgs/{org}/rulesets/{ruleset_id}/delete(repos/delete-org-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a repository
    ///
    /// The `parent` and `source` objects are present when the repository is a fork. `parent` is the repository this repository was forked from, `source` is the ultimate source for the network.
    ///
    /// > [!NOTE]
    /// > In order to see the `security_and_analysis` block for a repository you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)`.
    public enum ReposGet {
        public static let id: Swift.String = "repos/get"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGet.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGet.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGet.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGet.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGet.Input.Path,
                headers: Operations.ReposGet.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.FullRepository)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FullRepository {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGet.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGet.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGet.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGet.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Moved permanently
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/get(repos/get)/responses/301`.
            ///
            /// HTTP response code: `301 movedPermanently`.
            case movedPermanently(Components.Responses.MovedPermanently)
            /// The associated value of the enum case if `self` is `.movedPermanently`.
            ///
            /// - Throws: An error if `self` is not `.movedPermanently`.
            /// - SeeAlso: `.movedPermanently`.
            public var movedPermanently: Components.Responses.MovedPermanently {
                get throws {
                    switch self {
                    case let .movedPermanently(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "movedPermanently",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a repository
    ///
    /// **Note**: To edit a repository's topics, use the [Replace all repository topics](https://docs.github.com/rest/repos/repos#replace-all-repository-topics) endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)`.
    public enum ReposUpdate {
        public static let id: Swift.String = "repos/update"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposUpdate.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdate.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdate.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdate.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/name`.
                    public var name: Swift.String?
                    /// A short description of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/description`.
                    public var description: Swift.String?
                    /// A URL with more information about the repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/homepage`.
                    public var homepage: Swift.String?
                    /// Either `true` to make the repository private or `false` to make it public. Default: `false`.  
                    /// **Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/private`.
                    public var _private: Swift.Bool?
                    /// The visibility of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/visibility`.
                    @frozen public enum VisibilityPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case _public = "public"
                        case _private = "private"
                    }
                    /// The visibility of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/visibility`.
                    public var visibility: Operations.ReposUpdate.Input.Body.JsonPayload.VisibilityPayload?
                    /// Specify which security and analysis features to enable or disable for the repository.
                    ///
                    /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
                    ///
                    /// For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:
                    /// `{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.
                    ///
                    /// You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis`.
                    public struct SecurityAndAnalysisPayload: Codable, Hashable, Sendable {
                        /// Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/advanced_security`.
                        public struct AdvancedSecurityPayload: Codable, Hashable, Sendable {
                            /// Can be `enabled` or `disabled`.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/advanced_security/status`.
                            public var status: Swift.String?
                            /// Creates a new `AdvancedSecurityPayload`.
                            ///
                            /// - Parameters:
                            ///   - status: Can be `enabled` or `disabled`.
                            public init(status: Swift.String? = nil) {
                                self.status = status
                            }
                            public enum CodingKeys: String, CodingKey {
                                case status
                            }
                        }
                        /// Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/advanced_security`.
                        public var advancedSecurity: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.AdvancedSecurityPayload?
                        /// Use the `status` property to enable or disable GitHub Code Security for this repository.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/code_security`.
                        public struct CodeSecurityPayload: Codable, Hashable, Sendable {
                            /// Can be `enabled` or `disabled`.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/code_security/status`.
                            public var status: Swift.String?
                            /// Creates a new `CodeSecurityPayload`.
                            ///
                            /// - Parameters:
                            ///   - status: Can be `enabled` or `disabled`.
                            public init(status: Swift.String? = nil) {
                                self.status = status
                            }
                            public enum CodingKeys: String, CodingKey {
                                case status
                            }
                        }
                        /// Use the `status` property to enable or disable GitHub Code Security for this repository.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/code_security`.
                        public var codeSecurity: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.CodeSecurityPayload?
                        /// Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning`.
                        public struct SecretScanningPayload: Codable, Hashable, Sendable {
                            /// Can be `enabled` or `disabled`.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning/status`.
                            public var status: Swift.String?
                            /// Creates a new `SecretScanningPayload`.
                            ///
                            /// - Parameters:
                            ///   - status: Can be `enabled` or `disabled`.
                            public init(status: Swift.String? = nil) {
                                self.status = status
                            }
                            public enum CodingKeys: String, CodingKey {
                                case status
                            }
                        }
                        /// Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning`.
                        public var secretScanning: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningPayload?
                        /// Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_push_protection`.
                        public struct SecretScanningPushProtectionPayload: Codable, Hashable, Sendable {
                            /// Can be `enabled` or `disabled`.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_push_protection/status`.
                            public var status: Swift.String?
                            /// Creates a new `SecretScanningPushProtectionPayload`.
                            ///
                            /// - Parameters:
                            ///   - status: Can be `enabled` or `disabled`.
                            public init(status: Swift.String? = nil) {
                                self.status = status
                            }
                            public enum CodingKeys: String, CodingKey {
                                case status
                            }
                        }
                        /// Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_push_protection`.
                        public var secretScanningPushProtection: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningPushProtectionPayload?
                        /// Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see "[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_ai_detection`.
                        public struct SecretScanningAiDetectionPayload: Codable, Hashable, Sendable {
                            /// Can be `enabled` or `disabled`.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_ai_detection/status`.
                            public var status: Swift.String?
                            /// Creates a new `SecretScanningAiDetectionPayload`.
                            ///
                            /// - Parameters:
                            ///   - status: Can be `enabled` or `disabled`.
                            public init(status: Swift.String? = nil) {
                                self.status = status
                            }
                            public enum CodingKeys: String, CodingKey {
                                case status
                            }
                        }
                        /// Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see "[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_ai_detection`.
                        public var secretScanningAiDetection: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningAiDetectionPayload?
                        /// Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see "[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_non_provider_patterns`.
                        public struct SecretScanningNonProviderPatternsPayload: Codable, Hashable, Sendable {
                            /// Can be `enabled` or `disabled`.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_non_provider_patterns/status`.
                            public var status: Swift.String?
                            /// Creates a new `SecretScanningNonProviderPatternsPayload`.
                            ///
                            /// - Parameters:
                            ///   - status: Can be `enabled` or `disabled`.
                            public init(status: Swift.String? = nil) {
                                self.status = status
                            }
                            public enum CodingKeys: String, CodingKey {
                                case status
                            }
                        }
                        /// Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see "[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis/secret_scanning_non_provider_patterns`.
                        public var secretScanningNonProviderPatterns: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningNonProviderPatternsPayload?
                        /// Creates a new `SecurityAndAnalysisPayload`.
                        ///
                        /// - Parameters:
                        ///   - advancedSecurity: Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."
                        ///   - codeSecurity: Use the `status` property to enable or disable GitHub Code Security for this repository.
                        ///   - secretScanning: Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."
                        ///   - secretScanningPushProtection: Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."
                        ///   - secretScanningAiDetection: Use the `status` property to enable or disable secret scanning AI detection for this repository. For more information, see "[Responsible detection of generic secrets with AI](https://docs.github.com/code-security/secret-scanning/using-advanced-secret-scanning-and-push-protection-features/generic-secret-detection/responsible-ai-generic-secrets)."
                        ///   - secretScanningNonProviderPatterns: Use the `status` property to enable or disable secret scanning non-provider patterns for this repository. For more information, see "[Supported secret scanning patterns](/code-security/secret-scanning/introduction/supported-secret-scanning-patterns#supported-secrets)."
                        public init(
                            advancedSecurity: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.AdvancedSecurityPayload? = nil,
                            codeSecurity: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.CodeSecurityPayload? = nil,
                            secretScanning: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningPayload? = nil,
                            secretScanningPushProtection: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningPushProtectionPayload? = nil,
                            secretScanningAiDetection: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningAiDetectionPayload? = nil,
                            secretScanningNonProviderPatterns: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload.SecretScanningNonProviderPatternsPayload? = nil
                        ) {
                            self.advancedSecurity = advancedSecurity
                            self.codeSecurity = codeSecurity
                            self.secretScanning = secretScanning
                            self.secretScanningPushProtection = secretScanningPushProtection
                            self.secretScanningAiDetection = secretScanningAiDetection
                            self.secretScanningNonProviderPatterns = secretScanningNonProviderPatterns
                        }
                        public enum CodingKeys: String, CodingKey {
                            case advancedSecurity = "advanced_security"
                            case codeSecurity = "code_security"
                            case secretScanning = "secret_scanning"
                            case secretScanningPushProtection = "secret_scanning_push_protection"
                            case secretScanningAiDetection = "secret_scanning_ai_detection"
                            case secretScanningNonProviderPatterns = "secret_scanning_non_provider_patterns"
                        }
                    }
                    /// Specify which security and analysis features to enable or disable for the repository.
                    ///
                    /// To use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."
                    ///
                    /// For example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:
                    /// `{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.
                    ///
                    /// You can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/security_and_analysis`.
                    public var securityAndAnalysis: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload?
                    /// Either `true` to enable issues for this repository or `false` to disable them.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/has_issues`.
                    public var hasIssues: Swift.Bool?
                    /// Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/has_projects`.
                    public var hasProjects: Swift.Bool?
                    /// Either `true` to enable the wiki for this repository or `false` to disable it.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/has_wiki`.
                    public var hasWiki: Swift.Bool?
                    /// Either `true` to make this repo available as a template repository or `false` to prevent it.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/is_template`.
                    public var isTemplate: Swift.Bool?
                    /// Updates the default branch for this repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/default_branch`.
                    public var defaultBranch: Swift.String?
                    /// Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/allow_squash_merge`.
                    public var allowSquashMerge: Swift.Bool?
                    /// Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/allow_merge_commit`.
                    public var allowMergeCommit: Swift.Bool?
                    /// Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/allow_rebase_merge`.
                    public var allowRebaseMerge: Swift.Bool?
                    /// Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/allow_auto_merge`.
                    public var allowAutoMerge: Swift.Bool?
                    /// Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/delete_branch_on_merge`.
                    public var deleteBranchOnMerge: Swift.Bool?
                    /// Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/allow_update_branch`.
                    public var allowUpdateBranch: Swift.Bool?
                    /// Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/use_squash_pr_title_as_default`.
                    @available(*, deprecated)
                    public var useSquashPrTitleAsDefault: Swift.Bool?
                    /// Required when using `squash_merge_commit_message`.
                    ///
                    /// The default value for a squash merge commit title:
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/squash_merge_commit_title`.
                    @frozen public enum SquashMergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prTitle = "PR_TITLE"
                        case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
                    }
                    /// Required when using `squash_merge_commit_message`.
                    ///
                    /// The default value for a squash merge commit title:
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/squash_merge_commit_title`.
                    public var squashMergeCommitTitle: Operations.ReposUpdate.Input.Body.JsonPayload.SquashMergeCommitTitlePayload?
                    /// The default value for a squash merge commit message:
                    ///
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/squash_merge_commit_message`.
                    @frozen public enum SquashMergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prBody = "PR_BODY"
                        case commitMessages = "COMMIT_MESSAGES"
                        case blank = "BLANK"
                    }
                    /// The default value for a squash merge commit message:
                    ///
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/squash_merge_commit_message`.
                    public var squashMergeCommitMessage: Operations.ReposUpdate.Input.Body.JsonPayload.SquashMergeCommitMessagePayload?
                    /// Required when using `merge_commit_message`.
                    ///
                    /// The default value for a merge commit title.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/merge_commit_title`.
                    @frozen public enum MergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prTitle = "PR_TITLE"
                        case mergeMessage = "MERGE_MESSAGE"
                    }
                    /// Required when using `merge_commit_message`.
                    ///
                    /// The default value for a merge commit title.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/merge_commit_title`.
                    public var mergeCommitTitle: Operations.ReposUpdate.Input.Body.JsonPayload.MergeCommitTitlePayload?
                    /// The default value for a merge commit message.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/merge_commit_message`.
                    @frozen public enum MergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prBody = "PR_BODY"
                        case prTitle = "PR_TITLE"
                        case blank = "BLANK"
                    }
                    /// The default value for a merge commit message.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/merge_commit_message`.
                    public var mergeCommitMessage: Operations.ReposUpdate.Input.Body.JsonPayload.MergeCommitMessagePayload?
                    /// Whether to archive this repository. `false` will unarchive a previously archived repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/archived`.
                    public var archived: Swift.Bool?
                    /// Either `true` to allow private forks, or `false` to prevent private forks.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/allow_forking`.
                    public var allowForking: Swift.Bool?
                    /// Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/json/web_commit_signoff_required`.
                    public var webCommitSignoffRequired: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The name of the repository.
                    ///   - description: A short description of the repository.
                    ///   - homepage: A URL with more information about the repository.
                    ///   - _private: Either `true` to make the repository private or `false` to make it public. Default: `false`.  
                    ///   - visibility: The visibility of the repository.
                    ///   - securityAndAnalysis: Specify which security and analysis features to enable or disable for the repository.
                    ///   - hasIssues: Either `true` to enable issues for this repository or `false` to disable them.
                    ///   - hasProjects: Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.
                    ///   - hasWiki: Either `true` to enable the wiki for this repository or `false` to disable it.
                    ///   - isTemplate: Either `true` to make this repo available as a template repository or `false` to prevent it.
                    ///   - defaultBranch: Updates the default branch for this repository.
                    ///   - allowSquashMerge: Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.
                    ///   - allowMergeCommit: Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.
                    ///   - allowRebaseMerge: Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.
                    ///   - allowAutoMerge: Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.
                    ///   - deleteBranchOnMerge: Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.
                    ///   - allowUpdateBranch: Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.
                    ///   - useSquashPrTitleAsDefault: Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property is closing down. Please use `squash_merge_commit_title` instead.
                    ///   - squashMergeCommitTitle: Required when using `squash_merge_commit_message`.
                    ///   - squashMergeCommitMessage: The default value for a squash merge commit message:
                    ///   - mergeCommitTitle: Required when using `merge_commit_message`.
                    ///   - mergeCommitMessage: The default value for a merge commit message.
                    ///   - archived: Whether to archive this repository. `false` will unarchive a previously archived repository.
                    ///   - allowForking: Either `true` to allow private forks, or `false` to prevent private forks.
                    ///   - webCommitSignoffRequired: Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.
                    public init(
                        name: Swift.String? = nil,
                        description: Swift.String? = nil,
                        homepage: Swift.String? = nil,
                        _private: Swift.Bool? = nil,
                        visibility: Operations.ReposUpdate.Input.Body.JsonPayload.VisibilityPayload? = nil,
                        securityAndAnalysis: Operations.ReposUpdate.Input.Body.JsonPayload.SecurityAndAnalysisPayload? = nil,
                        hasIssues: Swift.Bool? = nil,
                        hasProjects: Swift.Bool? = nil,
                        hasWiki: Swift.Bool? = nil,
                        isTemplate: Swift.Bool? = nil,
                        defaultBranch: Swift.String? = nil,
                        allowSquashMerge: Swift.Bool? = nil,
                        allowMergeCommit: Swift.Bool? = nil,
                        allowRebaseMerge: Swift.Bool? = nil,
                        allowAutoMerge: Swift.Bool? = nil,
                        deleteBranchOnMerge: Swift.Bool? = nil,
                        allowUpdateBranch: Swift.Bool? = nil,
                        useSquashPrTitleAsDefault: Swift.Bool? = nil,
                        squashMergeCommitTitle: Operations.ReposUpdate.Input.Body.JsonPayload.SquashMergeCommitTitlePayload? = nil,
                        squashMergeCommitMessage: Operations.ReposUpdate.Input.Body.JsonPayload.SquashMergeCommitMessagePayload? = nil,
                        mergeCommitTitle: Operations.ReposUpdate.Input.Body.JsonPayload.MergeCommitTitlePayload? = nil,
                        mergeCommitMessage: Operations.ReposUpdate.Input.Body.JsonPayload.MergeCommitMessagePayload? = nil,
                        archived: Swift.Bool? = nil,
                        allowForking: Swift.Bool? = nil,
                        webCommitSignoffRequired: Swift.Bool? = nil
                    ) {
                        self.name = name
                        self.description = description
                        self.homepage = homepage
                        self._private = _private
                        self.visibility = visibility
                        self.securityAndAnalysis = securityAndAnalysis
                        self.hasIssues = hasIssues
                        self.hasProjects = hasProjects
                        self.hasWiki = hasWiki
                        self.isTemplate = isTemplate
                        self.defaultBranch = defaultBranch
                        self.allowSquashMerge = allowSquashMerge
                        self.allowMergeCommit = allowMergeCommit
                        self.allowRebaseMerge = allowRebaseMerge
                        self.allowAutoMerge = allowAutoMerge
                        self.deleteBranchOnMerge = deleteBranchOnMerge
                        self.allowUpdateBranch = allowUpdateBranch
                        self.useSquashPrTitleAsDefault = useSquashPrTitleAsDefault
                        self.squashMergeCommitTitle = squashMergeCommitTitle
                        self.squashMergeCommitMessage = squashMergeCommitMessage
                        self.mergeCommitTitle = mergeCommitTitle
                        self.mergeCommitMessage = mergeCommitMessage
                        self.archived = archived
                        self.allowForking = allowForking
                        self.webCommitSignoffRequired = webCommitSignoffRequired
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case description
                        case homepage
                        case _private = "private"
                        case visibility
                        case securityAndAnalysis = "security_and_analysis"
                        case hasIssues = "has_issues"
                        case hasProjects = "has_projects"
                        case hasWiki = "has_wiki"
                        case isTemplate = "is_template"
                        case defaultBranch = "default_branch"
                        case allowSquashMerge = "allow_squash_merge"
                        case allowMergeCommit = "allow_merge_commit"
                        case allowRebaseMerge = "allow_rebase_merge"
                        case allowAutoMerge = "allow_auto_merge"
                        case deleteBranchOnMerge = "delete_branch_on_merge"
                        case allowUpdateBranch = "allow_update_branch"
                        case useSquashPrTitleAsDefault = "use_squash_pr_title_as_default"
                        case squashMergeCommitTitle = "squash_merge_commit_title"
                        case squashMergeCommitMessage = "squash_merge_commit_message"
                        case mergeCommitTitle = "merge_commit_title"
                        case mergeCommitMessage = "merge_commit_message"
                        case archived
                        case allowForking = "allow_forking"
                        case webCommitSignoffRequired = "web_commit_signoff_required"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdate.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdate.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdate.Input.Path,
                headers: Operations.ReposUpdate.Input.Headers = .init(),
                body: Operations.ReposUpdate.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.FullRepository)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FullRepository {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdate.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdate.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdate.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdate.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Temporary Redirect
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)/responses/307`.
            ///
            /// HTTP response code: `307 temporaryRedirect`.
            case temporaryRedirect(Components.Responses.TemporaryRedirect)
            /// The associated value of the enum case if `self` is `.temporaryRedirect`.
            ///
            /// - Throws: An error if `self` is not `.temporaryRedirect`.
            /// - SeeAlso: `.temporaryRedirect`.
            public var temporaryRedirect: Components.Responses.TemporaryRedirect {
                get throws {
                    switch self {
                    case let .temporaryRedirect(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "temporaryRedirect",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/patch(repos/update)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a repository
    ///
    /// Deleting a repository requires admin access.
    ///
    /// If an organization owner has configured the organization to prevent members from deleting organization-owned
    /// repositories, you will get a `403 Forbidden` response.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `delete_repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)`.
    public enum ReposDelete {
        public static let id: Swift.String = "repos/delete"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposDelete.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDelete.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDelete.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDelete.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDelete.Input.Path,
                headers: Operations.ReposDelete.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDelete.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDelete.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            public struct Forbidden: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/responses/403/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/responses/403/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/responses/403/content/json/message`.
                        public var message: Swift.String?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/responses/403/content/json/documentation_url`.
                        public var documentationUrl: Swift.String?
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - message:
                        ///   - documentationUrl:
                        public init(
                            message: Swift.String? = nil,
                            documentationUrl: Swift.String? = nil
                        ) {
                            self.message = message
                            self.documentationUrl = documentationUrl
                        }
                        public enum CodingKeys: String, CodingKey {
                            case message
                            case documentationUrl = "documentation_url"
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/DELETE/responses/403/content/application\/json`.
                    case json(Operations.ReposDelete.Output.Forbidden.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposDelete.Output.Forbidden.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposDelete.Output.Forbidden.Body
                /// Creates a new `Forbidden`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposDelete.Output.Forbidden.Body) {
                    self.body = body
                }
            }
            /// If an organization owner has configured the organization to prevent members from deleting organization-owned repositories, a member will get this response:
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Operations.ReposDelete.Output.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Operations.ReposDelete.Output.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Temporary Redirect
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)/responses/307`.
            ///
            /// HTTP response code: `307 temporaryRedirect`.
            case temporaryRedirect(Components.Responses.TemporaryRedirect)
            /// The associated value of the enum case if `self` is `.temporaryRedirect`.
            ///
            /// - Throws: An error if `self` is not `.temporaryRedirect`.
            /// - SeeAlso: `.temporaryRedirect`.
            public var temporaryRedirect: Components.Responses.TemporaryRedirect {
                get throws {
                    switch self {
                    case let .temporaryRedirect(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "temporaryRedirect",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/delete(repos/delete)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repository activities
    ///
    /// Lists a detailed history of changes to a repository, such as pushes, merges, force pushes, and branch changes, and associates these changes with commits and users.
    ///
    /// For more information about viewing repository activity,
    /// see "[Viewing activity and data for your repository](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/activity`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/activity/get(repos/list-activities)`.
    public enum ReposListActivities {
        public static let id: Swift.String = "repos/list-activities"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListActivities.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/direction`.
                @frozen public enum Direction: String, Codable, Hashable, Sendable, CaseIterable {
                    case asc = "asc"
                    case desc = "desc"
                }
                /// The direction to sort the results by.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/direction`.
                public var direction: Components.Parameters.Direction?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/before`.
                public var before: Components.Parameters.PaginationBefore?
                /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/after`.
                public var after: Components.Parameters.PaginationAfter?
                /// The Git reference for the activities you want to list.
                ///
                /// The `ref` for a branch can be formatted either as `refs/heads/BRANCH_NAME` or `BRANCH_NAME`, where `BRANCH_NAME` is the name of your branch.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/ref`.
                public var ref: Swift.String?
                /// The GitHub username to use to filter by the actor who performed the activity.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/actor`.
                public var actor: Swift.String?
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/time_period`.
                @frozen public enum TimePeriodPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case day = "day"
                    case week = "week"
                    case month = "month"
                    case quarter = "quarter"
                    case year = "year"
                }
                /// The time period to filter by.
                ///
                /// For example, `day` will filter for activity that occurred in the past 24 hours, and `week` will filter for activity that occurred in the past 7 days (168 hours).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/time_period`.
                public var timePeriod: Operations.ReposListActivities.Input.Query.TimePeriodPayload?
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/activity_type`.
                @frozen public enum ActivityTypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case push = "push"
                    case forcePush = "force_push"
                    case branchCreation = "branch_creation"
                    case branchDeletion = "branch_deletion"
                    case prMerge = "pr_merge"
                    case mergeQueueMerge = "merge_queue_merge"
                }
                /// The activity type to filter by.
                ///
                /// For example, you can choose to filter by "force_push", to see all force pushes to the repository.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/query/activity_type`.
                public var activityType: Operations.ReposListActivities.Input.Query.ActivityTypePayload?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - direction: The direction to sort the results by.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - before: A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - after: A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - ref: The Git reference for the activities you want to list.
                ///   - actor: The GitHub username to use to filter by the actor who performed the activity.
                ///   - timePeriod: The time period to filter by.
                ///   - activityType: The activity type to filter by.
                public init(
                    direction: Components.Parameters.Direction? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    before: Components.Parameters.PaginationBefore? = nil,
                    after: Components.Parameters.PaginationAfter? = nil,
                    ref: Swift.String? = nil,
                    actor: Swift.String? = nil,
                    timePeriod: Operations.ReposListActivities.Input.Query.TimePeriodPayload? = nil,
                    activityType: Operations.ReposListActivities.Input.Query.ActivityTypePayload? = nil
                ) {
                    self.direction = direction
                    self.perPage = perPage
                    self.before = before
                    self.after = after
                    self.ref = ref
                    self.actor = actor
                    self.timePeriod = timePeriod
                    self.activityType = activityType
                }
            }
            public var query: Operations.ReposListActivities.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListActivities.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListActivities.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListActivities.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListActivities.Input.Path,
                query: Operations.ReposListActivities.Input.Query = .init(),
                headers: Operations.ReposListActivities.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListActivities.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/activity/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Activity])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Activity] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListActivities.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListActivities.Output.Ok.Headers = .init(),
                    body: Operations.ReposListActivities.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/activity/get(repos/list-activities)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListActivities.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListActivities.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/activity/get(repos/list-activities)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailedSimple)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailedSimple {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create an attestation
    ///
    /// Store an artifact attestation and associate it with a repository.
    ///
    /// The authenticated user must have write permission to the repository and, if using a fine-grained access token, the `attestations:write` permission is required.
    ///
    /// Artifact attestations are meant to be created using the [attest action](https://github.com/actions/attest). For more information, see our guide on [using artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/attestations`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/post(repos/create-attestation)`.
    public enum ReposCreateAttestation {
        public static let id: Swift.String = "repos/create-attestation"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateAttestation.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateAttestation.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateAttestation.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateAttestation.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The attestation's Sigstore Bundle.
                    /// Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json/bundle`.
                    public struct BundlePayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json/bundle/mediaType`.
                        public var mediaType: Swift.String?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json/bundle/verificationMaterial`.
                        public struct VerificationMaterialPayload: Codable, Hashable, Sendable {
                            /// A container of undocumented properties.
                            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                            /// Creates a new `VerificationMaterialPayload`.
                            ///
                            /// - Parameters:
                            ///   - additionalProperties: A container of undocumented properties.
                            public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                                self.additionalProperties = additionalProperties
                            }
                            public init(from decoder: any Decoder) throws {
                                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                            }
                            public func encode(to encoder: any Encoder) throws {
                                try encoder.encodeAdditionalProperties(additionalProperties)
                            }
                        }
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json/bundle/verificationMaterial`.
                        public var verificationMaterial: Operations.ReposCreateAttestation.Input.Body.JsonPayload.BundlePayload.VerificationMaterialPayload?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json/bundle/dsseEnvelope`.
                        public struct DsseEnvelopePayload: Codable, Hashable, Sendable {
                            /// A container of undocumented properties.
                            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                            /// Creates a new `DsseEnvelopePayload`.
                            ///
                            /// - Parameters:
                            ///   - additionalProperties: A container of undocumented properties.
                            public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                                self.additionalProperties = additionalProperties
                            }
                            public init(from decoder: any Decoder) throws {
                                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                            }
                            public func encode(to encoder: any Encoder) throws {
                                try encoder.encodeAdditionalProperties(additionalProperties)
                            }
                        }
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json/bundle/dsseEnvelope`.
                        public var dsseEnvelope: Operations.ReposCreateAttestation.Input.Body.JsonPayload.BundlePayload.DsseEnvelopePayload?
                        /// Creates a new `BundlePayload`.
                        ///
                        /// - Parameters:
                        ///   - mediaType:
                        ///   - verificationMaterial:
                        ///   - dsseEnvelope:
                        public init(
                            mediaType: Swift.String? = nil,
                            verificationMaterial: Operations.ReposCreateAttestation.Input.Body.JsonPayload.BundlePayload.VerificationMaterialPayload? = nil,
                            dsseEnvelope: Operations.ReposCreateAttestation.Input.Body.JsonPayload.BundlePayload.DsseEnvelopePayload? = nil
                        ) {
                            self.mediaType = mediaType
                            self.verificationMaterial = verificationMaterial
                            self.dsseEnvelope = dsseEnvelope
                        }
                        public enum CodingKeys: String, CodingKey {
                            case mediaType
                            case verificationMaterial
                            case dsseEnvelope
                        }
                    }
                    /// The attestation's Sigstore Bundle.
                    /// Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/json/bundle`.
                    public var bundle: Operations.ReposCreateAttestation.Input.Body.JsonPayload.BundlePayload
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - bundle: The attestation's Sigstore Bundle.
                    public init(bundle: Operations.ReposCreateAttestation.Input.Body.JsonPayload.BundlePayload) {
                        self.bundle = bundle
                    }
                    public enum CodingKeys: String, CodingKey {
                        case bundle
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateAttestation.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateAttestation.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateAttestation.Input.Path,
                headers: Operations.ReposCreateAttestation.Input.Headers = .init(),
                body: Operations.ReposCreateAttestation.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/responses/201/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// The ID of the attestation.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/responses/201/content/json/id`.
                        public var id: Swift.Int?
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - id: The ID of the attestation.
                        public init(id: Swift.Int? = nil) {
                            self.id = id
                        }
                        public enum CodingKeys: String, CodingKey {
                            case id
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/POST/responses/201/content/application\/json`.
                    case json(Operations.ReposCreateAttestation.Output.Created.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposCreateAttestation.Output.Created.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateAttestation.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateAttestation.Output.Created.Body) {
                    self.body = body
                }
            }
            /// response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/post(repos/create-attestation)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateAttestation.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateAttestation.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/post(repos/create-attestation)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/post(repos/create-attestation)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List attestations
    ///
    /// List a collection of artifact attestations with a given subject digest that are associated with a repository.
    ///
    /// The authenticated user making the request must have read access to the repository. In addition, when using a fine-grained access token the `attestations:read` permission is required.
    ///
    /// **Please note:** in order to offer meaningful security benefits, an attestation's signature and timestamps **must** be cryptographically verified, and the identity of the attestation signer **must** be validated. Attestations can be verified using the [GitHub CLI `attestation verify` command](https://cli.github.com/manual/gh_attestation_verify). For more information, see [our guide on how to use artifact attestations to establish a build's provenance](https://docs.github.com/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/attestations/{subject_digest}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/{subject_digest}/get(repos/list-attestations)`.
    public enum ReposListAttestations {
        public static let id: Swift.String = "repos/list-attestations"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/path/subject_digest`.
                public var subjectDigest: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - subjectDigest: The parameter should be set to the attestation's subject's SHA256 digest, in the form `sha256:HEX_DIGEST`.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    subjectDigest: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.subjectDigest = subjectDigest
                }
            }
            public var path: Operations.ReposListAttestations.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/query/before`.
                public var before: Components.Parameters.PaginationBefore?
                /// A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/query/after`.
                public var after: Components.Parameters.PaginationAfter?
                /// Optional filter for fetching attestations with a given predicate type.
                /// This option accepts `provenance`, `sbom`, or freeform text for custom predicate types.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/query/predicate_type`.
                public var predicateType: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - before: A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results before this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - after: A cursor, as given in the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers). If specified, the query only searches for results after this cursor. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - predicateType: Optional filter for fetching attestations with a given predicate type.
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    before: Components.Parameters.PaginationBefore? = nil,
                    after: Components.Parameters.PaginationAfter? = nil,
                    predicateType: Swift.String? = nil
                ) {
                    self.perPage = perPage
                    self.before = before
                    self.after = after
                    self.predicateType = predicateType
                }
            }
            public var query: Operations.ReposListAttestations.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListAttestations.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListAttestations.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListAttestations.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListAttestations.Input.Path,
                query: Operations.ReposListAttestations.Input.Query = .init(),
                headers: Operations.ReposListAttestations.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload`.
                        public struct AttestationsPayloadPayload: Codable, Hashable, Sendable {
                            /// The attestation's Sigstore Bundle.
                            /// Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle`.
                            public struct BundlePayload: Codable, Hashable, Sendable {
                                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle/mediaType`.
                                public var mediaType: Swift.String?
                                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle/verificationMaterial`.
                                public struct VerificationMaterialPayload: Codable, Hashable, Sendable {
                                    /// A container of undocumented properties.
                                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                                    /// Creates a new `VerificationMaterialPayload`.
                                    ///
                                    /// - Parameters:
                                    ///   - additionalProperties: A container of undocumented properties.
                                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                                        self.additionalProperties = additionalProperties
                                    }
                                    public init(from decoder: any Decoder) throws {
                                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                                    }
                                    public func encode(to encoder: any Encoder) throws {
                                        try encoder.encodeAdditionalProperties(additionalProperties)
                                    }
                                }
                                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle/verificationMaterial`.
                                public var verificationMaterial: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayloadPayload.BundlePayload.VerificationMaterialPayload?
                                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle/dsseEnvelope`.
                                public struct DsseEnvelopePayload: Codable, Hashable, Sendable {
                                    /// A container of undocumented properties.
                                    public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                                    /// Creates a new `DsseEnvelopePayload`.
                                    ///
                                    /// - Parameters:
                                    ///   - additionalProperties: A container of undocumented properties.
                                    public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                                        self.additionalProperties = additionalProperties
                                    }
                                    public init(from decoder: any Decoder) throws {
                                        additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                                    }
                                    public func encode(to encoder: any Encoder) throws {
                                        try encoder.encodeAdditionalProperties(additionalProperties)
                                    }
                                }
                                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle/dsseEnvelope`.
                                public var dsseEnvelope: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayloadPayload.BundlePayload.DsseEnvelopePayload?
                                /// Creates a new `BundlePayload`.
                                ///
                                /// - Parameters:
                                ///   - mediaType:
                                ///   - verificationMaterial:
                                ///   - dsseEnvelope:
                                public init(
                                    mediaType: Swift.String? = nil,
                                    verificationMaterial: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayloadPayload.BundlePayload.VerificationMaterialPayload? = nil,
                                    dsseEnvelope: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayloadPayload.BundlePayload.DsseEnvelopePayload? = nil
                                ) {
                                    self.mediaType = mediaType
                                    self.verificationMaterial = verificationMaterial
                                    self.dsseEnvelope = dsseEnvelope
                                }
                                public enum CodingKeys: String, CodingKey {
                                    case mediaType
                                    case verificationMaterial
                                    case dsseEnvelope
                                }
                            }
                            /// The attestation's Sigstore Bundle.
                            /// Refer to the [Sigstore Bundle Specification](https://github.com/sigstore/protobuf-specs/blob/main/protos/sigstore_bundle.proto) for more information.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle`.
                            public var bundle: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayloadPayload.BundlePayload?
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/repository_id`.
                            public var repositoryId: Swift.Int?
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/AttestationsPayload/bundle_url`.
                            public var bundleUrl: Swift.String?
                            /// Creates a new `AttestationsPayloadPayload`.
                            ///
                            /// - Parameters:
                            ///   - bundle: The attestation's Sigstore Bundle.
                            ///   - repositoryId:
                            ///   - bundleUrl:
                            public init(
                                bundle: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayloadPayload.BundlePayload? = nil,
                                repositoryId: Swift.Int? = nil,
                                bundleUrl: Swift.String? = nil
                            ) {
                                self.bundle = bundle
                                self.repositoryId = repositoryId
                                self.bundleUrl = bundleUrl
                            }
                            public enum CodingKeys: String, CodingKey {
                                case bundle
                                case repositoryId = "repository_id"
                                case bundleUrl = "bundle_url"
                            }
                        }
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/attestations`.
                        public typealias AttestationsPayload = [Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayloadPayload]
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/json/attestations`.
                        public var attestations: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayload?
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - attestations:
                        public init(attestations: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload.AttestationsPayload? = nil) {
                            self.attestations = attestations
                        }
                        public enum CodingKeys: String, CodingKey {
                            case attestations
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/attestations/{subject_digest}/GET/responses/200/content/application\/json`.
                    case json(Operations.ReposListAttestations.Output.Ok.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposListAttestations.Output.Ok.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListAttestations.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListAttestations.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/attestations/{subject_digest}/get(repos/list-attestations)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListAttestations.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListAttestations.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get all autolinks of a repository
    ///
    /// Gets all autolinks that are configured for a repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/autolinks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/get(repos/list-autolinks)`.
    public enum ReposListAutolinks {
        public static let id: Swift.String = "repos/list-autolinks"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListAutolinks.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListAutolinks.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListAutolinks.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListAutolinks.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposListAutolinks.Input.Path,
                headers: Operations.ReposListAutolinks.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Autolink])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Autolink] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListAutolinks.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListAutolinks.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/get(repos/list-autolinks)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListAutolinks.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListAutolinks.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create an autolink reference for a repository
    ///
    /// Users with admin access to the repository can create an autolink.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/autolinks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/post(repos/create-autolink)`.
    public enum ReposCreateAutolink {
        public static let id: Swift.String = "repos/create-autolink"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateAutolink.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateAutolink.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateAutolink.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateAutolink.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/requestBody/json/key_prefix`.
                    public var keyPrefix: Swift.String
                    /// The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/requestBody/json/url_template`.
                    public var urlTemplate: Swift.String
                    /// Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/requestBody/json/is_alphanumeric`.
                    public var isAlphanumeric: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - keyPrefix: This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.
                    ///   - urlTemplate: The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.
                    ///   - isAlphanumeric: Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.
                    public init(
                        keyPrefix: Swift.String,
                        urlTemplate: Swift.String,
                        isAlphanumeric: Swift.Bool? = nil
                    ) {
                        self.keyPrefix = keyPrefix
                        self.urlTemplate = urlTemplate
                        self.isAlphanumeric = isAlphanumeric
                    }
                    public enum CodingKeys: String, CodingKey {
                        case keyPrefix = "key_prefix"
                        case urlTemplate = "url_template"
                        case isAlphanumeric = "is_alphanumeric"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateAutolink.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateAutolink.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateAutolink.Input.Path,
                headers: Operations.ReposCreateAutolink.Input.Headers = .init(),
                body: Operations.ReposCreateAutolink.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateAutolink.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.Autolink)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Autolink {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateAutolink.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateAutolink.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateAutolink.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/post(repos/create-autolink)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateAutolink.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateAutolink.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/post(repos/create-autolink)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get an autolink reference of a repository
    ///
    /// This returns a single autolink reference by ID that was configured for the given repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/autolinks/{autolink_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/get(repos/get-autolink)`.
    public enum ReposGetAutolink {
        public static let id: Swift.String = "repos/get-autolink"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the autolink.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/GET/path/autolink_id`.
                public var autolinkId: Components.Parameters.AutolinkId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - autolinkId: The unique identifier of the autolink.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    autolinkId: Components.Parameters.AutolinkId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.autolinkId = autolinkId
                }
            }
            public var path: Operations.ReposGetAutolink.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAutolink.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAutolink.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAutolink.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetAutolink.Input.Path,
                headers: Operations.ReposGetAutolink.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Autolink)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Autolink {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAutolink.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAutolink.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/get(repos/get-autolink)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAutolink.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAutolink.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/get(repos/get-autolink)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete an autolink reference from a repository
    ///
    /// This deletes a single autolink reference by ID that was configured for the given repository.
    ///
    /// Information about autolinks are only available to repository administrators.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/delete(repos/delete-autolink)`.
    public enum ReposDeleteAutolink {
        public static let id: Swift.String = "repos/delete-autolink"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the autolink.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/DELETE/path/autolink_id`.
                public var autolinkId: Components.Parameters.AutolinkId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - autolinkId: The unique identifier of the autolink.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    autolinkId: Components.Parameters.AutolinkId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.autolinkId = autolinkId
                }
            }
            public var path: Operations.ReposDeleteAutolink.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/autolinks/{autolink_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteAutolink.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteAutolink.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteAutolink.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteAutolink.Input.Path,
                headers: Operations.ReposDeleteAutolink.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/delete(repos/delete-autolink)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteAutolink.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/delete(repos/delete-autolink)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteAutolink.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/autolinks/{autolink_id}/delete(repos/delete-autolink)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Check if Dependabot security updates are enabled for a repository
    ///
    /// Shows whether Dependabot security updates are enabled, disabled or paused for a repository. The authenticated user must have admin read access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/get(repos/check-automated-security-fixes)`.
    public enum ReposCheckAutomatedSecurityFixes {
        public static let id: Swift.String = "repos/check-automated-security-fixes"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCheckAutomatedSecurityFixes.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCheckAutomatedSecurityFixes.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCheckAutomatedSecurityFixes.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCheckAutomatedSecurityFixes.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposCheckAutomatedSecurityFixes.Input.Path,
                headers: Operations.ReposCheckAutomatedSecurityFixes.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CheckAutomatedSecurityFixes)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CheckAutomatedSecurityFixes {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCheckAutomatedSecurityFixes.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCheckAutomatedSecurityFixes.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response if Dependabot is enabled
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/get(repos/check-automated-security-fixes)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCheckAutomatedSecurityFixes.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCheckAutomatedSecurityFixes.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// Creates a new `NotFound`.
                public init() {}
            }
            /// Not Found if Dependabot is not enabled for the repository
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/get(repos/check-automated-security-fixes)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposCheckAutomatedSecurityFixes.Output.NotFound)
            /// Not Found if Dependabot is not enabled for the repository
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/get(repos/check-automated-security-fixes)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            public static var notFound: Self {
                .notFound(.init())
            }
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposCheckAutomatedSecurityFixes.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Enable Dependabot security updates
    ///
    /// Enables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/put(repos/enable-automated-security-fixes)`.
    public enum ReposEnableAutomatedSecurityFixes {
        public static let id: Swift.String = "repos/enable-automated-security-fixes"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposEnableAutomatedSecurityFixes.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposEnableAutomatedSecurityFixes.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/put(repos/enable-automated-security-fixes)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposEnableAutomatedSecurityFixes.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/put(repos/enable-automated-security-fixes)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposEnableAutomatedSecurityFixes.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Disable Dependabot security updates
    ///
    /// Disables Dependabot security updates for a repository. The authenticated user must have admin access to the repository. For more information, see "[Configuring Dependabot security updates](https://docs.github.com/articles/configuring-automated-security-fixes)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/automated-security-fixes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/delete(repos/disable-automated-security-fixes)`.
    public enum ReposDisableAutomatedSecurityFixes {
        public static let id: Swift.String = "repos/disable-automated-security-fixes"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/automated-security-fixes/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposDisableAutomatedSecurityFixes.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDisableAutomatedSecurityFixes.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/delete(repos/disable-automated-security-fixes)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDisableAutomatedSecurityFixes.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/automated-security-fixes/delete(repos/disable-automated-security-fixes)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDisableAutomatedSecurityFixes.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// List branches
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/get(repos/list-branches)`.
    public enum ReposListBranches {
        public static let id: Swift.String = "repos/list-branches"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListBranches.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/query/protected`.
                public var protected: Swift.Bool?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - protected: Setting to `true` returns only branches protected by branch protections or rulesets. When set to `false`, only unprotected branches are returned. Omitting this parameter returns all branches.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    protected: Swift.Bool? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.protected = protected
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListBranches.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListBranches.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListBranches.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListBranches.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListBranches.Input.Path,
                query: Operations.ReposListBranches.Input.Query = .init(),
                headers: Operations.ReposListBranches.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListBranches.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.ShortBranch])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.ShortBranch] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListBranches.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListBranches.Output.Ok.Headers = .init(),
                    body: Operations.ReposListBranches.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/get(repos/list-branches)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListBranches.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListBranches.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/get(repos/list-branches)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a branch
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/get(repos/get-branch)`.
    public enum ReposGetBranch {
        public static let id: Swift.String = "repos/get-branch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetBranch.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetBranch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetBranch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetBranch.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetBranch.Input.Path,
                headers: Operations.ReposGetBranch.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BranchWithProtection)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BranchWithProtection {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetBranch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetBranch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/get(repos/get-branch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetBranch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetBranch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Moved permanently
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/get(repos/get-branch)/responses/301`.
            ///
            /// HTTP response code: `301 movedPermanently`.
            case movedPermanently(Components.Responses.MovedPermanently)
            /// The associated value of the enum case if `self` is `.movedPermanently`.
            ///
            /// - Throws: An error if `self` is not `.movedPermanently`.
            /// - SeeAlso: `.movedPermanently`.
            public var movedPermanently: Components.Responses.MovedPermanently {
                get throws {
                    switch self {
                    case let .movedPermanently(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "movedPermanently",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/get(repos/get-branch)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/get(repos/get-branch-protection)`.
    public enum ReposGetBranchProtection {
        public static let id: Swift.String = "repos/get-branch-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetBranchProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetBranchProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetBranchProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetBranchProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetBranchProtection.Input.Path,
                headers: Operations.ReposGetBranchProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BranchProtection)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BranchProtection {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetBranchProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetBranchProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/get(repos/get-branch-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetBranchProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetBranchProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/get(repos/get-branch-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Protecting a branch requires admin or owner permissions to the repository.
    ///
    /// > [!NOTE]
    /// > Passing new arrays of `users` and `teams` replaces their previous values.
    ///
    /// > [!NOTE]
    /// > The list of users, apps, and teams in total is limited to 100 items.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/put(repos/update-branch-protection)`.
    public enum ReposUpdateBranchProtection {
        public static let id: Swift.String = "repos/update-branch-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposUpdateBranchProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateBranchProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateBranchProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateBranchProtection.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Require status checks to pass before merging. Set to `null` to disable.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks`.
                    public struct RequiredStatusChecksPayload: Codable, Hashable, Sendable {
                        /// Require branches to be up to date before merging.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks/strict`.
                        public var strict: Swift.Bool
                        /// **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks/contexts`.
                        @available(*, deprecated)
                        public var contexts: [Swift.String]
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks/ChecksPayload`.
                        public struct ChecksPayloadPayload: Codable, Hashable, Sendable {
                            /// The name of the required check
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks/ChecksPayload/context`.
                            public var context: Swift.String
                            /// The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks/ChecksPayload/app_id`.
                            public var appId: Swift.Int?
                            /// Creates a new `ChecksPayloadPayload`.
                            ///
                            /// - Parameters:
                            ///   - context: The name of the required check
                            ///   - appId: The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
                            public init(
                                context: Swift.String,
                                appId: Swift.Int? = nil
                            ) {
                                self.context = context
                                self.appId = appId
                            }
                            public enum CodingKeys: String, CodingKey {
                                case context
                                case appId = "app_id"
                            }
                        }
                        /// The list of status checks to require in order to merge into this branch.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks/checks`.
                        public typealias ChecksPayload = [Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredStatusChecksPayload.ChecksPayloadPayload]
                        /// The list of status checks to require in order to merge into this branch.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks/checks`.
                        public var checks: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredStatusChecksPayload.ChecksPayload?
                        /// Creates a new `RequiredStatusChecksPayload`.
                        ///
                        /// - Parameters:
                        ///   - strict: Require branches to be up to date before merging.
                        ///   - contexts: **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
                        ///   - checks: The list of status checks to require in order to merge into this branch.
                        public init(
                            strict: Swift.Bool,
                            contexts: [Swift.String],
                            checks: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredStatusChecksPayload.ChecksPayload? = nil
                        ) {
                            self.strict = strict
                            self.contexts = contexts
                            self.checks = checks
                        }
                        public enum CodingKeys: String, CodingKey {
                            case strict
                            case contexts
                            case checks
                        }
                    }
                    /// Require status checks to pass before merging. Set to `null` to disable.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_status_checks`.
                    public var requiredStatusChecks: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredStatusChecksPayload?
                    /// Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/enforce_admins`.
                    public var enforceAdmins: Swift.Bool?
                    /// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews`.
                    public struct RequiredPullRequestReviewsPayload: Codable, Hashable, Sendable {
                        /// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/dismissal_restrictions`.
                        public struct DismissalRestrictionsPayload: Codable, Hashable, Sendable {
                            /// The list of user `login`s with dismissal access
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/dismissal_restrictions/users`.
                            public var users: [Swift.String]?
                            /// The list of team `slug`s with dismissal access
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/dismissal_restrictions/teams`.
                            public var teams: [Swift.String]?
                            /// The list of app `slug`s with dismissal access
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/dismissal_restrictions/apps`.
                            public var apps: [Swift.String]?
                            /// Creates a new `DismissalRestrictionsPayload`.
                            ///
                            /// - Parameters:
                            ///   - users: The list of user `login`s with dismissal access
                            ///   - teams: The list of team `slug`s with dismissal access
                            ///   - apps: The list of app `slug`s with dismissal access
                            public init(
                                users: [Swift.String]? = nil,
                                teams: [Swift.String]? = nil,
                                apps: [Swift.String]? = nil
                            ) {
                                self.users = users
                                self.teams = teams
                                self.apps = apps
                            }
                            public enum CodingKeys: String, CodingKey {
                                case users
                                case teams
                                case apps
                            }
                        }
                        /// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/dismissal_restrictions`.
                        public var dismissalRestrictions: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredPullRequestReviewsPayload.DismissalRestrictionsPayload?
                        /// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/dismiss_stale_reviews`.
                        public var dismissStaleReviews: Swift.Bool?
                        /// Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/require_code_owner_reviews`.
                        public var requireCodeOwnerReviews: Swift.Bool?
                        /// Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/required_approving_review_count`.
                        public var requiredApprovingReviewCount: Swift.Int?
                        /// Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/require_last_push_approval`.
                        public var requireLastPushApproval: Swift.Bool?
                        /// Allow specific users, teams, or apps to bypass pull request requirements.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/bypass_pull_request_allowances`.
                        public struct BypassPullRequestAllowancesPayload: Codable, Hashable, Sendable {
                            /// The list of user `login`s allowed to bypass pull request requirements.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/bypass_pull_request_allowances/users`.
                            public var users: [Swift.String]?
                            /// The list of team `slug`s allowed to bypass pull request requirements.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/bypass_pull_request_allowances/teams`.
                            public var teams: [Swift.String]?
                            /// The list of app `slug`s allowed to bypass pull request requirements.
                            ///
                            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/bypass_pull_request_allowances/apps`.
                            public var apps: [Swift.String]?
                            /// Creates a new `BypassPullRequestAllowancesPayload`.
                            ///
                            /// - Parameters:
                            ///   - users: The list of user `login`s allowed to bypass pull request requirements.
                            ///   - teams: The list of team `slug`s allowed to bypass pull request requirements.
                            ///   - apps: The list of app `slug`s allowed to bypass pull request requirements.
                            public init(
                                users: [Swift.String]? = nil,
                                teams: [Swift.String]? = nil,
                                apps: [Swift.String]? = nil
                            ) {
                                self.users = users
                                self.teams = teams
                                self.apps = apps
                            }
                            public enum CodingKeys: String, CodingKey {
                                case users
                                case teams
                                case apps
                            }
                        }
                        /// Allow specific users, teams, or apps to bypass pull request requirements.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews/bypass_pull_request_allowances`.
                        public var bypassPullRequestAllowances: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredPullRequestReviewsPayload.BypassPullRequestAllowancesPayload?
                        /// Creates a new `RequiredPullRequestReviewsPayload`.
                        ///
                        /// - Parameters:
                        ///   - dismissalRestrictions: Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
                        ///   - dismissStaleReviews: Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
                        ///   - requireCodeOwnerReviews: Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.
                        ///   - requiredApprovingReviewCount: Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
                        ///   - requireLastPushApproval: Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`.
                        ///   - bypassPullRequestAllowances: Allow specific users, teams, or apps to bypass pull request requirements.
                        public init(
                            dismissalRestrictions: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredPullRequestReviewsPayload.DismissalRestrictionsPayload? = nil,
                            dismissStaleReviews: Swift.Bool? = nil,
                            requireCodeOwnerReviews: Swift.Bool? = nil,
                            requiredApprovingReviewCount: Swift.Int? = nil,
                            requireLastPushApproval: Swift.Bool? = nil,
                            bypassPullRequestAllowances: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredPullRequestReviewsPayload.BypassPullRequestAllowancesPayload? = nil
                        ) {
                            self.dismissalRestrictions = dismissalRestrictions
                            self.dismissStaleReviews = dismissStaleReviews
                            self.requireCodeOwnerReviews = requireCodeOwnerReviews
                            self.requiredApprovingReviewCount = requiredApprovingReviewCount
                            self.requireLastPushApproval = requireLastPushApproval
                            self.bypassPullRequestAllowances = bypassPullRequestAllowances
                        }
                        public enum CodingKeys: String, CodingKey {
                            case dismissalRestrictions = "dismissal_restrictions"
                            case dismissStaleReviews = "dismiss_stale_reviews"
                            case requireCodeOwnerReviews = "require_code_owner_reviews"
                            case requiredApprovingReviewCount = "required_approving_review_count"
                            case requireLastPushApproval = "require_last_push_approval"
                            case bypassPullRequestAllowances = "bypass_pull_request_allowances"
                        }
                    }
                    /// Require at least one approving review on a pull request, before merging. Set to `null` to disable.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_pull_request_reviews`.
                    public var requiredPullRequestReviews: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredPullRequestReviewsPayload?
                    /// Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/restrictions`.
                    public struct RestrictionsPayload: Codable, Hashable, Sendable {
                        /// The list of user `login`s with push access
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/restrictions/users`.
                        public var users: [Swift.String]
                        /// The list of team `slug`s with push access
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/restrictions/teams`.
                        public var teams: [Swift.String]
                        /// The list of app `slug`s with push access
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/restrictions/apps`.
                        public var apps: [Swift.String]?
                        /// Creates a new `RestrictionsPayload`.
                        ///
                        /// - Parameters:
                        ///   - users: The list of user `login`s with push access
                        ///   - teams: The list of team `slug`s with push access
                        ///   - apps: The list of app `slug`s with push access
                        public init(
                            users: [Swift.String],
                            teams: [Swift.String],
                            apps: [Swift.String]? = nil
                        ) {
                            self.users = users
                            self.teams = teams
                            self.apps = apps
                        }
                        public enum CodingKeys: String, CodingKey {
                            case users
                            case teams
                            case apps
                        }
                    }
                    /// Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/restrictions`.
                    public var restrictions: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RestrictionsPayload?
                    /// Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_linear_history`.
                    public var requiredLinearHistory: Swift.Bool?
                    /// Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/allow_force_pushes`.
                    public var allowForcePushes: Swift.Bool?
                    /// Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/allow_deletions`.
                    public var allowDeletions: Swift.Bool?
                    /// If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/block_creations`.
                    public var blockCreations: Swift.Bool?
                    /// Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/required_conversation_resolution`.
                    public var requiredConversationResolution: Swift.Bool?
                    /// Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/lock_branch`.
                    public var lockBranch: Swift.Bool?
                    /// Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/json/allow_fork_syncing`.
                    public var allowForkSyncing: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - requiredStatusChecks: Require status checks to pass before merging. Set to `null` to disable.
                    ///   - enforceAdmins: Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.
                    ///   - requiredPullRequestReviews: Require at least one approving review on a pull request, before merging. Set to `null` to disable.
                    ///   - restrictions: Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.
                    ///   - requiredLinearHistory: Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.
                    ///   - allowForcePushes: Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."
                    ///   - allowDeletions: Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.
                    ///   - blockCreations: If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.
                    ///   - requiredConversationResolution: Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.
                    ///   - lockBranch: Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.
                    ///   - allowForkSyncing: Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.
                    public init(
                        requiredStatusChecks: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredStatusChecksPayload? = nil,
                        enforceAdmins: Swift.Bool? = nil,
                        requiredPullRequestReviews: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RequiredPullRequestReviewsPayload? = nil,
                        restrictions: Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload.RestrictionsPayload? = nil,
                        requiredLinearHistory: Swift.Bool? = nil,
                        allowForcePushes: Swift.Bool? = nil,
                        allowDeletions: Swift.Bool? = nil,
                        blockCreations: Swift.Bool? = nil,
                        requiredConversationResolution: Swift.Bool? = nil,
                        lockBranch: Swift.Bool? = nil,
                        allowForkSyncing: Swift.Bool? = nil
                    ) {
                        self.requiredStatusChecks = requiredStatusChecks
                        self.enforceAdmins = enforceAdmins
                        self.requiredPullRequestReviews = requiredPullRequestReviews
                        self.restrictions = restrictions
                        self.requiredLinearHistory = requiredLinearHistory
                        self.allowForcePushes = allowForcePushes
                        self.allowDeletions = allowDeletions
                        self.blockCreations = blockCreations
                        self.requiredConversationResolution = requiredConversationResolution
                        self.lockBranch = lockBranch
                        self.allowForkSyncing = allowForkSyncing
                    }
                    public enum CodingKeys: String, CodingKey {
                        case requiredStatusChecks = "required_status_checks"
                        case enforceAdmins = "enforce_admins"
                        case requiredPullRequestReviews = "required_pull_request_reviews"
                        case restrictions
                        case requiredLinearHistory = "required_linear_history"
                        case allowForcePushes = "allow_force_pushes"
                        case allowDeletions = "allow_deletions"
                        case blockCreations = "block_creations"
                        case requiredConversationResolution = "required_conversation_resolution"
                        case lockBranch = "lock_branch"
                        case allowForkSyncing = "allow_fork_syncing"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateBranchProtection.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateBranchProtection.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateBranchProtection.Input.Path,
                headers: Operations.ReposUpdateBranchProtection.Input.Headers = .init(),
                body: Operations.ReposUpdateBranchProtection.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/PUT/responses/200/content/application\/json`.
                    case json(Components.Schemas.ProtectedBranch)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProtectedBranch {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateBranchProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateBranchProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/put(repos/update-branch-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateBranchProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateBranchProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/put(repos/update-branch-protection)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/put(repos/update-branch-protection)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailedSimple)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailedSimple {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/put(repos/update-branch-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/delete(repos/delete-branch-protection)`.
    public enum ReposDeleteBranchProtection {
        public static let id: Swift.String = "repos/delete-branch-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposDeleteBranchProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteBranchProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteBranchProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteBranchProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteBranchProtection.Input.Path,
                headers: Operations.ReposDeleteBranchProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/delete(repos/delete-branch-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteBranchProtection.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/delete(repos/delete-branch-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteBranchProtection.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/delete(repos/delete-branch-protection)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/get(repos/get-admin-branch-protection)`.
    public enum ReposGetAdminBranchProtection {
        public static let id: Swift.String = "repos/get-admin-branch-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetAdminBranchProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAdminBranchProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAdminBranchProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAdminBranchProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetAdminBranchProtection.Input.Path,
                headers: Operations.ReposGetAdminBranchProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ProtectedBranchAdminEnforced)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProtectedBranchAdminEnforced {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAdminBranchProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAdminBranchProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/get(repos/get-admin-branch-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAdminBranchProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAdminBranchProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Set admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Adding admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/post(repos/set-admin-branch-protection)`.
    public enum ReposSetAdminBranchProtection {
        public static let id: Swift.String = "repos/set-admin-branch-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/POST/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposSetAdminBranchProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetAdminBranchProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetAdminBranchProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposSetAdminBranchProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposSetAdminBranchProtection.Input.Path,
                headers: Operations.ReposSetAdminBranchProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ProtectedBranchAdminEnforced)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProtectedBranchAdminEnforced {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposSetAdminBranchProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposSetAdminBranchProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/post(repos/set-admin-branch-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposSetAdminBranchProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposSetAdminBranchProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete admin branch protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removing admin enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/delete(repos/delete-admin-branch-protection)`.
    public enum ReposDeleteAdminBranchProtection {
        public static let id: Swift.String = "repos/delete-admin-branch-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposDeleteAdminBranchProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteAdminBranchProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteAdminBranchProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteAdminBranchProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteAdminBranchProtection.Input.Path,
                headers: Operations.ReposDeleteAdminBranchProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/delete(repos/delete-admin-branch-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteAdminBranchProtection.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/delete(repos/delete-admin-branch-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteAdminBranchProtection.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins/delete(repos/delete-admin-branch-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/get(repos/get-pull-request-review-protection)`.
    public enum ReposGetPullRequestReviewProtection {
        public static let id: Swift.String = "repos/get-pull-request-review-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetPullRequestReviewProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPullRequestReviewProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPullRequestReviewProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetPullRequestReviewProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetPullRequestReviewProtection.Input.Path,
                headers: Operations.ReposGetPullRequestReviewProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ProtectedBranchPullRequestReview)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProtectedBranchPullRequestReview {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetPullRequestReviewProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetPullRequestReviewProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/get(repos/get-pull-request-review-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetPullRequestReviewProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetPullRequestReviewProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Updating pull request review enforcement requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// > [!NOTE]
    /// > Passing new arrays of `users` and `teams` replaces their previous values.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/patch(repos/update-pull-request-review-protection)`.
    public enum ReposUpdatePullRequestReviewProtection {
        public static let id: Swift.String = "repos/update-pull-request-review-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposUpdatePullRequestReviewProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdatePullRequestReviewProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdatePullRequestReviewProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdatePullRequestReviewProtection.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/dismissal_restrictions`.
                    public struct DismissalRestrictionsPayload: Codable, Hashable, Sendable {
                        /// The list of user `login`s with dismissal access
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/dismissal_restrictions/users`.
                        public var users: [Swift.String]?
                        /// The list of team `slug`s with dismissal access
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/dismissal_restrictions/teams`.
                        public var teams: [Swift.String]?
                        /// The list of app `slug`s with dismissal access
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/dismissal_restrictions/apps`.
                        public var apps: [Swift.String]?
                        /// Creates a new `DismissalRestrictionsPayload`.
                        ///
                        /// - Parameters:
                        ///   - users: The list of user `login`s with dismissal access
                        ///   - teams: The list of team `slug`s with dismissal access
                        ///   - apps: The list of app `slug`s with dismissal access
                        public init(
                            users: [Swift.String]? = nil,
                            teams: [Swift.String]? = nil,
                            apps: [Swift.String]? = nil
                        ) {
                            self.users = users
                            self.teams = teams
                            self.apps = apps
                        }
                        public enum CodingKeys: String, CodingKey {
                            case users
                            case teams
                            case apps
                        }
                    }
                    /// Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/dismissal_restrictions`.
                    public var dismissalRestrictions: Operations.ReposUpdatePullRequestReviewProtection.Input.Body.JsonPayload.DismissalRestrictionsPayload?
                    /// Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/dismiss_stale_reviews`.
                    public var dismissStaleReviews: Swift.Bool?
                    /// Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/require_code_owner_reviews`.
                    public var requireCodeOwnerReviews: Swift.Bool?
                    /// Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/required_approving_review_count`.
                    public var requiredApprovingReviewCount: Swift.Int?
                    /// Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/require_last_push_approval`.
                    public var requireLastPushApproval: Swift.Bool?
                    /// Allow specific users, teams, or apps to bypass pull request requirements.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/bypass_pull_request_allowances`.
                    public struct BypassPullRequestAllowancesPayload: Codable, Hashable, Sendable {
                        /// The list of user `login`s allowed to bypass pull request requirements.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/bypass_pull_request_allowances/users`.
                        public var users: [Swift.String]?
                        /// The list of team `slug`s allowed to bypass pull request requirements.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/bypass_pull_request_allowances/teams`.
                        public var teams: [Swift.String]?
                        /// The list of app `slug`s allowed to bypass pull request requirements.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/bypass_pull_request_allowances/apps`.
                        public var apps: [Swift.String]?
                        /// Creates a new `BypassPullRequestAllowancesPayload`.
                        ///
                        /// - Parameters:
                        ///   - users: The list of user `login`s allowed to bypass pull request requirements.
                        ///   - teams: The list of team `slug`s allowed to bypass pull request requirements.
                        ///   - apps: The list of app `slug`s allowed to bypass pull request requirements.
                        public init(
                            users: [Swift.String]? = nil,
                            teams: [Swift.String]? = nil,
                            apps: [Swift.String]? = nil
                        ) {
                            self.users = users
                            self.teams = teams
                            self.apps = apps
                        }
                        public enum CodingKeys: String, CodingKey {
                            case users
                            case teams
                            case apps
                        }
                    }
                    /// Allow specific users, teams, or apps to bypass pull request requirements.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/json/bypass_pull_request_allowances`.
                    public var bypassPullRequestAllowances: Operations.ReposUpdatePullRequestReviewProtection.Input.Body.JsonPayload.BypassPullRequestAllowancesPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - dismissalRestrictions: Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.
                    ///   - dismissStaleReviews: Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.
                    ///   - requireCodeOwnerReviews: Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.
                    ///   - requiredApprovingReviewCount: Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.
                    ///   - requireLastPushApproval: Whether the most recent push must be approved by someone other than the person who pushed it. Default: `false`
                    ///   - bypassPullRequestAllowances: Allow specific users, teams, or apps to bypass pull request requirements.
                    public init(
                        dismissalRestrictions: Operations.ReposUpdatePullRequestReviewProtection.Input.Body.JsonPayload.DismissalRestrictionsPayload? = nil,
                        dismissStaleReviews: Swift.Bool? = nil,
                        requireCodeOwnerReviews: Swift.Bool? = nil,
                        requiredApprovingReviewCount: Swift.Int? = nil,
                        requireLastPushApproval: Swift.Bool? = nil,
                        bypassPullRequestAllowances: Operations.ReposUpdatePullRequestReviewProtection.Input.Body.JsonPayload.BypassPullRequestAllowancesPayload? = nil
                    ) {
                        self.dismissalRestrictions = dismissalRestrictions
                        self.dismissStaleReviews = dismissStaleReviews
                        self.requireCodeOwnerReviews = requireCodeOwnerReviews
                        self.requiredApprovingReviewCount = requiredApprovingReviewCount
                        self.requireLastPushApproval = requireLastPushApproval
                        self.bypassPullRequestAllowances = bypassPullRequestAllowances
                    }
                    public enum CodingKeys: String, CodingKey {
                        case dismissalRestrictions = "dismissal_restrictions"
                        case dismissStaleReviews = "dismiss_stale_reviews"
                        case requireCodeOwnerReviews = "require_code_owner_reviews"
                        case requiredApprovingReviewCount = "required_approving_review_count"
                        case requireLastPushApproval = "require_last_push_approval"
                        case bypassPullRequestAllowances = "bypass_pull_request_allowances"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdatePullRequestReviewProtection.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdatePullRequestReviewProtection.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdatePullRequestReviewProtection.Input.Path,
                headers: Operations.ReposUpdatePullRequestReviewProtection.Input.Headers = .init(),
                body: Operations.ReposUpdatePullRequestReviewProtection.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.ProtectedBranchPullRequestReview)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProtectedBranchPullRequestReview {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdatePullRequestReviewProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdatePullRequestReviewProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/patch(repos/update-pull-request-review-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdatePullRequestReviewProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdatePullRequestReviewProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/patch(repos/update-pull-request-review-protection)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete pull request review protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/delete(repos/delete-pull-request-review-protection)`.
    public enum ReposDeletePullRequestReviewProtection {
        public static let id: Swift.String = "repos/delete-pull-request-review-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposDeletePullRequestReviewProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeletePullRequestReviewProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeletePullRequestReviewProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeletePullRequestReviewProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeletePullRequestReviewProtection.Input.Path,
                headers: Operations.ReposDeletePullRequestReviewProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/delete(repos/delete-pull-request-review-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeletePullRequestReviewProtection.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/delete(repos/delete-pull-request-review-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeletePullRequestReviewProtection.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews/delete(repos/delete-pull-request-review-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to check whether a branch requires signed commits. An enabled status of `true` indicates you must sign commits on this branch. For more information, see [Signing commits with GPG](https://docs.github.com/articles/signing-commits-with-gpg) in GitHub Help.
    ///
    /// > [!NOTE]
    /// > You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/get(repos/get-commit-signature-protection)`.
    public enum ReposGetCommitSignatureProtection {
        public static let id: Swift.String = "repos/get-commit-signature-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetCommitSignatureProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommitSignatureProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommitSignatureProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCommitSignatureProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCommitSignatureProtection.Input.Path,
                headers: Operations.ReposGetCommitSignatureProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ProtectedBranchAdminEnforced)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProtectedBranchAdminEnforced {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCommitSignatureProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCommitSignatureProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/get(repos/get-commit-signature-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCommitSignatureProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCommitSignatureProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/get(repos/get-commit-signature-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to require signed commits on a branch. You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/post(repos/create-commit-signature-protection)`.
    public enum ReposCreateCommitSignatureProtection {
        public static let id: Swift.String = "repos/create-commit-signature-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/POST/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposCreateCommitSignatureProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateCommitSignatureProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateCommitSignatureProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateCommitSignatureProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposCreateCommitSignatureProtection.Input.Path,
                headers: Operations.ReposCreateCommitSignatureProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ProtectedBranchAdminEnforced)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ProtectedBranchAdminEnforced {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateCommitSignatureProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateCommitSignatureProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/post(repos/create-commit-signature-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCreateCommitSignatureProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCreateCommitSignatureProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/post(repos/create-commit-signature-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete commit signature protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// When authenticated with admin or owner permissions to the repository, you can use this endpoint to disable required signed commits on a branch. You must enable branch protection to require signed commits.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/delete(repos/delete-commit-signature-protection)`.
    public enum ReposDeleteCommitSignatureProtection {
        public static let id: Swift.String = "repos/delete-commit-signature-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposDeleteCommitSignatureProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteCommitSignatureProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteCommitSignatureProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteCommitSignatureProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteCommitSignatureProtection.Input.Path,
                headers: Operations.ReposDeleteCommitSignatureProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/delete(repos/delete-commit-signature-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteCommitSignatureProtection.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/delete(repos/delete-commit-signature-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteCommitSignatureProtection.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_signatures/delete(repos/delete-commit-signature-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get status checks protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/get(repos/get-status-checks-protection)`.
    public enum ReposGetStatusChecksProtection {
        public static let id: Swift.String = "repos/get-status-checks-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetStatusChecksProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetStatusChecksProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetStatusChecksProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetStatusChecksProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetStatusChecksProtection.Input.Path,
                headers: Operations.ReposGetStatusChecksProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.StatusCheckPolicy)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.StatusCheckPolicy {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetStatusChecksProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetStatusChecksProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/get(repos/get-status-checks-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetStatusChecksProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetStatusChecksProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/get(repos/get-status-checks-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update status check protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Updating required status checks requires admin or owner permissions to the repository and branch protection to be enabled.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/patch(repos/update-status-check-protection)`.
    public enum ReposUpdateStatusCheckProtection {
        public static let id: Swift.String = "repos/update-status-check-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposUpdateStatusCheckProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateStatusCheckProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateStatusCheckProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateStatusCheckProtection.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Require branches to be up to date before merging.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json/strict`.
                    public var strict: Swift.Bool?
                    /// **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json/contexts`.
                    @available(*, deprecated)
                    public var contexts: [Swift.String]?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json/ChecksPayload`.
                    public struct ChecksPayloadPayload: Codable, Hashable, Sendable {
                        /// The name of the required check
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json/ChecksPayload/context`.
                        public var context: Swift.String
                        /// The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json/ChecksPayload/app_id`.
                        public var appId: Swift.Int?
                        /// Creates a new `ChecksPayloadPayload`.
                        ///
                        /// - Parameters:
                        ///   - context: The name of the required check
                        ///   - appId: The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.
                        public init(
                            context: Swift.String,
                            appId: Swift.Int? = nil
                        ) {
                            self.context = context
                            self.appId = appId
                        }
                        public enum CodingKeys: String, CodingKey {
                            case context
                            case appId = "app_id"
                        }
                    }
                    /// The list of status checks to require in order to merge into this branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json/checks`.
                    public typealias ChecksPayload = [Operations.ReposUpdateStatusCheckProtection.Input.Body.JsonPayload.ChecksPayloadPayload]
                    /// The list of status checks to require in order to merge into this branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/json/checks`.
                    public var checks: Operations.ReposUpdateStatusCheckProtection.Input.Body.JsonPayload.ChecksPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - strict: Require branches to be up to date before merging.
                    ///   - contexts: **Closing down notice**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.
                    ///   - checks: The list of status checks to require in order to merge into this branch.
                    public init(
                        strict: Swift.Bool? = nil,
                        contexts: [Swift.String]? = nil,
                        checks: Operations.ReposUpdateStatusCheckProtection.Input.Body.JsonPayload.ChecksPayload? = nil
                    ) {
                        self.strict = strict
                        self.contexts = contexts
                        self.checks = checks
                    }
                    public enum CodingKeys: String, CodingKey {
                        case strict
                        case contexts
                        case checks
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateStatusCheckProtection.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateStatusCheckProtection.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateStatusCheckProtection.Input.Path,
                headers: Operations.ReposUpdateStatusCheckProtection.Input.Headers = .init(),
                body: Operations.ReposUpdateStatusCheckProtection.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.StatusCheckPolicy)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.StatusCheckPolicy {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateStatusCheckProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateStatusCheckProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/patch(repos/update-status-check-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateStatusCheckProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateStatusCheckProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/patch(repos/update-status-check-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/patch(repos/update-status-check-protection)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Remove status check protection
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/delete(repos/remove-status-check-protection)`.
    public enum ReposRemoveStatusCheckProtection {
        public static let id: Swift.String = "repos/remove-status-check-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposRemoveStatusCheckProtection.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposRemoveStatusCheckProtection.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/delete(repos/remove-status-check-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposRemoveStatusCheckProtection.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/delete(repos/remove-status-check-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposRemoveStatusCheckProtection.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Get all status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/get(repos/get-all-status-check-contexts)`.
    public enum ReposGetAllStatusCheckContexts {
        public static let id: Swift.String = "repos/get-all-status-check-contexts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetAllStatusCheckContexts.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllStatusCheckContexts.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllStatusCheckContexts.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAllStatusCheckContexts.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetAllStatusCheckContexts.Input.Path,
                headers: Operations.ReposGetAllStatusCheckContexts.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/GET/responses/200/content/application\/json`.
                    case json([Swift.String])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Swift.String] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAllStatusCheckContexts.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAllStatusCheckContexts.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/get(repos/get-all-status-check-contexts)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAllStatusCheckContexts.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAllStatusCheckContexts.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/get(repos/get-all-status-check-contexts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Add status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/post(repos/add-status-check-contexts)`.
    public enum ReposAddStatusCheckContexts {
        public static let id: Swift.String = "repos/add-status-check-contexts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposAddStatusCheckContexts.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddStatusCheckContexts.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddStatusCheckContexts.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposAddStatusCheckContexts.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/requestBody/json`.
                @frozen public enum JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/requestBody/json/case1`.
                    public struct Case1Payload: Codable, Hashable, Sendable {
                        /// The name of the status checks
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/requestBody/json/case1/contexts`.
                        public var contexts: [Swift.String]
                        /// Creates a new `Case1Payload`.
                        ///
                        /// - Parameters:
                        ///   - contexts: The name of the status checks
                        public init(contexts: [Swift.String]) {
                            self.contexts = contexts
                        }
                        public enum CodingKeys: String, CodingKey {
                            case contexts
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/requestBody/json/case1`.
                    case case1(Operations.ReposAddStatusCheckContexts.Input.Body.JsonPayload.Case1Payload)
                    /// The name of the status checks
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/requestBody/json/case2`.
                    case case2([Swift.String])
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try value.encode(to: encoder)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/requestBody/content/application\/json`.
                case json(Operations.ReposAddStatusCheckContexts.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposAddStatusCheckContexts.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposAddStatusCheckContexts.Input.Path,
                headers: Operations.ReposAddStatusCheckContexts.Input.Headers = .init(),
                body: Operations.ReposAddStatusCheckContexts.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/POST/responses/200/content/application\/json`.
                    case json([Swift.String])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Swift.String] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposAddStatusCheckContexts.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposAddStatusCheckContexts.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/post(repos/add-status-check-contexts)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposAddStatusCheckContexts.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposAddStatusCheckContexts.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/post(repos/add-status-check-contexts)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/post(repos/add-status-check-contexts)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/post(repos/add-status-check-contexts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Set status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/put(repos/set-status-check-contexts)`.
    public enum ReposSetStatusCheckContexts {
        public static let id: Swift.String = "repos/set-status-check-contexts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposSetStatusCheckContexts.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetStatusCheckContexts.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetStatusCheckContexts.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposSetStatusCheckContexts.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/requestBody/json`.
                @frozen public enum JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/requestBody/json/case1`.
                    public struct Case1Payload: Codable, Hashable, Sendable {
                        /// The name of the status checks
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/requestBody/json/case1/contexts`.
                        public var contexts: [Swift.String]
                        /// Creates a new `Case1Payload`.
                        ///
                        /// - Parameters:
                        ///   - contexts: The name of the status checks
                        public init(contexts: [Swift.String]) {
                            self.contexts = contexts
                        }
                        public enum CodingKeys: String, CodingKey {
                            case contexts
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/requestBody/json/case1`.
                    case case1(Operations.ReposSetStatusCheckContexts.Input.Body.JsonPayload.Case1Payload)
                    /// The name of the status checks
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/requestBody/json/case2`.
                    case case2([Swift.String])
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try value.encode(to: encoder)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposSetStatusCheckContexts.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposSetStatusCheckContexts.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposSetStatusCheckContexts.Input.Path,
                headers: Operations.ReposSetStatusCheckContexts.Input.Headers = .init(),
                body: Operations.ReposSetStatusCheckContexts.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/PUT/responses/200/content/application\/json`.
                    case json([Swift.String])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Swift.String] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposSetStatusCheckContexts.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposSetStatusCheckContexts.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/put(repos/set-status-check-contexts)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposSetStatusCheckContexts.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposSetStatusCheckContexts.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/put(repos/set-status-check-contexts)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/put(repos/set-status-check-contexts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Remove status check contexts
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/delete(repos/remove-status-check-contexts)`.
    public enum ReposRemoveStatusCheckContexts {
        public static let id: Swift.String = "repos/remove-status-check-contexts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposRemoveStatusCheckContexts.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveStatusCheckContexts.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveStatusCheckContexts.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRemoveStatusCheckContexts.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/requestBody/json`.
                @frozen public enum JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/requestBody/json/case1`.
                    public struct Case1Payload: Codable, Hashable, Sendable {
                        /// The name of the status checks
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/requestBody/json/case1/contexts`.
                        public var contexts: [Swift.String]
                        /// Creates a new `Case1Payload`.
                        ///
                        /// - Parameters:
                        ///   - contexts: The name of the status checks
                        public init(contexts: [Swift.String]) {
                            self.contexts = contexts
                        }
                        public enum CodingKeys: String, CodingKey {
                            case contexts
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/requestBody/json/case1`.
                    case case1(Operations.ReposRemoveStatusCheckContexts.Input.Body.JsonPayload.Case1Payload)
                    /// The name of the status checks
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/requestBody/json/case2`.
                    case case2([Swift.String])
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try value.encode(to: encoder)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/requestBody/content/application\/json`.
                case json(Operations.ReposRemoveStatusCheckContexts.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposRemoveStatusCheckContexts.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposRemoveStatusCheckContexts.Input.Path,
                headers: Operations.ReposRemoveStatusCheckContexts.Input.Headers = .init(),
                body: Operations.ReposRemoveStatusCheckContexts.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/DELETE/responses/200/content/application\/json`.
                    case json([Swift.String])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Swift.String] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposRemoveStatusCheckContexts.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposRemoveStatusCheckContexts.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/delete(repos/remove-status-check-contexts)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposRemoveStatusCheckContexts.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposRemoveStatusCheckContexts.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/delete(repos/remove-status-check-contexts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts/delete(repos/remove-status-check-contexts)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists who has access to this protected branch.
    ///
    /// > [!NOTE]
    /// > Users, apps, and teams `restrictions` are only available for organization-owned repositories.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/get(repos/get-access-restrictions)`.
    public enum ReposGetAccessRestrictions {
        public static let id: Swift.String = "repos/get-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAccessRestrictions.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetAccessRestrictions.Input.Path,
                headers: Operations.ReposGetAccessRestrictions.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.BranchRestrictionPolicy)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BranchRestrictionPolicy {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/get(repos/get-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/get(repos/get-access-restrictions)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Disables the ability to restrict who can push to this branch.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/delete(repos/delete-access-restrictions)`.
    public enum ReposDeleteAccessRestrictions {
        public static let id: Swift.String = "repos/delete-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposDeleteAccessRestrictions.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDeleteAccessRestrictions.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/delete(repos/delete-access-restrictions)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteAccessRestrictions.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/delete(repos/delete-access-restrictions)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteAccessRestrictions.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Get apps with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the GitHub Apps that have push access to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/get(repos/get-apps-with-access-to-protected-branch)`.
    public enum ReposGetAppsWithAccessToProtectedBranch {
        public static let id: Swift.String = "repos/get-apps-with-access-to-protected-branch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetAppsWithAccessToProtectedBranch.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAppsWithAccessToProtectedBranch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAppsWithAccessToProtectedBranch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAppsWithAccessToProtectedBranch.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetAppsWithAccessToProtectedBranch.Input.Path,
                headers: Operations.ReposGetAppsWithAccessToProtectedBranch.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Integration])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Integration] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAppsWithAccessToProtectedBranch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAppsWithAccessToProtectedBranch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/get(repos/get-apps-with-access-to-protected-branch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAppsWithAccessToProtectedBranch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAppsWithAccessToProtectedBranch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/get(repos/get-apps-with-access-to-protected-branch)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Add app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified apps push access for this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/post(repos/add-app-access-restrictions)`.
    public enum ReposAddAppAccessRestrictions {
        public static let id: Swift.String = "repos/add-app-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposAddAppAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddAppAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddAppAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposAddAppAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/requestBody/json/apps`.
                    public var apps: [Swift.String]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - apps: The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
                    public init(apps: [Swift.String]) {
                        self.apps = apps
                    }
                    public enum CodingKeys: String, CodingKey {
                        case apps
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/requestBody/content/application\/json`.
                case json(Operations.ReposAddAppAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposAddAppAccessRestrictions.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposAddAppAccessRestrictions.Input.Path,
                headers: Operations.ReposAddAppAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposAddAppAccessRestrictions.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/POST/responses/200/content/application\/json`.
                    case json([Components.Schemas.Integration])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Integration] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposAddAppAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposAddAppAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/post(repos/add-app-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposAddAppAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposAddAppAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/post(repos/add-app-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Set app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of apps that have push access to this branch. This removes all apps that previously had push access and grants push access to the new list of apps. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/put(repos/set-app-access-restrictions)`.
    public enum ReposSetAppAccessRestrictions {
        public static let id: Swift.String = "repos/set-app-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposSetAppAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetAppAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetAppAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposSetAppAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/requestBody/json/apps`.
                    public var apps: [Swift.String]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - apps: The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
                    public init(apps: [Swift.String]) {
                        self.apps = apps
                    }
                    public enum CodingKeys: String, CodingKey {
                        case apps
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposSetAppAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposSetAppAccessRestrictions.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposSetAppAccessRestrictions.Input.Path,
                headers: Operations.ReposSetAppAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposSetAppAccessRestrictions.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/PUT/responses/200/content/application\/json`.
                    case json([Components.Schemas.Integration])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Integration] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposSetAppAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposSetAppAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/put(repos/set-app-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposSetAppAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposSetAppAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/put(repos/set-app-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Remove app access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of an app to push to this branch. Only GitHub Apps that are installed on the repository and that have been granted write access to the repository contents can be added as authorized actors on a protected branch.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/delete(repos/remove-app-access-restrictions)`.
    public enum ReposRemoveAppAccessRestrictions {
        public static let id: Swift.String = "repos/remove-app-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposRemoveAppAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveAppAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveAppAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRemoveAppAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/requestBody/json/apps`.
                    public var apps: [Swift.String]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - apps: The GitHub Apps that have push access to this branch. Use the slugified version of the app name. **Note**: The list of users, apps, and teams in total is limited to 100 items.
                    public init(apps: [Swift.String]) {
                        self.apps = apps
                    }
                    public enum CodingKeys: String, CodingKey {
                        case apps
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/requestBody/content/application\/json`.
                case json(Operations.ReposRemoveAppAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposRemoveAppAccessRestrictions.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposRemoveAppAccessRestrictions.Input.Path,
                headers: Operations.ReposRemoveAppAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposRemoveAppAccessRestrictions.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/DELETE/responses/200/content/application\/json`.
                    case json([Components.Schemas.Integration])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Integration] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposRemoveAppAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposRemoveAppAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/delete(repos/remove-app-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposRemoveAppAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposRemoveAppAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps/delete(repos/remove-app-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get teams with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the teams who have push access to this branch. The list includes child teams.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/get(repos/get-teams-with-access-to-protected-branch)`.
    public enum ReposGetTeamsWithAccessToProtectedBranch {
        public static let id: Swift.String = "repos/get-teams-with-access-to-protected-branch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetTeamsWithAccessToProtectedBranch.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetTeamsWithAccessToProtectedBranch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetTeamsWithAccessToProtectedBranch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetTeamsWithAccessToProtectedBranch.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetTeamsWithAccessToProtectedBranch.Input.Path,
                headers: Operations.ReposGetTeamsWithAccessToProtectedBranch.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Team])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Team] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetTeamsWithAccessToProtectedBranch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetTeamsWithAccessToProtectedBranch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/get(repos/get-teams-with-access-to-protected-branch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetTeamsWithAccessToProtectedBranch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetTeamsWithAccessToProtectedBranch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/get(repos/get-teams-with-access-to-protected-branch)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Add team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified teams push access for this branch. You can also give push access to child teams.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/post(repos/add-team-access-restrictions)`.
    public enum ReposAddTeamAccessRestrictions {
        public static let id: Swift.String = "repos/add-team-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposAddTeamAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddTeamAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddTeamAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposAddTeamAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/requestBody/json`.
                @frozen public enum JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/requestBody/json/case1`.
                    public struct Case1Payload: Codable, Hashable, Sendable {
                        /// The slug values for teams
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/requestBody/json/case1/teams`.
                        public var teams: [Swift.String]
                        /// Creates a new `Case1Payload`.
                        ///
                        /// - Parameters:
                        ///   - teams: The slug values for teams
                        public init(teams: [Swift.String]) {
                            self.teams = teams
                        }
                        public enum CodingKeys: String, CodingKey {
                            case teams
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/requestBody/json/case1`.
                    case case1(Operations.ReposAddTeamAccessRestrictions.Input.Body.JsonPayload.Case1Payload)
                    /// The slug values for teams
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/requestBody/json/case2`.
                    case case2([Swift.String])
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try value.encode(to: encoder)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/requestBody/content/application\/json`.
                case json(Operations.ReposAddTeamAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposAddTeamAccessRestrictions.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposAddTeamAccessRestrictions.Input.Path,
                headers: Operations.ReposAddTeamAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposAddTeamAccessRestrictions.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/POST/responses/200/content/application\/json`.
                    case json([Components.Schemas.Team])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Team] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposAddTeamAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposAddTeamAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/post(repos/add-team-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposAddTeamAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposAddTeamAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/post(repos/add-team-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Set team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of teams that have push access to this branch. This removes all teams that previously had push access and grants push access to the new list of teams. Team restrictions include child teams.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/put(repos/set-team-access-restrictions)`.
    public enum ReposSetTeamAccessRestrictions {
        public static let id: Swift.String = "repos/set-team-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposSetTeamAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetTeamAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetTeamAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposSetTeamAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/requestBody/json`.
                @frozen public enum JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/requestBody/json/case1`.
                    public struct Case1Payload: Codable, Hashable, Sendable {
                        /// The slug values for teams
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/requestBody/json/case1/teams`.
                        public var teams: [Swift.String]
                        /// Creates a new `Case1Payload`.
                        ///
                        /// - Parameters:
                        ///   - teams: The slug values for teams
                        public init(teams: [Swift.String]) {
                            self.teams = teams
                        }
                        public enum CodingKeys: String, CodingKey {
                            case teams
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/requestBody/json/case1`.
                    case case1(Operations.ReposSetTeamAccessRestrictions.Input.Body.JsonPayload.Case1Payload)
                    /// The slug values for teams
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/requestBody/json/case2`.
                    case case2([Swift.String])
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try value.encode(to: encoder)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposSetTeamAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposSetTeamAccessRestrictions.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposSetTeamAccessRestrictions.Input.Path,
                headers: Operations.ReposSetTeamAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposSetTeamAccessRestrictions.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/PUT/responses/200/content/application\/json`.
                    case json([Components.Schemas.Team])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Team] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposSetTeamAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposSetTeamAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/put(repos/set-team-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposSetTeamAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposSetTeamAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/put(repos/set-team-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Remove team access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of a team to push to this branch. You can also remove push access for child teams.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/delete(repos/remove-team-access-restrictions)`.
    public enum ReposRemoveTeamAccessRestrictions {
        public static let id: Swift.String = "repos/remove-team-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposRemoveTeamAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveTeamAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveTeamAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRemoveTeamAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/requestBody/json`.
                @frozen public enum JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/requestBody/json/case1`.
                    public struct Case1Payload: Codable, Hashable, Sendable {
                        /// The slug values for teams
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/requestBody/json/case1/teams`.
                        public var teams: [Swift.String]
                        /// Creates a new `Case1Payload`.
                        ///
                        /// - Parameters:
                        ///   - teams: The slug values for teams
                        public init(teams: [Swift.String]) {
                            self.teams = teams
                        }
                        public enum CodingKeys: String, CodingKey {
                            case teams
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/requestBody/json/case1`.
                    case case1(Operations.ReposRemoveTeamAccessRestrictions.Input.Body.JsonPayload.Case1Payload)
                    /// The slug values for teams
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/requestBody/json/case2`.
                    case case2([Swift.String])
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try .init(from: decoder))
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try value.encode(to: encoder)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/requestBody/content/application\/json`.
                case json(Operations.ReposRemoveTeamAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposRemoveTeamAccessRestrictions.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposRemoveTeamAccessRestrictions.Input.Path,
                headers: Operations.ReposRemoveTeamAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposRemoveTeamAccessRestrictions.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/DELETE/responses/200/content/application\/json`.
                    case json([Components.Schemas.Team])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Team] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposRemoveTeamAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposRemoveTeamAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/delete(repos/remove-team-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposRemoveTeamAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposRemoveTeamAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams/delete(repos/remove-team-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get users with access to the protected branch
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Lists the people who have push access to this branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/get(repos/get-users-with-access-to-protected-branch)`.
    public enum ReposGetUsersWithAccessToProtectedBranch {
        public static let id: Swift.String = "repos/get-users-with-access-to-protected-branch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetUsersWithAccessToProtectedBranch.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetUsersWithAccessToProtectedBranch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetUsersWithAccessToProtectedBranch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetUsersWithAccessToProtectedBranch.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetUsersWithAccessToProtectedBranch.Input.Path,
                headers: Operations.ReposGetUsersWithAccessToProtectedBranch.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.SimpleUser])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.SimpleUser] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetUsersWithAccessToProtectedBranch.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetUsersWithAccessToProtectedBranch.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/get(repos/get-users-with-access-to-protected-branch)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetUsersWithAccessToProtectedBranch.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetUsersWithAccessToProtectedBranch.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/get(repos/get-users-with-access-to-protected-branch)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Add user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Grants the specified people push access for this branch.
    ///
    /// | Type    | Description                                                                                                                   |
    /// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/post(repos/add-user-access-restrictions)`.
    public enum ReposAddUserAccessRestrictions {
        public static let id: Swift.String = "repos/add-user-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposAddUserAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddUserAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddUserAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposAddUserAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The username for users
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/requestBody/json/users`.
                    public var users: [Swift.String]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - users: The username for users
                    public init(users: [Swift.String]) {
                        self.users = users
                    }
                    public enum CodingKeys: String, CodingKey {
                        case users
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/requestBody/content/application\/json`.
                case json(Operations.ReposAddUserAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposAddUserAccessRestrictions.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposAddUserAccessRestrictions.Input.Path,
                headers: Operations.ReposAddUserAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposAddUserAccessRestrictions.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/POST/responses/200/content/application\/json`.
                    case json([Components.Schemas.SimpleUser])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.SimpleUser] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposAddUserAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposAddUserAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/post(repos/add-user-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposAddUserAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposAddUserAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/post(repos/add-user-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Set user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Replaces the list of people that have push access to this branch. This removes all people that previously had push access and grants push access to the new list of people.
    ///
    /// | Type    | Description                                                                                                                   |
    /// | ------- | ----------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames for people who can have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/put(repos/set-user-access-restrictions)`.
    public enum ReposSetUserAccessRestrictions {
        public static let id: Swift.String = "repos/set-user-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposSetUserAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetUserAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposSetUserAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposSetUserAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The username for users
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/requestBody/json/users`.
                    public var users: [Swift.String]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - users: The username for users
                    public init(users: [Swift.String]) {
                        self.users = users
                    }
                    public enum CodingKeys: String, CodingKey {
                        case users
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposSetUserAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposSetUserAccessRestrictions.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposSetUserAccessRestrictions.Input.Path,
                headers: Operations.ReposSetUserAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposSetUserAccessRestrictions.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/PUT/responses/200/content/application\/json`.
                    case json([Components.Schemas.SimpleUser])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.SimpleUser] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposSetUserAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposSetUserAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/put(repos/set-user-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposSetUserAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposSetUserAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/put(repos/set-user-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Remove user access restrictions
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Removes the ability of a user to push to this branch.
    ///
    /// | Type    | Description                                                                                                                                   |
    /// | ------- | --------------------------------------------------------------------------------------------------------------------------------------------- |
    /// | `array` | Usernames of the people who should no longer have push access. **Note**: The list of users, apps, and teams in total is limited to 100 items. |
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/delete(repos/remove-user-access-restrictions)`.
    public enum ReposRemoveUserAccessRestrictions {
        public static let id: Swift.String = "repos/remove-user-access-restrictions"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposRemoveUserAccessRestrictions.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveUserAccessRestrictions.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveUserAccessRestrictions.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRemoveUserAccessRestrictions.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The username for users
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/requestBody/json/users`.
                    public var users: [Swift.String]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - users: The username for users
                    public init(users: [Swift.String]) {
                        self.users = users
                    }
                    public enum CodingKeys: String, CodingKey {
                        case users
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/requestBody/content/application\/json`.
                case json(Operations.ReposRemoveUserAccessRestrictions.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposRemoveUserAccessRestrictions.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposRemoveUserAccessRestrictions.Input.Path,
                headers: Operations.ReposRemoveUserAccessRestrictions.Input.Headers = .init(),
                body: Operations.ReposRemoveUserAccessRestrictions.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/DELETE/responses/200/content/application\/json`.
                    case json([Components.Schemas.SimpleUser])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.SimpleUser] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposRemoveUserAccessRestrictions.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposRemoveUserAccessRestrictions.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/delete(repos/remove-user-access-restrictions)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposRemoveUserAccessRestrictions.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposRemoveUserAccessRestrictions.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users/delete(repos/remove-user-access-restrictions)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Rename a branch
    ///
    /// Renames a branch in a repository.
    ///
    /// > [!NOTE]
    /// > Although the API responds immediately, the branch rename process might take some extra time to complete in the background. You won't be able to push to the old branch name while the rename process is in progress. For more information, see "[Renaming a branch](https://docs.github.com/github/administering-a-repository/renaming-a-branch)".
    ///
    /// The authenticated user must have push access to the branch. If the branch is the default branch, the authenticated user must also have admin or owner permissions.
    ///
    /// In order to rename the default branch, fine-grained access tokens also need the `administration:write` repository permission.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/branches/{branch}/rename`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/rename/post(repos/rename-branch)`.
    public enum ReposRenameBranch {
        public static let id: Swift.String = "repos/rename-branch"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposRenameBranch.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRenameBranch.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRenameBranch.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRenameBranch.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The new name of the branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/requestBody/json/new_name`.
                    public var newName: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - newName: The new name of the branch.
                    public init(newName: Swift.String) {
                        self.newName = newName
                    }
                    public enum CodingKeys: String, CodingKey {
                        case newName = "new_name"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/requestBody/content/application\/json`.
                case json(Operations.ReposRenameBranch.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposRenameBranch.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposRenameBranch.Input.Path,
                headers: Operations.ReposRenameBranch.Input.Headers = .init(),
                body: Operations.ReposRenameBranch.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/branches/{branch}/rename/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.BranchWithProtection)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BranchWithProtection {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposRenameBranch.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposRenameBranch.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/rename/post(repos/rename-branch)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposRenameBranch.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposRenameBranch.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/rename/post(repos/rename-branch)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/rename/post(repos/rename-branch)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/branches/{branch}/rename/post(repos/rename-branch)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List CODEOWNERS errors
    ///
    /// List any syntax errors that are detected in the CODEOWNERS
    /// file.
    ///
    /// For more information about the correct CODEOWNERS syntax,
    /// see "[About code owners](https://docs.github.com/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/codeowners/errors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/codeowners/errors/get(repos/codeowners-errors)`.
    public enum ReposCodeownersErrors {
        public static let id: Swift.String = "repos/codeowners-errors"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCodeownersErrors.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/query`.
            public struct Query: Sendable, Hashable {
                /// A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/query/ref`.
                public var ref: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - ref: A branch, tag or commit name used to determine which version of the CODEOWNERS file to use. Default: the repository's default branch (e.g. `main`)
                public init(ref: Swift.String? = nil) {
                    self.ref = ref
                }
            }
            public var query: Operations.ReposCodeownersErrors.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCodeownersErrors.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCodeownersErrors.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCodeownersErrors.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposCodeownersErrors.Input.Path,
                query: Operations.ReposCodeownersErrors.Input.Query = .init(),
                headers: Operations.ReposCodeownersErrors.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/codeowners/errors/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CodeownersErrors)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CodeownersErrors {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCodeownersErrors.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCodeownersErrors.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/codeowners/errors/get(repos/codeowners-errors)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCodeownersErrors.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCodeownersErrors.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// Creates a new `NotFound`.
                public init() {}
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/codeowners/errors/get(repos/codeowners-errors)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposCodeownersErrors.Output.NotFound)
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/codeowners/errors/get(repos/codeowners-errors)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            public static var notFound: Self {
                .notFound(.init())
            }
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposCodeownersErrors.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repository collaborators
    ///
    /// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    /// The `permissions` hash returned in the response contains the base role permissions of the collaborator. The `role_name` is the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
    /// There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
    ///
    /// Team members will include the members of child teams.
    ///
    /// The authenticated user must have write, maintain, or admin privileges on the repository to use this endpoint. For organization-owned repositories, the authenticated user needs to be a member of the organization.
    /// OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/get(repos/list-collaborators)`.
    public enum ReposListCollaborators {
        public static let id: Swift.String = "repos/list-collaborators"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListCollaborators.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/query/affiliation`.
                @frozen public enum AffiliationPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case outside = "outside"
                    case direct = "direct"
                    case all = "all"
                }
                /// Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/query/affiliation`.
                public var affiliation: Operations.ReposListCollaborators.Input.Query.AffiliationPayload?
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/query/permission`.
                @frozen public enum PermissionPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case pull = "pull"
                    case triage = "triage"
                    case push = "push"
                    case maintain = "maintain"
                    case admin = "admin"
                }
                /// Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/query/permission`.
                public var permission: Operations.ReposListCollaborators.Input.Query.PermissionPayload?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - affiliation: Filter collaborators returned by their affiliation. `outside` means all outside collaborators of an organization-owned repository. `direct` means all collaborators with permissions to an organization-owned repository, regardless of organization membership status. `all` means all collaborators the authenticated user can see.
                ///   - permission: Filter collaborators by the permissions they have on the repository. If not specified, all collaborators will be returned.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    affiliation: Operations.ReposListCollaborators.Input.Query.AffiliationPayload? = nil,
                    permission: Operations.ReposListCollaborators.Input.Query.PermissionPayload? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.affiliation = affiliation
                    self.permission = permission
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListCollaborators.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCollaborators.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCollaborators.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListCollaborators.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListCollaborators.Input.Path,
                query: Operations.ReposListCollaborators.Input.Query = .init(),
                headers: Operations.ReposListCollaborators.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListCollaborators.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Collaborator])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Collaborator] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListCollaborators.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListCollaborators.Output.Ok.Headers = .init(),
                    body: Operations.ReposListCollaborators.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/get(repos/list-collaborators)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListCollaborators.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListCollaborators.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/get(repos/list-collaborators)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Check if a user is a repository collaborator
    ///
    /// For organization-owned repositories, the list of collaborators includes outside collaborators, organization members that are direct collaborators, organization members with access through team memberships, organization members with access through default organization permissions, and organization owners.
    ///
    /// Team members will include the members of child teams.
    ///
    /// The authenticated user must have push access to the repository to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `read:org` and `repo` scopes to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/get(repos/check-collaborator)`.
    public enum ReposCheckCollaborator {
        public static let id: Swift.String = "repos/check-collaborator"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The handle for the GitHub user account.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/GET/path/username`.
                public var username: Components.Parameters.Username
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - username: The handle for the GitHub user account.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    username: Components.Parameters.Username
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.username = username
                }
            }
            public var path: Operations.ReposCheckCollaborator.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposCheckCollaborator.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response if user is a collaborator
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/get(repos/check-collaborator)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposCheckCollaborator.Output.NoContent)
            /// Response if user is a collaborator
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/get(repos/check-collaborator)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposCheckCollaborator.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// Creates a new `NotFound`.
                public init() {}
            }
            /// Not Found if user is not a collaborator
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/get(repos/check-collaborator)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposCheckCollaborator.Output.NotFound)
            /// Not Found if user is not a collaborator
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/get(repos/check-collaborator)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            public static var notFound: Self {
                .notFound(.init())
            }
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposCheckCollaborator.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Add a repository collaborator
    ///
    /// Add a user to a repository with a specified level of access. If the repository is owned by an organization, this API does not add the user to the organization - a user that has repository access without being an organization member is called an "outside collaborator" (if they are not an Enterprise Managed User) or a "repository collaborator" if they are an Enterprise Managed User. These users are exempt from some organization policies - see "[Adding outside collaborators to repositories](https://docs.github.com/organizations/managing-user-access-to-your-organizations-repositories/managing-outside-collaborators/adding-outside-collaborators-to-repositories-in-your-organization)" to learn more about these collaborator types.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications).
    ///
    /// Adding an outside collaborator may be restricted by enterprise and organization administrators. For more information, see "[Enforcing repository management policies in your enterprise](https://docs.github.com/admin/policies/enforcing-policies-for-your-enterprise/enforcing-repository-management-policies-in-your-enterprise#enforcing-a-policy-for-inviting-outside-collaborators-to-repositories)" and "[Setting permissions for adding outside collaborators](https://docs.github.com/organizations/managing-organization-settings/setting-permissions-for-adding-outside-collaborators)" for organization settings.
    ///
    /// For more information on permission levels, see "[Repository permission levels for an organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/repository-permission-levels-for-an-organization#permission-levels-for-repositories-owned-by-an-organization)". There are restrictions on which permissions can be granted to organization members when an organization base role is in place. In this case, the role being given must be equal to or higher than the org base permission. Otherwise, the request will fail with:
    ///
    /// ```
    /// Cannot assign {member} permission of {role name}
    /// ```
    ///
    /// Note that, if you choose not to pass any parameters, you'll need to set `Content-Length` to zero when calling out to this endpoint. For more information, see "[HTTP method](https://docs.github.com/rest/guides/getting-started-with-the-rest-api#http-method)."
    ///
    /// The invitee will receive a notification that they have been invited to the repository, which they must accept or decline. They may do this via the notifications page, the email they receive, or by using the [API](https://docs.github.com/rest/collaborators/invitations).
    ///
    /// For Enterprise Managed Users, this endpoint does not send invitations - these users are automatically added to organizations and repositories. Enterprise Managed Users can only be added to organizations and repositories within their enterprise.
    ///
    /// **Updating an existing collaborator's permission level**
    ///
    /// The endpoint can also be used to change the permissions of an existing collaborator without first removing and re-adding the collaborator. To change the permissions, use the same endpoint and pass a different `permission` parameter. The response will be a `204`, with no other indication that the permission level changed.
    ///
    /// **Rate limits**
    ///
    /// You are limited to sending 50 invitations to a repository per 24 hour period. Note there is no limit if you are inviting organization members to an organization repository.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)`.
    public enum ReposAddCollaborator {
        public static let id: Swift.String = "repos/add-collaborator"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The handle for the GitHub user account.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/path/username`.
                public var username: Components.Parameters.Username
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - username: The handle for the GitHub user account.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    username: Components.Parameters.Username
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.username = username
                }
            }
            public var path: Operations.ReposAddCollaborator.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddCollaborator.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAddCollaborator.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposAddCollaborator.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/requestBody/json/permission`.
                    public var permission: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - permission: The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.
                    public init(permission: Swift.String? = nil) {
                        self.permission = permission
                    }
                    public enum CodingKeys: String, CodingKey {
                        case permission
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposAddCollaborator.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposAddCollaborator.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposAddCollaborator.Input.Path,
                headers: Operations.ReposAddCollaborator.Input.Headers = .init(),
                body: Operations.ReposAddCollaborator.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/responses/201/content/application\/json`.
                    case json(Components.Schemas.RepositoryInvitation)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryInvitation {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposAddCollaborator.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposAddCollaborator.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response when a new invitation is created
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposAddCollaborator.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposAddCollaborator.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response when:
            /// - an existing collaborator is added as a collaborator
            /// - an organization member is added as an individual collaborator
            /// - an existing team member (whose team is also a repository collaborator) is added as an individual collaborator
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposAddCollaborator.Output.NoContent)
            /// Response when:
            /// - an existing collaborator is added as a collaborator
            /// - an organization member is added as an individual collaborator
            /// - an existing team member (whose team is also a repository collaborator) is added as an individual collaborator
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposAddCollaborator.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            public struct UnprocessableContent: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/responses/422/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/PUT/responses/422/content/application\/json`.
                    case json(Components.Schemas.ValidationError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ValidationError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposAddCollaborator.Output.UnprocessableContent.Body
                /// Creates a new `UnprocessableContent`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposAddCollaborator.Output.UnprocessableContent.Body) {
                    self.body = body
                }
            }
            /// Response when:
            /// - validation failed, or the endpoint has been spammed
            /// - an Enterprise Managed User (EMU) account was invited to a repository in an enterprise with personal user accounts
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Operations.ReposAddCollaborator.Output.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Operations.ReposAddCollaborator.Output.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/put(repos/add-collaborator)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Remove a repository collaborator
    ///
    /// Removes a collaborator from a repository.
    ///
    /// To use this endpoint, the authenticated user must either be an administrator of the repository or target themselves for removal.
    ///
    /// This endpoint also:
    /// - Cancels any outstanding invitations sent by the collaborator
    /// - Unassigns the user from any issues
    /// - Removes access to organization projects if the user is not an organization member and is not a collaborator on any other organization repositories.
    /// - Unstars the repository
    /// - Updates access permissions to packages
    ///
    /// Removing a user as a collaborator has the following effects on forks:
    ///  - If the user had access to a fork through their membership to this repository, the user will also be removed from the fork.
    ///  - If the user had their own fork of the repository, the fork will be deleted.
    ///  - If the user still has read access to the repository, open pull requests by this user from a fork will be denied.
    ///
    /// > [!NOTE]
    /// > A user can still have access to the repository through organization permissions like base repository permissions.
    ///
    /// Although the API responds immediately, the additional permission updates might take some extra time to complete in the background.
    ///
    /// For more information on fork permissions, see "[About permissions and visibility of forks](https://docs.github.com/pull-requests/collaborating-with-pull-requests/working-with-forks/about-permissions-and-visibility-of-forks)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/collaborators/{username}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/delete(repos/remove-collaborator)`.
    public enum ReposRemoveCollaborator {
        public static let id: Swift.String = "repos/remove-collaborator"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The handle for the GitHub user account.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/DELETE/path/username`.
                public var username: Components.Parameters.Username
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - username: The handle for the GitHub user account.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    username: Components.Parameters.Username
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.username = username
                }
            }
            public var path: Operations.ReposRemoveCollaborator.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveCollaborator.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRemoveCollaborator.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRemoveCollaborator.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposRemoveCollaborator.Input.Path,
                headers: Operations.ReposRemoveCollaborator.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// No Content when collaborator was removed from the repository.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/delete(repos/remove-collaborator)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposRemoveCollaborator.Output.NoContent)
            /// No Content when collaborator was removed from the repository.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/delete(repos/remove-collaborator)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposRemoveCollaborator.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/delete(repos/remove-collaborator)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/delete(repos/remove-collaborator)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get repository permissions for a user
    ///
    /// Checks the repository permission and role of a collaborator.
    ///
    /// The `permission` attribute provides the legacy base roles of `admin`, `write`, `read`, and `none`, where the
    /// `maintain` role is mapped to `write` and the `triage` role is mapped to `read`.
    /// The `role_name` attribute provides the name of the assigned role, including custom roles. The
    /// `permission` can also be used to determine which base level of access the collaborator has to the repository.
    ///
    /// The calculated permissions are the highest role assigned to the collaborator after considering all sources of grants, including: repo, teams, organization, and enterprise.
    /// There is presently not a way to differentiate between an organization level grant and a repository level grant from this endpoint response.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/collaborators/{username}/permission`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/permission/get(repos/get-collaborator-permission-level)`.
    public enum ReposGetCollaboratorPermissionLevel {
        public static let id: Swift.String = "repos/get-collaborator-permission-level"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/permission/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/permission/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/permission/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The handle for the GitHub user account.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/permission/GET/path/username`.
                public var username: Components.Parameters.Username
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - username: The handle for the GitHub user account.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    username: Components.Parameters.Username
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.username = username
                }
            }
            public var path: Operations.ReposGetCollaboratorPermissionLevel.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/permission/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCollaboratorPermissionLevel.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCollaboratorPermissionLevel.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCollaboratorPermissionLevel.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCollaboratorPermissionLevel.Input.Path,
                headers: Operations.ReposGetCollaboratorPermissionLevel.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/permission/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/collaborators/{username}/permission/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RepositoryCollaboratorPermission)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryCollaboratorPermission {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCollaboratorPermissionLevel.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCollaboratorPermissionLevel.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// if user has admin permissions
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/permission/get(repos/get-collaborator-permission-level)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCollaboratorPermissionLevel.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCollaboratorPermissionLevel.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/collaborators/{username}/permission/get(repos/get-collaborator-permission-level)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List commit comments for a repository
    ///
    /// Lists the commit comments for a specified repository. Comments are ordered by ascending ID.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/get(repos/list-commit-comments-for-repo)`.
    public enum ReposListCommitCommentsForRepo {
        public static let id: Swift.String = "repos/list-commit-comments-for-repo"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListCommitCommentsForRepo.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListCommitCommentsForRepo.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommitCommentsForRepo.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommitCommentsForRepo.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListCommitCommentsForRepo.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListCommitCommentsForRepo.Input.Path,
                query: Operations.ReposListCommitCommentsForRepo.Input.Query = .init(),
                headers: Operations.ReposListCommitCommentsForRepo.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListCommitCommentsForRepo.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.CommitComment])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.CommitComment] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListCommitCommentsForRepo.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListCommitCommentsForRepo.Output.Ok.Headers = .init(),
                    body: Operations.ReposListCommitCommentsForRepo.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/get(repos/list-commit-comments-for-repo)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListCommitCommentsForRepo.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListCommitCommentsForRepo.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a commit comment
    ///
    /// Gets a specified commit comment.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/get(repos/get-commit-comment)`.
    public enum ReposGetCommitComment {
        public static let id: Swift.String = "repos/get-commit-comment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the comment.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/GET/path/comment_id`.
                public var commentId: Components.Parameters.CommentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - commentId: The unique identifier of the comment.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    commentId: Components.Parameters.CommentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.commentId = commentId
                }
            }
            public var path: Operations.ReposGetCommitComment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommitComment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommitComment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCommitComment.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCommitComment.Input.Path,
                headers: Operations.ReposGetCommitComment.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CommitComment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CommitComment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCommitComment.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCommitComment.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/get(repos/get-commit-comment)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCommitComment.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCommitComment.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/get(repos/get-commit-comment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a commit comment
    ///
    /// Updates the contents of a specified commit comment.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/patch(repos/update-commit-comment)`.
    public enum ReposUpdateCommitComment {
        public static let id: Swift.String = "repos/update-commit-comment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the comment.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/path/comment_id`.
                public var commentId: Components.Parameters.CommentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - commentId: The unique identifier of the comment.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    commentId: Components.Parameters.CommentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.commentId = commentId
                }
            }
            public var path: Operations.ReposUpdateCommitComment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateCommitComment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateCommitComment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateCommitComment.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The contents of the comment
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/requestBody/json/body`.
                    public var body: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - body: The contents of the comment
                    public init(body: Swift.String) {
                        self.body = body
                    }
                    public enum CodingKeys: String, CodingKey {
                        case body
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateCommitComment.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateCommitComment.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateCommitComment.Input.Path,
                headers: Operations.ReposUpdateCommitComment.Input.Headers = .init(),
                body: Operations.ReposUpdateCommitComment.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.CommitComment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CommitComment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateCommitComment.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateCommitComment.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/patch(repos/update-commit-comment)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateCommitComment.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateCommitComment.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/patch(repos/update-commit-comment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a commit comment
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/comments/{comment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/delete(repos/delete-commit-comment)`.
    public enum ReposDeleteCommitComment {
        public static let id: Swift.String = "repos/delete-commit-comment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the comment.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/DELETE/path/comment_id`.
                public var commentId: Components.Parameters.CommentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - commentId: The unique identifier of the comment.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    commentId: Components.Parameters.CommentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.commentId = commentId
                }
            }
            public var path: Operations.ReposDeleteCommitComment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/comments/{comment_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteCommitComment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteCommitComment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteCommitComment.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteCommitComment.Input.Path,
                headers: Operations.ReposDeleteCommitComment.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/delete(repos/delete-commit-comment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteCommitComment.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/delete(repos/delete-commit-comment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteCommitComment.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/comments/{comment_id}/delete(repos/delete-commit-comment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List commits
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)`.
    public enum ReposListCommits {
        public static let id: Swift.String = "repos/list-commits"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListCommits.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query`.
            public struct Query: Sendable, Hashable {
                /// SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/sha`.
                public var sha: Swift.String?
                /// Only commits containing this file path will be returned.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/path`.
                public var path: Swift.String?
                /// GitHub username or email address to use to filter by commit author.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/author`.
                public var author: Swift.String?
                /// GitHub username or email address to use to filter by commit committer.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/committer`.
                public var committer: Swift.String?
                /// Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/since`.
                public var since: Foundation.Date?
                /// Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/until`.
                public var until: Foundation.Date?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - sha: SHA or branch to start listing commits from. Default: the repositorys default branch (usually `main`).
                ///   - path: Only commits containing this file path will be returned.
                ///   - author: GitHub username or email address to use to filter by commit author.
                ///   - committer: GitHub username or email address to use to filter by commit committer.
                ///   - since: Only show results that were last updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
                ///   - until: Only commits before this date will be returned. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Due to limitations of Git, timestamps must be between 1970-01-01 and 2099-12-31 (inclusive) or unexpected results may be returned.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    sha: Swift.String? = nil,
                    path: Swift.String? = nil,
                    author: Swift.String? = nil,
                    committer: Swift.String? = nil,
                    since: Foundation.Date? = nil,
                    until: Foundation.Date? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.sha = sha
                    self.path = path
                    self.author = author
                    self.committer = committer
                    self.since = since
                    self.until = until
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListCommits.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommits.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommits.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListCommits.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListCommits.Input.Path,
                query: Operations.ReposListCommits.Input.Query = .init(),
                headers: Operations.ReposListCommits.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListCommits.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Commit])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Commit] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListCommits.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListCommits.Output.Ok.Headers = .init(),
                    body: Operations.ReposListCommits.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListCommits.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListCommits.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/get(repos/list-commits)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// List branches for HEAD commit
    ///
    /// Protected branches are available in public repositories with GitHub Free and GitHub Free for organizations, and in public and private repositories with GitHub Pro, GitHub Team, GitHub Enterprise Cloud, and GitHub Enterprise Server. For more information, see [GitHub's products](https://docs.github.com/github/getting-started-with-github/githubs-products) in the GitHub Help documentation.
    ///
    /// Returns all branches where the given commit SHA is the HEAD, or latest commit for the branch.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/get(repos/list-branches-for-head-commit)`.
    public enum ReposListBranchesForHeadCommit {
        public static let id: Swift.String = "repos/list-branches-for-head-commit"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The SHA of the commit.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/GET/path/commit_sha`.
                public var commitSha: Components.Parameters.CommitSha
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - commitSha: The SHA of the commit.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    commitSha: Components.Parameters.CommitSha
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.commitSha = commitSha
                }
            }
            public var path: Operations.ReposListBranchesForHeadCommit.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListBranchesForHeadCommit.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListBranchesForHeadCommit.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListBranchesForHeadCommit.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposListBranchesForHeadCommit.Input.Path,
                headers: Operations.ReposListBranchesForHeadCommit.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.BranchShort])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.BranchShort] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListBranchesForHeadCommit.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListBranchesForHeadCommit.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/get(repos/list-branches-for-head-commit)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListBranchesForHeadCommit.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListBranchesForHeadCommit.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/get(repos/list-branches-for-head-commit)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head/get(repos/list-branches-for-head-commit)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List commit comments
    ///
    /// Lists the comments for a specified commit.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/get(repos/list-comments-for-commit)`.
    public enum ReposListCommentsForCommit {
        public static let id: Swift.String = "repos/list-comments-for-commit"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The SHA of the commit.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/path/commit_sha`.
                public var commitSha: Components.Parameters.CommitSha
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - commitSha: The SHA of the commit.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    commitSha: Components.Parameters.CommitSha
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.commitSha = commitSha
                }
            }
            public var path: Operations.ReposListCommentsForCommit.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListCommentsForCommit.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommentsForCommit.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommentsForCommit.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListCommentsForCommit.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListCommentsForCommit.Input.Path,
                query: Operations.ReposListCommentsForCommit.Input.Query = .init(),
                headers: Operations.ReposListCommentsForCommit.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListCommentsForCommit.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.CommitComment])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.CommitComment] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListCommentsForCommit.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListCommentsForCommit.Output.Ok.Headers = .init(),
                    body: Operations.ReposListCommentsForCommit.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/get(repos/list-comments-for-commit)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListCommentsForCommit.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListCommentsForCommit.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a commit comment
    ///
    /// Create a comment for a commit using its `:commit_sha`.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github-commitcomment.raw+json`**: Returns the raw markdown body. Response will include `body`. This is the default if you do not pass any specific media type.
    /// - **`application/vnd.github-commitcomment.text+json`**: Returns a text only representation of the markdown body. Response will include `body_text`.
    /// - **`application/vnd.github-commitcomment.html+json`**: Returns HTML rendered from the body's markdown. Response will include `body_html`.
    /// - **`application/vnd.github-commitcomment.full+json`**: Returns raw, text, and HTML representations. Response will include `body`, `body_text`, and `body_html`.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/commits/{commit_sha}/comments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/post(repos/create-commit-comment)`.
    public enum ReposCreateCommitComment {
        public static let id: Swift.String = "repos/create-commit-comment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The SHA of the commit.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/path/commit_sha`.
                public var commitSha: Components.Parameters.CommitSha
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - commitSha: The SHA of the commit.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    commitSha: Components.Parameters.CommitSha
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.commitSha = commitSha
                }
            }
            public var path: Operations.ReposCreateCommitComment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateCommitComment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateCommitComment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateCommitComment.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The contents of the comment.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/requestBody/json/body`.
                    public var body: Swift.String
                    /// Relative path of the file to comment on.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/requestBody/json/path`.
                    public var path: Swift.String?
                    /// Line index in the diff to comment on.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/requestBody/json/position`.
                    public var position: Swift.Int?
                    /// **Closing down notice**. Use **position** parameter instead. Line number in the file to comment on.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/requestBody/json/line`.
                    public var line: Swift.Int?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - body: The contents of the comment.
                    ///   - path: Relative path of the file to comment on.
                    ///   - position: Line index in the diff to comment on.
                    ///   - line: **Closing down notice**. Use **position** parameter instead. Line number in the file to comment on.
                    public init(
                        body: Swift.String,
                        path: Swift.String? = nil,
                        position: Swift.Int? = nil,
                        line: Swift.Int? = nil
                    ) {
                        self.body = body
                        self.path = path
                        self.position = position
                        self.line = line
                    }
                    public enum CodingKeys: String, CodingKey {
                        case body
                        case path
                        case position
                        case line
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateCommitComment.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateCommitComment.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateCommitComment.Input.Path,
                headers: Operations.ReposCreateCommitComment.Input.Headers = .init(),
                body: Operations.ReposCreateCommitComment.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateCommitComment.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/comments/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.CommitComment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CommitComment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateCommitComment.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateCommitComment.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateCommitComment.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/post(repos/create-commit-comment)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateCommitComment.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateCommitComment.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/post(repos/create-commit-comment)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/comments/post(repos/create-commit-comment)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List pull requests associated with a commit
    ///
    /// Lists the merged pull request that introduced the commit to the repository. If the commit is not present in the default branch, it will return merged and open pull requests associated with the commit.
    ///
    /// To list the open or merged pull requests associated with a branch, you can set the `commit_sha` parameter to the branch name.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/pulls/get(repos/list-pull-requests-associated-with-commit)`.
    public enum ReposListPullRequestsAssociatedWithCommit {
        public static let id: Swift.String = "repos/list-pull-requests-associated-with-commit"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The SHA of the commit.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/path/commit_sha`.
                public var commitSha: Components.Parameters.CommitSha
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - commitSha: The SHA of the commit.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    commitSha: Components.Parameters.CommitSha
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.commitSha = commitSha
                }
            }
            public var path: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListPullRequestsAssociatedWithCommit.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListPullRequestsAssociatedWithCommit.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Path,
                query: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Query = .init(),
                headers: Operations.ReposListPullRequestsAssociatedWithCommit.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListPullRequestsAssociatedWithCommit.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{commit_sha}/pulls/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.PullRequestSimple])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.PullRequestSimple] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListPullRequestsAssociatedWithCommit.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListPullRequestsAssociatedWithCommit.Output.Ok.Headers = .init(),
                    body: Operations.ReposListPullRequestsAssociatedWithCommit.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/pulls/get(repos/list-pull-requests-associated-with-commit)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListPullRequestsAssociatedWithCommit.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListPullRequestsAssociatedWithCommit.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{commit_sha}/pulls/get(repos/list-pull-requests-associated-with-commit)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a commit
    ///
    /// Returns the contents of a single commit reference. You must have `read` access for the repository to use this endpoint.
    ///
    /// > [!NOTE]
    /// > If there are more than 300 files in the commit diff and the default JSON media type is requested, the response will include pagination link headers for the remaining files, up to a limit of 3000 files. Each page contains the static commit information, and the only changes are to the file listing.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)." Pagination query parameters are not supported for these media types.
    ///
    /// - **`application/vnd.github.diff`**: Returns the diff of the commit. Larger diffs may time out and return a 5xx status code.
    /// - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property. Larger diffs may time out and return a 5xx status code.
    /// - **`application/vnd.github.sha`**: Returns the commit's SHA-1 hash. You can use this endpoint to check if a remote reference's SHA-1 hash is the same as your local reference's SHA-1 hash by providing the local SHA-1 reference as the ETag.
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The following fields are included in the `verification` object:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)`.
    public enum ReposGetCommit {
        public static let id: Swift.String = "repos/get-commit"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/path/ref`.
                public var ref: Components.Parameters.CommitRef
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - ref: The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    ref: Components.Parameters.CommitRef
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.ref = ref
                }
            }
            public var path: Operations.ReposGetCommit.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    page: Components.Parameters.Page? = nil,
                    perPage: Components.Parameters.PerPage? = nil
                ) {
                    self.page = page
                    self.perPage = perPage
                }
            }
            public var query: Operations.ReposGetCommit.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommit.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommit.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCommit.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetCommit.Input.Path,
                query: Operations.ReposGetCommit.Input.Query = .init(),
                headers: Operations.ReposGetCommit.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Commit)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Commit {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCommit.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCommit.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCommit.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCommit.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/get(repos/get-commit)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get the combined status for a specific reference
    ///
    /// Users with pull access in a repository can access a combined view of commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name.
    ///
    ///
    /// Additionally, a combined `state` is returned. The `state` is one of:
    ///
    /// *   **failure** if any of the contexts report as `error` or `failure`
    /// *   **pending** if there are no statuses or a context is `pending`
    /// *   **success** if the latest status for all contexts is `success`
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}/status`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/status/get(repos/get-combined-status-for-ref)`.
    public enum ReposGetCombinedStatusForRef {
        public static let id: Swift.String = "repos/get-combined-status-for-ref"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/path/ref`.
                public var ref: Components.Parameters.CommitRef
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - ref: The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    ref: Components.Parameters.CommitRef
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.ref = ref
                }
            }
            public var path: Operations.ReposGetCombinedStatusForRef.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposGetCombinedStatusForRef.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCombinedStatusForRef.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCombinedStatusForRef.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCombinedStatusForRef.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetCombinedStatusForRef.Input.Path,
                query: Operations.ReposGetCombinedStatusForRef.Input.Query = .init(),
                headers: Operations.ReposGetCombinedStatusForRef.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/status/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CombinedCommitStatus)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CombinedCommitStatus {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCombinedStatusForRef.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCombinedStatusForRef.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/status/get(repos/get-combined-status-for-ref)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCombinedStatusForRef.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCombinedStatusForRef.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/status/get(repos/get-combined-status-for-ref)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List commit statuses for a reference
    ///
    /// Users with pull access in a repository can view commit statuses for a given ref. The ref can be a SHA, a branch name, or a tag name. Statuses are returned in reverse chronological order. The first status in the list will be the latest one.
    ///
    /// This resource is also available via a legacy route: `GET /repos/:owner/:repo/statuses/:ref`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/commits/{ref}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/statuses/get(repos/list-commit-statuses-for-ref)`.
    public enum ReposListCommitStatusesForRef {
        public static let id: Swift.String = "repos/list-commit-statuses-for-ref"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/path/ref`.
                public var ref: Components.Parameters.CommitRef
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - ref: The commit reference. Can be a commit SHA, branch name (`heads/BRANCH_NAME`), or tag name (`tags/TAG_NAME`). For more information, see "[Git References](https://git-scm.com/book/en/v2/Git-Internals-Git-References)" in the Git documentation.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    ref: Components.Parameters.CommitRef
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.ref = ref
                }
            }
            public var path: Operations.ReposListCommitStatusesForRef.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListCommitStatusesForRef.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommitStatusesForRef.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCommitStatusesForRef.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListCommitStatusesForRef.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListCommitStatusesForRef.Input.Path,
                query: Operations.ReposListCommitStatusesForRef.Input.Query = .init(),
                headers: Operations.ReposListCommitStatusesForRef.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListCommitStatusesForRef.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/commits/{ref}/statuses/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Status])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Status] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListCommitStatusesForRef.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListCommitStatusesForRef.Output.Ok.Headers = .init(),
                    body: Operations.ReposListCommitStatusesForRef.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/statuses/get(repos/list-commit-statuses-for-ref)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListCommitStatusesForRef.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListCommitStatusesForRef.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Moved permanently
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/commits/{ref}/statuses/get(repos/list-commit-statuses-for-ref)/responses/301`.
            ///
            /// HTTP response code: `301 movedPermanently`.
            case movedPermanently(Components.Responses.MovedPermanently)
            /// The associated value of the enum case if `self` is `.movedPermanently`.
            ///
            /// - Throws: An error if `self` is not `.movedPermanently`.
            /// - SeeAlso: `.movedPermanently`.
            public var movedPermanently: Components.Responses.MovedPermanently {
                get throws {
                    switch self {
                    case let .movedPermanently(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "movedPermanently",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get community profile metrics
    ///
    /// Returns all community profile metrics for a repository. The repository cannot be a fork.
    ///
    /// The returned metrics include an overall health score, the repository description, the presence of documentation, the
    /// detected code of conduct, the detected license, and the presence of ISSUE\_TEMPLATE, PULL\_REQUEST\_TEMPLATE,
    /// README, and CONTRIBUTING files.
    ///
    /// The `health_percentage` score is defined as a percentage of how many of
    /// the recommended community health files are present. For more information, see
    /// "[About community profiles for public repositories](https://docs.github.com/communities/setting-up-your-project-for-healthy-contributions/about-community-profiles-for-public-repositories)."
    ///
    /// `content_reports_enabled` is only returned for organization-owned repositories.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/community/profile`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/community/profile/get(repos/get-community-profile-metrics)`.
    public enum ReposGetCommunityProfileMetrics {
        public static let id: Swift.String = "repos/get-community-profile-metrics"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/community/profile/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/community/profile/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/community/profile/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetCommunityProfileMetrics.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/community/profile/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommunityProfileMetrics.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommunityProfileMetrics.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCommunityProfileMetrics.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCommunityProfileMetrics.Input.Path,
                headers: Operations.ReposGetCommunityProfileMetrics.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/community/profile/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/community/profile/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CommunityProfile)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CommunityProfile {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCommunityProfileMetrics.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCommunityProfileMetrics.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/community/profile/get(repos/get-community-profile-metrics)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCommunityProfileMetrics.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCommunityProfileMetrics.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Compare two commits
    ///
    /// Compares two commits against one another. You can compare refs (branches or tags) and commit SHAs in the same repository, or you can compare refs and commit SHAs that exist in different repositories within the same repository network, including fork branches. For more information about how to view a repository's network, see "[Understanding connections between repositories](https://docs.github.com/repositories/viewing-activity-and-data-for-your-repository/understanding-connections-between-repositories)."
    ///
    /// This endpoint is equivalent to running the `git log BASE..HEAD` command, but it returns commits in a different order. The `git log BASE..HEAD` command returns commits in reverse chronological order, whereas the API returns commits in chronological order.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.diff`**: Returns the diff of the commit.
    /// - **`application/vnd.github.patch`**: Returns the patch of the commit. Diffs with binary data will have no `patch` property.
    ///
    /// The API response includes details about the files that were changed between the two commits. This includes the status of the change (if a file was added, removed, modified, or renamed), and details of the change itself. For example, files with a `renamed` status have a `previous_filename` field showing the previous filename of the file, and files with a `modified` status have a `patch` field showing the changes made to the file.
    ///
    /// When calling this endpoint without any paging parameter (`per_page` or `page`), the returned list is limited to 250 commits, and the last commit in the list is the most recent of the entire comparison.
    ///
    /// **Working with large comparisons**
    ///
    /// To process a response with a large number of commits, use a query parameter (`per_page` or `page`) to paginate the results. When using pagination:
    ///
    /// - The list of changed files is only shown on the first page of results, and it includes up to 300 changed files for the entire comparison.
    /// - The results are returned in chronological order, but the last commit in the returned list may not be the most recent one in the entire set if there are more pages of results.
    ///
    /// For more information on working with pagination, see "[Using pagination in the REST API](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api)."
    ///
    /// **Signature verification object**
    ///
    /// The response will include a `verification` object that describes the result of verifying the commit's signature. The `verification` object includes the following fields:
    ///
    /// | Name | Type | Description |
    /// | ---- | ---- | ----------- |
    /// | `verified` | `boolean` | Indicates whether GitHub considers the signature in this commit to be verified. |
    /// | `reason` | `string` | The reason for verified value. Possible values and their meanings are enumerated in table below. |
    /// | `signature` | `string` | The signature that was extracted from the commit. |
    /// | `payload` | `string` | The value that was signed. |
    /// | `verified_at` | `string` | The date the signature was verified by GitHub. |
    ///
    /// These are the possible values for `reason` in the `verification` object:
    ///
    /// | Value | Description |
    /// | ----- | ----------- |
    /// | `expired_key` | The key that made the signature is expired. |
    /// | `not_signing_key` | The "signing" flag is not among the usage flags in the GPG key that made the signature. |
    /// | `gpgverify_error` | There was an error communicating with the signature verification service. |
    /// | `gpgverify_unavailable` | The signature verification service is currently unavailable. |
    /// | `unsigned` | The object does not include a signature. |
    /// | `unknown_signature_type` | A non-PGP signature was found in the commit. |
    /// | `no_user` | No user was associated with the `committer` email address in the commit. |
    /// | `unverified_email` | The `committer` email address in the commit was associated with a user, but the email address is not verified on their account. |
    /// | `bad_email` | The `committer` email address in the commit is not included in the identities of the PGP key that made the signature. |
    /// | `unknown_key` | The key that made the signature has not been registered with any user's account. |
    /// | `malformed_signature` | There was an error parsing the signature. |
    /// | `invalid` | The signature could not be cryptographically verified using the key whose key-id was found in the signature. |
    /// | `valid` | None of the above errors applied, so the signature is considered to be verified. |
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/compare/{basehead}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)`.
    public enum ReposCompareCommits {
        public static let id: Swift.String = "repos/compare-commits"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/path/basehead`.
                public var basehead: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - basehead: The base branch and head branch to compare. This parameter expects the format `BASE...HEAD`. Both must be branch names in `repo`. To compare with a branch that exists in a different repository in the same network as `repo`, the `basehead` parameter expects the format `USERNAME:BASE...USERNAME:HEAD`.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    basehead: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.basehead = basehead
                }
            }
            public var path: Operations.ReposCompareCommits.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    page: Components.Parameters.Page? = nil,
                    perPage: Components.Parameters.PerPage? = nil
                ) {
                    self.page = page
                    self.perPage = perPage
                }
            }
            public var query: Operations.ReposCompareCommits.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCompareCommits.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCompareCommits.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCompareCommits.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposCompareCommits.Input.Path,
                query: Operations.ReposCompareCommits.Input.Query = .init(),
                headers: Operations.ReposCompareCommits.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/compare/{basehead}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CommitComparison)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CommitComparison {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCompareCommits.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCompareCommits.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCompareCommits.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCompareCommits.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/compare/{basehead}/get(repos/compare-commits)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get repository content
    ///
    /// Gets the contents of a file or directory in a repository. Specify the file path or directory with the `path` parameter. If you omit the `path` parameter, you will receive the contents of the repository's root directory.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents for files and symlinks.
    /// - **`application/vnd.github.html+json`**: Returns the file contents in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    /// - **`application/vnd.github.object+json`**: Returns the contents in a consistent object format regardless of the content type. For example, instead of an array of objects for a directory, the response will be an object with an `entries` attribute containing the array of objects.
    ///
    /// If the content is a directory, the response will be an array of objects, one object for each item in the directory. When listing the contents of a directory, submodules have their "type" specified as "file". Logically, the value _should_ be "submodule". This behavior exists [for backwards compatibility purposes](https://git.io/v1YCW). In the next major version of the API, the type will be returned as "submodule".
    ///
    /// If the content is a symlink and the symlink's target is a normal file in the repository, then the API responds with the content of the file. Otherwise, the API responds with an object describing the symlink itself.
    ///
    /// If the content is a submodule, the `submodule_git_url` field identifies the location of the submodule repository, and the `sha` identifies a specific commit within the submodule repository. Git uses the given URL when cloning the submodule repository, and checks out the submodule at that specific commit. If the submodule repository is not hosted on github.com, the Git URLs (`git_url` and `_links["git"]`) and the github.com URLs (`html_url` and `_links["html"]`) will have null values.
    ///
    /// **Notes**:
    ///
    /// - To get a repository's contents recursively, you can [recursively get the tree](https://docs.github.com/rest/git/trees#get-a-tree).
    /// - This API has an upper limit of 1,000 files for a directory. If you need to retrieve
    /// more files, use the [Git Trees API](https://docs.github.com/rest/git/trees#get-a-tree).
    /// - Download URLs expire and are meant to be used just once. To ensure the download URL does not expire, please use the contents API to obtain a fresh download URL for each download.
    /// - If the requested file's size is:
    ///   - 1 MB or smaller: All features of this endpoint are supported.
    ///   - Between 1-100 MB: Only the `raw` or `object` custom media types are supported. Both will work as normal, except that when using the `object` media type, the `content` field will be an empty
    /// string and the `encoding` field will be `"none"`. To get the contents of these larger files, use the `raw` media type.
    ///   - Greater than 100 MB: This endpoint is not supported.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)`.
    public enum ReposGetContent {
        public static let id: Swift.String = "repos/get-content"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// path parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/path/path`.
                public var path: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - path: path parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    path: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.path = path
                }
            }
            public var path: Operations.ReposGetContent.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The name of the commit/branch/tag. Default: the repositorys default branch.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/query/ref`.
                public var ref: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - ref: The name of the commit/branch/tag. Default: the repositorys default branch.
                public init(ref: Swift.String? = nil) {
                    self.ref = ref
                }
            }
            public var query: Operations.ReposGetContent.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetContent.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetContent.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetContent.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetContent.Input.Path,
                query: Operations.ReposGetContent.Input.Query = .init(),
                headers: Operations.ReposGetContent.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/GET/responses/200/content/application\/vnd.github.object`.
                    case applicationVnd_github_object(OpenAPIRuntime.HTTPBody)
                    /// The associated value of the enum case if `self` is `.applicationVnd_github_object`.
                    ///
                    /// - Throws: An error if `self` is not `.applicationVnd_github_object`.
                    /// - SeeAlso: `.applicationVnd_github_object`.
                    public var applicationVnd_github_object: OpenAPIRuntime.HTTPBody {
                        get throws {
                            switch self {
                            case let .applicationVnd_github_object(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetContent.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetContent.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetContent.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetContent.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)/responses/302`.
            ///
            /// HTTP response code: `302 found`.
            case found(Components.Responses.Found)
            /// Found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)/responses/302`.
            ///
            /// HTTP response code: `302 found`.
            public static var found: Self {
                .found(.init())
            }
            /// The associated value of the enum case if `self` is `.found`.
            ///
            /// - Throws: An error if `self` is not `.found`.
            /// - SeeAlso: `.found`.
            public var found: Components.Responses.Found {
                get throws {
                    switch self {
                    case let .found(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "found",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/get(repos/get-content)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case applicationVnd_github_object
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/vnd.github.object":
                    self = .applicationVnd_github_object
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .applicationVnd_github_object:
                    return "application/vnd.github.object"
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .applicationVnd_github_object,
                    .json
                ]
            }
        }
    }
    /// Create or update file contents
    ///
    /// Creates a new file or replaces an existing file in a repository.
    ///
    /// > [!NOTE]
    /// > If you use this endpoint and the "[Delete a file](https://docs.github.com/rest/repos/contents/#delete-a-file)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint. The `workflow` scope is also required in order to modify files in the `.github/workflows` directory.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)`.
    public enum ReposCreateOrUpdateFileContents {
        public static let id: Swift.String = "repos/create-or-update-file-contents"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// path parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/path/path`.
                public var path: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - path: path parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    path: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.path = path
                }
            }
            public var path: Operations.ReposCreateOrUpdateFileContents.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrUpdateFileContents.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrUpdateFileContents.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateOrUpdateFileContents.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The commit message.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/message`.
                    public var message: Swift.String
                    /// The new file content, using Base64 encoding.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/content`.
                    public var content: Swift.String
                    /// **Required if you are updating a file**. The blob SHA of the file being replaced.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/sha`.
                    public var sha: Swift.String?
                    /// The branch name. Default: the repositorys default branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/branch`.
                    public var branch: Swift.String?
                    /// The person that committed the file. Default: the authenticated user.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/committer`.
                    public struct CommitterPayload: Codable, Hashable, Sendable {
                        /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/committer/name`.
                        public var name: Swift.String
                        /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/committer/email`.
                        public var email: Swift.String
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/committer/date`.
                        public var date: Swift.String?
                        /// Creates a new `CommitterPayload`.
                        ///
                        /// - Parameters:
                        ///   - name: The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                        ///   - email: The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                        ///   - date:
                        public init(
                            name: Swift.String,
                            email: Swift.String,
                            date: Swift.String? = nil
                        ) {
                            self.name = name
                            self.email = email
                            self.date = date
                        }
                        public enum CodingKeys: String, CodingKey {
                            case name
                            case email
                            case date
                        }
                    }
                    /// The person that committed the file. Default: the authenticated user.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/committer`.
                    public var committer: Operations.ReposCreateOrUpdateFileContents.Input.Body.JsonPayload.CommitterPayload?
                    /// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/author`.
                    public struct AuthorPayload: Codable, Hashable, Sendable {
                        /// The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/author/name`.
                        public var name: Swift.String
                        /// The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/author/email`.
                        public var email: Swift.String
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/author/date`.
                        public var date: Swift.String?
                        /// Creates a new `AuthorPayload`.
                        ///
                        /// - Parameters:
                        ///   - name: The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted.
                        ///   - email: The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted.
                        ///   - date:
                        public init(
                            name: Swift.String,
                            email: Swift.String,
                            date: Swift.String? = nil
                        ) {
                            self.name = name
                            self.email = email
                            self.date = date
                        }
                        public enum CodingKeys: String, CodingKey {
                            case name
                            case email
                            case date
                        }
                    }
                    /// The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/json/author`.
                    public var author: Operations.ReposCreateOrUpdateFileContents.Input.Body.JsonPayload.AuthorPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - message: The commit message.
                    ///   - content: The new file content, using Base64 encoding.
                    ///   - sha: **Required if you are updating a file**. The blob SHA of the file being replaced.
                    ///   - branch: The branch name. Default: the repositorys default branch.
                    ///   - committer: The person that committed the file. Default: the authenticated user.
                    ///   - author: The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.
                    public init(
                        message: Swift.String,
                        content: Swift.String,
                        sha: Swift.String? = nil,
                        branch: Swift.String? = nil,
                        committer: Operations.ReposCreateOrUpdateFileContents.Input.Body.JsonPayload.CommitterPayload? = nil,
                        author: Operations.ReposCreateOrUpdateFileContents.Input.Body.JsonPayload.AuthorPayload? = nil
                    ) {
                        self.message = message
                        self.content = content
                        self.sha = sha
                        self.branch = branch
                        self.committer = committer
                        self.author = author
                    }
                    public enum CodingKeys: String, CodingKey {
                        case message
                        case content
                        case sha
                        case branch
                        case committer
                        case author
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposCreateOrUpdateFileContents.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateOrUpdateFileContents.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateOrUpdateFileContents.Input.Path,
                headers: Operations.ReposCreateOrUpdateFileContents.Input.Headers = .init(),
                body: Operations.ReposCreateOrUpdateFileContents.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/200/content/application\/json`.
                    case json(Components.Schemas.FileCommit)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FileCommit {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateOrUpdateFileContents.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateOrUpdateFileContents.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCreateOrUpdateFileContents.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCreateOrUpdateFileContents.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/201/content/application\/json`.
                    case json(Components.Schemas.FileCommit)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FileCommit {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateOrUpdateFileContents.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateOrUpdateFileContents.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateOrUpdateFileContents.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateOrUpdateFileContents.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            public struct Conflict: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/409/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/409/content/json`.
                    @frozen public enum JsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/409/content/json/case1`.
                        case BasicError(Components.Schemas.BasicError)
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/409/content/json/case2`.
                        case RepositoryRuleViolationError(Components.Schemas.RepositoryRuleViolationError)
                        public init(from decoder: any Decoder) throws {
                            var errors: [any Error] = []
                            do {
                                self = .BasicError(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            do {
                                self = .RepositoryRuleViolationError(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            throw Swift.DecodingError.failedToDecodeOneOfSchema(
                                type: Self.self,
                                codingPath: decoder.codingPath,
                                errors: errors
                            )
                        }
                        public func encode(to encoder: any Encoder) throws {
                            switch self {
                            case let .BasicError(value):
                                try value.encode(to: encoder)
                            case let .RepositoryRuleViolationError(value):
                                try value.encode(to: encoder)
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/PUT/responses/409/content/application\/json`.
                    case json(Operations.ReposCreateOrUpdateFileContents.Output.Conflict.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposCreateOrUpdateFileContents.Output.Conflict.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateOrUpdateFileContents.Output.Conflict.Body
                /// Creates a new `Conflict`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateOrUpdateFileContents.Output.Conflict.Body) {
                    self.body = body
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/put(repos/create-or-update-file-contents)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Operations.ReposCreateOrUpdateFileContents.Output.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Operations.ReposCreateOrUpdateFileContents.Output.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a file
    ///
    /// Deletes a file in a repository.
    ///
    /// You can provide an additional `committer` parameter, which is an object containing information about the committer. Or, you can provide an `author` parameter, which is an object containing information about the author.
    ///
    /// The `author` section is optional and is filled in with the `committer` information if omitted. If the `committer` information is omitted, the authenticated user's information is used.
    ///
    /// You must provide values for both `name` and `email`, whether you choose to use `author` or `committer`. Otherwise, you'll receive a `422` status code.
    ///
    /// > [!NOTE]
    /// > If you use this endpoint and the "[Create or update file contents](https://docs.github.com/rest/repos/contents/#create-or-update-file-contents)" endpoint in parallel, the concurrent requests will conflict and you will receive errors. You must use these endpoints serially instead.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/contents/{path}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)`.
    public enum ReposDeleteFile {
        public static let id: Swift.String = "repos/delete-file"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// path parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/path/path`.
                public var path: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - path: path parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    path: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.path = path
                }
            }
            public var path: Operations.ReposDeleteFile.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteFile.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteFile.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteFile.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The commit message.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/message`.
                    public var message: Swift.String
                    /// The blob SHA of the file being deleted.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/sha`.
                    public var sha: Swift.String
                    /// The branch name. Default: the repositorys default branch
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/branch`.
                    public var branch: Swift.String?
                    /// object containing information about the committer.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/committer`.
                    public struct CommitterPayload: Codable, Hashable, Sendable {
                        /// The name of the author (or committer) of the commit
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/committer/name`.
                        public var name: Swift.String?
                        /// The email of the author (or committer) of the commit
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/committer/email`.
                        public var email: Swift.String?
                        /// Creates a new `CommitterPayload`.
                        ///
                        /// - Parameters:
                        ///   - name: The name of the author (or committer) of the commit
                        ///   - email: The email of the author (or committer) of the commit
                        public init(
                            name: Swift.String? = nil,
                            email: Swift.String? = nil
                        ) {
                            self.name = name
                            self.email = email
                        }
                        public enum CodingKeys: String, CodingKey {
                            case name
                            case email
                        }
                    }
                    /// object containing information about the committer.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/committer`.
                    public var committer: Operations.ReposDeleteFile.Input.Body.JsonPayload.CommitterPayload?
                    /// object containing information about the author.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/author`.
                    public struct AuthorPayload: Codable, Hashable, Sendable {
                        /// The name of the author (or committer) of the commit
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/author/name`.
                        public var name: Swift.String?
                        /// The email of the author (or committer) of the commit
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/author/email`.
                        public var email: Swift.String?
                        /// Creates a new `AuthorPayload`.
                        ///
                        /// - Parameters:
                        ///   - name: The name of the author (or committer) of the commit
                        ///   - email: The email of the author (or committer) of the commit
                        public init(
                            name: Swift.String? = nil,
                            email: Swift.String? = nil
                        ) {
                            self.name = name
                            self.email = email
                        }
                        public enum CodingKeys: String, CodingKey {
                            case name
                            case email
                        }
                    }
                    /// object containing information about the author.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/json/author`.
                    public var author: Operations.ReposDeleteFile.Input.Body.JsonPayload.AuthorPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - message: The commit message.
                    ///   - sha: The blob SHA of the file being deleted.
                    ///   - branch: The branch name. Default: the repositorys default branch
                    ///   - committer: object containing information about the committer.
                    ///   - author: object containing information about the author.
                    public init(
                        message: Swift.String,
                        sha: Swift.String,
                        branch: Swift.String? = nil,
                        committer: Operations.ReposDeleteFile.Input.Body.JsonPayload.CommitterPayload? = nil,
                        author: Operations.ReposDeleteFile.Input.Body.JsonPayload.AuthorPayload? = nil
                    ) {
                        self.message = message
                        self.sha = sha
                        self.branch = branch
                        self.committer = committer
                        self.author = author
                    }
                    public enum CodingKeys: String, CodingKey {
                        case message
                        case sha
                        case branch
                        case committer
                        case author
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/requestBody/content/application\/json`.
                case json(Operations.ReposDeleteFile.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposDeleteFile.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposDeleteFile.Input.Path,
                headers: Operations.ReposDeleteFile.Input.Headers = .init(),
                body: Operations.ReposDeleteFile.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contents/{path}/DELETE/responses/200/content/application\/json`.
                    case json(Components.Schemas.FileCommit)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FileCommit {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposDeleteFile.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposDeleteFile.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposDeleteFile.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposDeleteFile.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Service unavailable
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contents/{path}/delete(repos/delete-file)/responses/503`.
            ///
            /// HTTP response code: `503 serviceUnavailable`.
            case serviceUnavailable(Components.Responses.ServiceUnavailable)
            /// The associated value of the enum case if `self` is `.serviceUnavailable`.
            ///
            /// - Throws: An error if `self` is not `.serviceUnavailable`.
            /// - SeeAlso: `.serviceUnavailable`.
            public var serviceUnavailable: Components.Responses.ServiceUnavailable {
                get throws {
                    switch self {
                    case let .serviceUnavailable(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "serviceUnavailable",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repository contributors
    ///
    /// Lists contributors to the specified repository and sorts them by the number of commits per contributor in descending order. This endpoint may return information that is a few hours old because the GitHub REST API caches contributor data to improve performance.
    ///
    /// GitHub identifies contributors by author email address. This endpoint groups contribution counts by GitHub user, which includes all associated email addresses. To improve performance, only the first 500 author email addresses in the repository link to GitHub users. The rest will appear as anonymous contributors without associated GitHub user information.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)`.
    public enum ReposListContributors {
        public static let id: Swift.String = "repos/list-contributors"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListContributors.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Set to `1` or `true` to include anonymous contributors in results.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/query/anon`.
                public var anon: Swift.String?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - anon: Set to `1` or `true` to include anonymous contributors in results.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    anon: Swift.String? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.anon = anon
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListContributors.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListContributors.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListContributors.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListContributors.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListContributors.Input.Path,
                query: Operations.ReposListContributors.Input.Query = .init(),
                headers: Operations.ReposListContributors.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListContributors.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/contributors/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Contributor])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Contributor] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListContributors.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListContributors.Output.Ok.Headers = .init(),
                    body: Operations.ReposListContributors.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// If repository contains content
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListContributors.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListContributors.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response if repository is empty
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposListContributors.Output.NoContent)
            /// Response if repository is empty
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposListContributors.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/contributors/get(repos/list-contributors)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List deployments
    ///
    /// Simple filtering of deployments is available via query parameters:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/get(repos/list-deployments)`.
    public enum ReposListDeployments {
        public static let id: Swift.String = "repos/list-deployments"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListDeployments.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The SHA recorded at creation time.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/query/sha`.
                public var sha: Swift.String?
                /// The name of the ref. This can be a branch, tag, or SHA.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/query/ref`.
                public var ref: Swift.String?
                /// The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/query/task`.
                public var task: Swift.String?
                /// The name of the environment that was deployed to (e.g., `staging` or `production`).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/query/environment`.
                public var environment: Swift.String?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - sha: The SHA recorded at creation time.
                ///   - ref: The name of the ref. This can be a branch, tag, or SHA.
                ///   - task: The name of the task for the deployment (e.g., `deploy` or `deploy:migrations`).
                ///   - environment: The name of the environment that was deployed to (e.g., `staging` or `production`).
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    sha: Swift.String? = nil,
                    ref: Swift.String? = nil,
                    task: Swift.String? = nil,
                    environment: Swift.String? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.sha = sha
                    self.ref = ref
                    self.task = task
                    self.environment = environment
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListDeployments.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeployments.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeployments.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListDeployments.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListDeployments.Input.Path,
                query: Operations.ReposListDeployments.Input.Query = .init(),
                headers: Operations.ReposListDeployments.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListDeployments.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Deployment])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Deployment] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListDeployments.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListDeployments.Output.Ok.Headers = .init(),
                    body: Operations.ReposListDeployments.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/get(repos/list-deployments)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListDeployments.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListDeployments.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a deployment
    ///
    /// Deployments offer a few configurable parameters with certain defaults.
    ///
    /// The `ref` parameter can be any named branch, tag, or SHA. At GitHub we often deploy branches and verify them
    /// before we merge a pull request.
    ///
    /// The `environment` parameter allows deployments to be issued to different runtime environments. Teams often have
    /// multiple environments for verifying their applications, such as `production`, `staging`, and `qa`. This parameter
    /// makes it easier to track which environments have requested deployments. The default environment is `production`.
    ///
    /// The `auto_merge` parameter is used to ensure that the requested ref is not behind the repository's default branch. If
    /// the ref _is_ behind the default branch for the repository, we will attempt to merge it for you. If the merge succeeds,
    /// the API will return a successful merge commit. If merge conflicts prevent the merge from succeeding, the API will
    /// return a failure response.
    ///
    /// By default, [commit statuses](https://docs.github.com/rest/commits/statuses) for every submitted context must be in a `success`
    /// state. The `required_contexts` parameter allows you to specify a subset of contexts that must be `success`, or to
    /// specify contexts that have not yet been submitted. You are not required to use commit statuses to deploy. If you do
    /// not require any contexts or create any commit statuses, the deployment will always succeed.
    ///
    /// The `payload` parameter is available for any extra information that a deployment system might need. It is a JSON text
    /// field that will be passed on when a deployment event is dispatched.
    ///
    /// The `task` parameter is used by the deployment system to allow different execution paths. In the web world this might
    /// be `deploy:migrations` to run schema changes on the system. In the compiled world this could be a flag to compile an
    /// application with debugging enabled.
    ///
    /// Merged branch response:
    ///
    /// You will see this response when GitHub automatically merges the base branch into the topic branch instead of creating
    /// a deployment. This auto-merge happens when:
    /// *   Auto-merge option is enabled in the repository
    /// *   Topic branch does not include the latest changes on the base branch, which is `master` in the response example
    /// *   There are no merge conflicts
    ///
    /// If there are no new commits in the base branch, a new request to create a deployment should give a successful
    /// response.
    ///
    /// Merge conflict response:
    ///
    /// This error happens when the `auto_merge` option is enabled and when the default branch (in this case `master`), can't
    /// be merged into the branch that's being deployed (in this case `topic-branch`), due to merge conflicts.
    ///
    /// Failed commit status checks:
    ///
    /// This error happens when the `required_contexts` parameter indicates that one or more contexts need to have a `success`
    /// status for the commit to be deployed, but one or more of the required contexts do not have a state of `success`.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)`.
    public enum ReposCreateDeployment {
        public static let id: Swift.String = "repos/create-deployment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateDeployment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeployment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeployment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateDeployment.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The ref to deploy. This can be a branch, tag, or SHA.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/ref`.
                    public var ref: Swift.String
                    /// Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/task`.
                    public var task: Swift.String?
                    /// Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/auto_merge`.
                    public var autoMerge: Swift.Bool?
                    /// The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/required_contexts`.
                    public var requiredContexts: [Swift.String]?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/payload`.
                    @frozen public enum PayloadPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/payload/case1`.
                        public struct Case1Payload: Codable, Hashable, Sendable {
                            /// A container of undocumented properties.
                            public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                            /// Creates a new `Case1Payload`.
                            ///
                            /// - Parameters:
                            ///   - additionalProperties: A container of undocumented properties.
                            public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                                self.additionalProperties = additionalProperties
                            }
                            public init(from decoder: any Decoder) throws {
                                additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                            }
                            public func encode(to encoder: any Encoder) throws {
                                try encoder.encodeAdditionalProperties(additionalProperties)
                            }
                        }
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/payload/case1`.
                        case case1(Operations.ReposCreateDeployment.Input.Body.JsonPayload.PayloadPayload.Case1Payload)
                        /// JSON payload with extra information about the deployment.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/payload/case2`.
                        case case2(Swift.String)
                        public init(from decoder: any Decoder) throws {
                            var errors: [any Error] = []
                            do {
                                self = .case1(try .init(from: decoder))
                                return
                            } catch {
                                errors.append(error)
                            }
                            do {
                                self = .case2(try decoder.decodeFromSingleValueContainer())
                                return
                            } catch {
                                errors.append(error)
                            }
                            throw Swift.DecodingError.failedToDecodeOneOfSchema(
                                type: Self.self,
                                codingPath: decoder.codingPath,
                                errors: errors
                            )
                        }
                        public func encode(to encoder: any Encoder) throws {
                            switch self {
                            case let .case1(value):
                                try value.encode(to: encoder)
                            case let .case2(value):
                                try encoder.encodeToSingleValueContainer(value)
                            }
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/payload`.
                    public var payload: Operations.ReposCreateDeployment.Input.Body.JsonPayload.PayloadPayload?
                    /// Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/environment`.
                    public var environment: Swift.String?
                    /// Short description of the deployment.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/description`.
                    public var description: Swift.String?
                    /// Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/transient_environment`.
                    public var transientEnvironment: Swift.Bool?
                    /// Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/json/production_environment`.
                    public var productionEnvironment: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - ref: The ref to deploy. This can be a branch, tag, or SHA.
                    ///   - task: Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).
                    ///   - autoMerge: Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.
                    ///   - requiredContexts: The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.
                    ///   - payload:
                    ///   - environment: Name for the target deployment environment (e.g., `production`, `staging`, `qa`).
                    ///   - description: Short description of the deployment.
                    ///   - transientEnvironment: Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`
                    ///   - productionEnvironment: Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.
                    public init(
                        ref: Swift.String,
                        task: Swift.String? = nil,
                        autoMerge: Swift.Bool? = nil,
                        requiredContexts: [Swift.String]? = nil,
                        payload: Operations.ReposCreateDeployment.Input.Body.JsonPayload.PayloadPayload? = nil,
                        environment: Swift.String? = nil,
                        description: Swift.String? = nil,
                        transientEnvironment: Swift.Bool? = nil,
                        productionEnvironment: Swift.Bool? = nil
                    ) {
                        self.ref = ref
                        self.task = task
                        self.autoMerge = autoMerge
                        self.requiredContexts = requiredContexts
                        self.payload = payload
                        self.environment = environment
                        self.description = description
                        self.transientEnvironment = transientEnvironment
                        self.productionEnvironment = productionEnvironment
                    }
                    public enum CodingKeys: String, CodingKey {
                        case ref
                        case task
                        case autoMerge = "auto_merge"
                        case requiredContexts = "required_contexts"
                        case payload
                        case environment
                        case description
                        case transientEnvironment = "transient_environment"
                        case productionEnvironment = "production_environment"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateDeployment.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateDeployment.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateDeployment.Input.Path,
                headers: Operations.ReposCreateDeployment.Input.Headers = .init(),
                body: Operations.ReposCreateDeployment.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.Deployment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Deployment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateDeployment.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateDeployment.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateDeployment.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateDeployment.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            public struct Accepted: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/responses/202/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/responses/202/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/responses/202/content/json/message`.
                        public var message: Swift.String?
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - message:
                        public init(message: Swift.String? = nil) {
                            self.message = message
                        }
                        public enum CodingKeys: String, CodingKey {
                            case message
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/POST/responses/202/content/application\/json`.
                    case json(Operations.ReposCreateDeployment.Output.Accepted.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposCreateDeployment.Output.Accepted.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateDeployment.Output.Accepted.Body
                /// Creates a new `Accepted`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateDeployment.Output.Accepted.Body) {
                    self.body = body
                }
            }
            /// Merged branch response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Operations.ReposCreateDeployment.Output.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Operations.ReposCreateDeployment.Output.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            public struct Conflict: Sendable, Hashable {
                /// Creates a new `Conflict`.
                public init() {}
            }
            /// Conflict when there is a merge conflict or the commit's status checks failed
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Operations.ReposCreateDeployment.Output.Conflict)
            /// Conflict when there is a merge conflict or the commit's status checks failed
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            public static var conflict: Self {
                .conflict(.init())
            }
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Operations.ReposCreateDeployment.Output.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/post(repos/create-deployment)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a deployment
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/get(repos/get-deployment)`.
    public enum ReposGetDeployment {
        public static let id: Swift.String = "repos/get-deployment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// deployment_id parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/GET/path/deployment_id`.
                public var deploymentId: Components.Parameters.DeploymentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - deploymentId: deployment_id parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    deploymentId: Components.Parameters.DeploymentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.deploymentId = deploymentId
                }
            }
            public var path: Operations.ReposGetDeployment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeployment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeployment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetDeployment.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetDeployment.Input.Path,
                headers: Operations.ReposGetDeployment.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Deployment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Deployment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetDeployment.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetDeployment.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/get(repos/get-deployment)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetDeployment.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetDeployment.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/get(repos/get-deployment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a deployment
    ///
    /// If the repository only has one deployment, you can delete the deployment regardless of its status. If the repository has more than one deployment, you can only delete inactive deployments. This ensures that repositories with multiple deployments will always have an active deployment.
    ///
    /// To set a deployment as inactive, you must:
    ///
    /// *   Create a new deployment that is active so that the system has a record of the current state, then delete the previously active deployment.
    /// *   Mark the active deployment as inactive by adding any non-successful deployment status.
    ///
    /// For more information, see "[Create a deployment](https://docs.github.com/rest/deployments/deployments/#create-a-deployment)" and "[Create a deployment status](https://docs.github.com/rest/deployments/statuses#create-a-deployment-status)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` or `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/deployments/{deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/delete(repos/delete-deployment)`.
    public enum ReposDeleteDeployment {
        public static let id: Swift.String = "repos/delete-deployment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// deployment_id parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/DELETE/path/deployment_id`.
                public var deploymentId: Components.Parameters.DeploymentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - deploymentId: deployment_id parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    deploymentId: Components.Parameters.DeploymentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.deploymentId = deploymentId
                }
            }
            public var path: Operations.ReposDeleteDeployment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteDeployment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteDeployment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteDeployment.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteDeployment.Input.Path,
                headers: Operations.ReposDeleteDeployment.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/delete(repos/delete-deployment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteDeployment.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/delete(repos/delete-deployment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteDeployment.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/delete(repos/delete-deployment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/delete(repos/delete-deployment)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailedSimple)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailedSimple {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List deployment statuses
    ///
    /// Users with pull access can view deployment statuses for a deployment:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/get(repos/list-deployment-statuses)`.
    public enum ReposListDeploymentStatuses {
        public static let id: Swift.String = "repos/list-deployment-statuses"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// deployment_id parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/path/deployment_id`.
                public var deploymentId: Components.Parameters.DeploymentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - deploymentId: deployment_id parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    deploymentId: Components.Parameters.DeploymentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.deploymentId = deploymentId
                }
            }
            public var path: Operations.ReposListDeploymentStatuses.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListDeploymentStatuses.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeploymentStatuses.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeploymentStatuses.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListDeploymentStatuses.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListDeploymentStatuses.Input.Path,
                query: Operations.ReposListDeploymentStatuses.Input.Query = .init(),
                headers: Operations.ReposListDeploymentStatuses.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListDeploymentStatuses.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.DeploymentStatus])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.DeploymentStatus] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListDeploymentStatuses.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListDeploymentStatuses.Output.Ok.Headers = .init(),
                    body: Operations.ReposListDeploymentStatuses.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/get(repos/list-deployment-statuses)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListDeploymentStatuses.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListDeploymentStatuses.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/get(repos/list-deployment-statuses)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a deployment status
    ///
    /// Users with `push` access can create deployment statuses for a given deployment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo_deployment` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/post(repos/create-deployment-status)`.
    public enum ReposCreateDeploymentStatus {
        public static let id: Swift.String = "repos/create-deployment-status"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// deployment_id parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/path/deployment_id`.
                public var deploymentId: Components.Parameters.DeploymentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - deploymentId: deployment_id parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    deploymentId: Components.Parameters.DeploymentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.deploymentId = deploymentId
                }
            }
            public var path: Operations.ReposCreateDeploymentStatus.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeploymentStatus.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeploymentStatus.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateDeploymentStatus.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/state`.
                    @frozen public enum StatePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case error = "error"
                        case failure = "failure"
                        case inactive = "inactive"
                        case inProgress = "in_progress"
                        case queued = "queued"
                        case pending = "pending"
                        case success = "success"
                    }
                    /// The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/state`.
                    public var state: Operations.ReposCreateDeploymentStatus.Input.Body.JsonPayload.StatePayload
                    /// The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.
                    ///
                    /// > [!NOTE]
                    /// > It's recommended to use the `log_url` parameter, which replaces `target_url`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/target_url`.
                    public var targetUrl: Swift.String?
                    /// The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/log_url`.
                    public var logUrl: Swift.String?
                    /// A short description of the status. The maximum description length is 140 characters.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/description`.
                    public var description: Swift.String?
                    /// Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/environment`.
                    public var environment: Swift.String?
                    /// Sets the URL for accessing your environment. Default: `""`
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/environment_url`.
                    public var environmentUrl: Swift.String?
                    /// Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/json/auto_inactive`.
                    public var autoInactive: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - state: The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.
                    ///   - targetUrl: The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment.
                    ///   - logUrl: The full URL of the deployment's output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`
                    ///   - description: A short description of the status. The maximum description length is 140 characters.
                    ///   - environment: Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`. If not defined, the environment of the previous status on the deployment will be used, if it exists. Otherwise, the environment of the deployment will be used.
                    ///   - environmentUrl: Sets the URL for accessing your environment. Default: `""`
                    ///   - autoInactive: Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`
                    public init(
                        state: Operations.ReposCreateDeploymentStatus.Input.Body.JsonPayload.StatePayload,
                        targetUrl: Swift.String? = nil,
                        logUrl: Swift.String? = nil,
                        description: Swift.String? = nil,
                        environment: Swift.String? = nil,
                        environmentUrl: Swift.String? = nil,
                        autoInactive: Swift.Bool? = nil
                    ) {
                        self.state = state
                        self.targetUrl = targetUrl
                        self.logUrl = logUrl
                        self.description = description
                        self.environment = environment
                        self.environmentUrl = environmentUrl
                        self.autoInactive = autoInactive
                    }
                    public enum CodingKeys: String, CodingKey {
                        case state
                        case targetUrl = "target_url"
                        case logUrl = "log_url"
                        case description
                        case environment
                        case environmentUrl = "environment_url"
                        case autoInactive = "auto_inactive"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateDeploymentStatus.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateDeploymentStatus.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateDeploymentStatus.Input.Path,
                headers: Operations.ReposCreateDeploymentStatus.Input.Headers = .init(),
                body: Operations.ReposCreateDeploymentStatus.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateDeploymentStatus.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.DeploymentStatus)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeploymentStatus {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateDeploymentStatus.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateDeploymentStatus.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateDeploymentStatus.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/post(repos/create-deployment-status)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateDeploymentStatus.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateDeploymentStatus.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/post(repos/create-deployment-status)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a deployment status
    ///
    /// Users with pull access can view a deployment status for a deployment:
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/get(repos/get-deployment-status)`.
    public enum ReposGetDeploymentStatus {
        public static let id: Swift.String = "repos/get-deployment-status"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// deployment_id parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/path/deployment_id`.
                public var deploymentId: Components.Parameters.DeploymentId
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/path/status_id`.
                public var statusId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - deploymentId: deployment_id parameter
                ///   - statusId:
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    deploymentId: Components.Parameters.DeploymentId,
                    statusId: Swift.Int
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.deploymentId = deploymentId
                    self.statusId = statusId
                }
            }
            public var path: Operations.ReposGetDeploymentStatus.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeploymentStatus.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeploymentStatus.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetDeploymentStatus.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetDeploymentStatus.Input.Path,
                headers: Operations.ReposGetDeploymentStatus.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.DeploymentStatus)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeploymentStatus {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetDeploymentStatus.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetDeploymentStatus.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/get(repos/get-deployment-status)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetDeploymentStatus.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetDeploymentStatus.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}/get(repos/get-deployment-status)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a repository dispatch event
    ///
    /// You can use this endpoint to trigger a webhook event called `repository_dispatch` when you want activity that happens outside of GitHub to trigger a GitHub Actions workflow or GitHub App webhook. You must configure your GitHub Actions workflow or GitHub App to run when the `repository_dispatch` event occurs. For an example `repository_dispatch` webhook payload, see "[RepositoryDispatchEvent](https://docs.github.com/webhooks/event-payloads/#repository_dispatch)."
    ///
    /// The `client_payload` parameter is available for any extra information that your workflow might need. This parameter is a JSON payload that will be passed on when the webhook event is dispatched. For example, the `client_payload` can include a message that a user would like to send using a GitHub Actions workflow. Or the `client_payload` can be used as a test to debug your workflow.
    ///
    /// This input example shows how you can use the `client_payload` as a test to debug your workflow.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/dispatches`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/dispatches/post(repos/create-dispatch-event)`.
    public enum ReposCreateDispatchEvent {
        public static let id: Swift.String = "repos/create-dispatch-event"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateDispatchEvent.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDispatchEvent.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDispatchEvent.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateDispatchEvent.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// A custom webhook event name. Must be 100 characters or fewer.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/requestBody/json/event_type`.
                    public var eventType: Swift.String
                    /// JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/requestBody/json/client_payload`.
                    public struct ClientPayloadPayload: Codable, Hashable, Sendable {
                        /// A container of undocumented properties.
                        public var additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer
                        /// Creates a new `ClientPayloadPayload`.
                        ///
                        /// - Parameters:
                        ///   - additionalProperties: A container of undocumented properties.
                        public init(additionalProperties: OpenAPIRuntime.OpenAPIObjectContainer = .init()) {
                            self.additionalProperties = additionalProperties
                        }
                        public init(from decoder: any Decoder) throws {
                            additionalProperties = try decoder.decodeAdditionalProperties(knownKeys: [])
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try encoder.encodeAdditionalProperties(additionalProperties)
                        }
                    }
                    /// JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/requestBody/json/client_payload`.
                    public var clientPayload: Operations.ReposCreateDispatchEvent.Input.Body.JsonPayload.ClientPayloadPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - eventType: A custom webhook event name. Must be 100 characters or fewer.
                    ///   - clientPayload: JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10. The total size of the JSON payload must be less than 64KB.
                    public init(
                        eventType: Swift.String,
                        clientPayload: Operations.ReposCreateDispatchEvent.Input.Body.JsonPayload.ClientPayloadPayload? = nil
                    ) {
                        self.eventType = eventType
                        self.clientPayload = clientPayload
                    }
                    public enum CodingKeys: String, CodingKey {
                        case eventType = "event_type"
                        case clientPayload = "client_payload"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/dispatches/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateDispatchEvent.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateDispatchEvent.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateDispatchEvent.Input.Path,
                headers: Operations.ReposCreateDispatchEvent.Input.Headers = .init(),
                body: Operations.ReposCreateDispatchEvent.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/dispatches/post(repos/create-dispatch-event)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposCreateDispatchEvent.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/dispatches/post(repos/create-dispatch-event)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposCreateDispatchEvent.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/dispatches/post(repos/create-dispatch-event)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/dispatches/post(repos/create-dispatch-event)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List environments
    ///
    /// Lists the environments for a repository.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/get(repos/get-all-environments)`.
    public enum ReposGetAllEnvironments {
        public static let id: Swift.String = "repos/get-all-environments"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetAllEnvironments.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposGetAllEnvironments.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllEnvironments.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllEnvironments.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAllEnvironments.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetAllEnvironments.Input.Path,
                query: Operations.ReposGetAllEnvironments.Input.Query = .init(),
                headers: Operations.ReposGetAllEnvironments.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/responses/200/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// The number of environments in this repository
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/responses/200/content/json/total_count`.
                        public var totalCount: Swift.Int?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/responses/200/content/json/environments`.
                        public var environments: [Components.Schemas.Environment]?
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - totalCount: The number of environments in this repository
                        ///   - environments:
                        public init(
                            totalCount: Swift.Int? = nil,
                            environments: [Components.Schemas.Environment]? = nil
                        ) {
                            self.totalCount = totalCount
                            self.environments = environments
                        }
                        public enum CodingKeys: String, CodingKey {
                            case totalCount = "total_count"
                            case environments
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/GET/responses/200/content/application\/json`.
                    case json(Operations.ReposGetAllEnvironments.Output.Ok.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposGetAllEnvironments.Output.Ok.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAllEnvironments.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAllEnvironments.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/get(repos/get-all-environments)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAllEnvironments.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAllEnvironments.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get an environment
    ///
    /// > [!NOTE]
    /// > To get information about name patterns that branches must match in order to deploy to this environment, see "[Get a deployment branch policy](/rest/deployments/branch-policies#get-a-deployment-branch-policy)."
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/get(repos/get-environment)`.
    public enum ReposGetEnvironment {
        public static let id: Swift.String = "repos/get-environment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/GET/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                }
            }
            public var path: Operations.ReposGetEnvironment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetEnvironment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetEnvironment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetEnvironment.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetEnvironment.Input.Path,
                headers: Operations.ReposGetEnvironment.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Environment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Environment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetEnvironment.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetEnvironment.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/get(repos/get-environment)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetEnvironment.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetEnvironment.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create or update an environment
    ///
    /// Create or update an environment with protection rules, such as required reviewers. For more information about environment protection rules, see "[Environments](/actions/reference/environments#environment-protection-rules)."
    ///
    /// > [!NOTE]
    /// > To create or update name patterns that branches must match in order to deploy to this environment, see "[Deployment branch policies](/rest/deployments/branch-policies)."
    ///
    /// > [!NOTE]
    /// > To create or update secrets for an environment, see "[GitHub Actions secrets](/rest/actions/secrets)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/put(repos/create-or-update-environment)`.
    public enum ReposCreateOrUpdateEnvironment {
        public static let id: Swift.String = "repos/create-or-update-environment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                }
            }
            public var path: Operations.ReposCreateOrUpdateEnvironment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrUpdateEnvironment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrUpdateEnvironment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateOrUpdateEnvironment.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/wait_timer`.
                    public var waitTimer: Components.Schemas.WaitTimer?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/prevent_self_review`.
                    public var preventSelfReview: Components.Schemas.PreventSelfReview?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/ReviewersPayload`.
                    public struct ReviewersPayloadPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/ReviewersPayload/type`.
                        public var _type: Components.Schemas.DeploymentReviewerType?
                        /// The id of the user or team who can review the deployment
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/ReviewersPayload/id`.
                        public var id: Swift.Int?
                        /// Creates a new `ReviewersPayloadPayload`.
                        ///
                        /// - Parameters:
                        ///   - _type:
                        ///   - id: The id of the user or team who can review the deployment
                        public init(
                            _type: Components.Schemas.DeploymentReviewerType? = nil,
                            id: Swift.Int? = nil
                        ) {
                            self._type = _type
                            self.id = id
                        }
                        public enum CodingKeys: String, CodingKey {
                            case _type = "type"
                            case id
                        }
                    }
                    /// The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/reviewers`.
                    public typealias ReviewersPayload = [Operations.ReposCreateOrUpdateEnvironment.Input.Body.JsonPayload.ReviewersPayloadPayload]
                    /// The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/reviewers`.
                    public var reviewers: Operations.ReposCreateOrUpdateEnvironment.Input.Body.JsonPayload.ReviewersPayload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/json/deployment_branch_policy`.
                    public var deploymentBranchPolicy: Components.Schemas.DeploymentBranchPolicySettings?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - waitTimer:
                    ///   - preventSelfReview:
                    ///   - reviewers: The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.
                    ///   - deploymentBranchPolicy:
                    public init(
                        waitTimer: Components.Schemas.WaitTimer? = nil,
                        preventSelfReview: Components.Schemas.PreventSelfReview? = nil,
                        reviewers: Operations.ReposCreateOrUpdateEnvironment.Input.Body.JsonPayload.ReviewersPayload? = nil,
                        deploymentBranchPolicy: Components.Schemas.DeploymentBranchPolicySettings? = nil
                    ) {
                        self.waitTimer = waitTimer
                        self.preventSelfReview = preventSelfReview
                        self.reviewers = reviewers
                        self.deploymentBranchPolicy = deploymentBranchPolicy
                    }
                    public enum CodingKeys: String, CodingKey {
                        case waitTimer = "wait_timer"
                        case preventSelfReview = "prevent_self_review"
                        case reviewers
                        case deploymentBranchPolicy = "deployment_branch_policy"
                    }
                    public init(from decoder: any Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)
                        self.waitTimer = try container.decodeIfPresent(
                            Components.Schemas.WaitTimer.self,
                            forKey: .waitTimer
                        )
                        self.preventSelfReview = try container.decodeIfPresent(
                            Components.Schemas.PreventSelfReview.self,
                            forKey: .preventSelfReview
                        )
                        self.reviewers = try container.decodeIfPresent(
                            Operations.ReposCreateOrUpdateEnvironment.Input.Body.JsonPayload.ReviewersPayload.self,
                            forKey: .reviewers
                        )
                        self.deploymentBranchPolicy = try container.decodeIfPresent(
                            Components.Schemas.DeploymentBranchPolicySettings.self,
                            forKey: .deploymentBranchPolicy
                        )
                        try decoder.ensureNoAdditionalProperties(knownKeys: [
                            "wait_timer",
                            "prevent_self_review",
                            "reviewers",
                            "deployment_branch_policy"
                        ])
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposCreateOrUpdateEnvironment.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateOrUpdateEnvironment.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateOrUpdateEnvironment.Input.Path,
                headers: Operations.ReposCreateOrUpdateEnvironment.Input.Headers = .init(),
                body: Operations.ReposCreateOrUpdateEnvironment.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/responses/200/content/application\/json`.
                    case json(Components.Schemas.Environment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Environment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateOrUpdateEnvironment.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateOrUpdateEnvironment.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/put(repos/create-or-update-environment)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCreateOrUpdateEnvironment.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCreateOrUpdateEnvironment.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct UnprocessableContent: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/responses/422/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/PUT/responses/422/content/application\/json`.
                    case json(Components.Schemas.BasicError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BasicError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateOrUpdateEnvironment.Output.UnprocessableContent.Body
                /// Creates a new `UnprocessableContent`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateOrUpdateEnvironment.Output.UnprocessableContent.Body) {
                    self.body = body
                }
            }
            /// Validation error when the environment name is invalid or when `protected_branches` and `custom_branch_policies` in `deployment_branch_policy` are set to the same value
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/put(repos/create-or-update-environment)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Operations.ReposCreateOrUpdateEnvironment.Output.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Operations.ReposCreateOrUpdateEnvironment.Output.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete an environment
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/delete(repos/delete-an-environment)`.
    public enum ReposDeleteAnEnvironment {
        public static let id: Swift.String = "repos/delete-an-environment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/DELETE/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                }
            }
            public var path: Operations.ReposDeleteAnEnvironment.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDeleteAnEnvironment.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Default response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/delete(repos/delete-an-environment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteAnEnvironment.Output.NoContent)
            /// Default response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/delete(repos/delete-an-environment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteAnEnvironment.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// List deployment branch policies
    ///
    /// Lists the deployment branch policies for an environment.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/get(repos/list-deployment-branch-policies)`.
    public enum ReposListDeploymentBranchPolicies {
        public static let id: Swift.String = "repos/list-deployment-branch-policies"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                }
            }
            public var path: Operations.ReposListDeploymentBranchPolicies.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListDeploymentBranchPolicies.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeploymentBranchPolicies.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeploymentBranchPolicies.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListDeploymentBranchPolicies.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListDeploymentBranchPolicies.Input.Path,
                query: Operations.ReposListDeploymentBranchPolicies.Input.Query = .init(),
                headers: Operations.ReposListDeploymentBranchPolicies.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/responses/200/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// The number of deployment branch policies for the environment.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/responses/200/content/json/total_count`.
                        public var totalCount: Swift.Int
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/responses/200/content/json/branch_policies`.
                        public var branchPolicies: [Components.Schemas.DeploymentBranchPolicy]
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - totalCount: The number of deployment branch policies for the environment.
                        ///   - branchPolicies:
                        public init(
                            totalCount: Swift.Int,
                            branchPolicies: [Components.Schemas.DeploymentBranchPolicy]
                        ) {
                            self.totalCount = totalCount
                            self.branchPolicies = branchPolicies
                        }
                        public enum CodingKeys: String, CodingKey {
                            case totalCount = "total_count"
                            case branchPolicies = "branch_policies"
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/GET/responses/200/content/application\/json`.
                    case json(Operations.ReposListDeploymentBranchPolicies.Output.Ok.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposListDeploymentBranchPolicies.Output.Ok.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListDeploymentBranchPolicies.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListDeploymentBranchPolicies.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/get(repos/list-deployment-branch-policies)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListDeploymentBranchPolicies.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListDeploymentBranchPolicies.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a deployment branch policy
    ///
    /// Creates a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)`.
    public enum ReposCreateDeploymentBranchPolicy {
        public static let id: Swift.String = "repos/create-deployment-branch-policy"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                }
            }
            public var path: Operations.ReposCreateDeploymentBranchPolicy.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeploymentBranchPolicy.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeploymentBranchPolicy.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateDeploymentBranchPolicy.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/requestBody/content/application\/json`.
                case json(Components.Schemas.DeploymentBranchPolicyNamePatternWithType)
            }
            public var body: Operations.ReposCreateDeploymentBranchPolicy.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateDeploymentBranchPolicy.Input.Path,
                headers: Operations.ReposCreateDeploymentBranchPolicy.Input.Headers = .init(),
                body: Operations.ReposCreateDeploymentBranchPolicy.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.DeploymentBranchPolicy)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeploymentBranchPolicy {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateDeploymentBranchPolicy.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateDeploymentBranchPolicy.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCreateDeploymentBranchPolicy.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCreateDeploymentBranchPolicy.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// Creates a new `NotFound`.
                public init() {}
            }
            /// Not Found or `deployment_branch_policy.custom_branch_policies` property for the environment is set to false
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposCreateDeploymentBranchPolicy.Output.NotFound)
            /// Not Found or `deployment_branch_policy.custom_branch_policies` property for the environment is set to false
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            public static var notFound: Self {
                .notFound(.init())
            }
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposCreateDeploymentBranchPolicy.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            public struct SeeOther: Sendable, Hashable {
                /// Creates a new `SeeOther`.
                public init() {}
            }
            /// Response if the same branch name pattern already exists
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)/responses/303`.
            ///
            /// HTTP response code: `303 seeOther`.
            case seeOther(Operations.ReposCreateDeploymentBranchPolicy.Output.SeeOther)
            /// Response if the same branch name pattern already exists
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/post(repos/create-deployment-branch-policy)/responses/303`.
            ///
            /// HTTP response code: `303 seeOther`.
            public static var seeOther: Self {
                .seeOther(.init())
            }
            /// The associated value of the enum case if `self` is `.seeOther`.
            ///
            /// - Throws: An error if `self` is not `.seeOther`.
            /// - SeeAlso: `.seeOther`.
            public var seeOther: Operations.ReposCreateDeploymentBranchPolicy.Output.SeeOther {
                get throws {
                    switch self {
                    case let .seeOther(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "seeOther",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a deployment branch policy
    ///
    /// Gets a deployment branch or tag policy for an environment.
    ///
    /// Anyone with read access to the repository can use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/get(repos/get-deployment-branch-policy)`.
    public enum ReposGetDeploymentBranchPolicy {
        public static let id: Swift.String = "repos/get-deployment-branch-policy"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The unique identifier of the branch policy.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/path/branch_policy_id`.
                public var branchPolicyId: Components.Parameters.BranchPolicyId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - branchPolicyId: The unique identifier of the branch policy.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName,
                    branchPolicyId: Components.Parameters.BranchPolicyId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                    self.branchPolicyId = branchPolicyId
                }
            }
            public var path: Operations.ReposGetDeploymentBranchPolicy.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeploymentBranchPolicy.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeploymentBranchPolicy.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetDeploymentBranchPolicy.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetDeploymentBranchPolicy.Input.Path,
                headers: Operations.ReposGetDeploymentBranchPolicy.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.DeploymentBranchPolicy)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeploymentBranchPolicy {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetDeploymentBranchPolicy.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetDeploymentBranchPolicy.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/get(repos/get-deployment-branch-policy)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetDeploymentBranchPolicy.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetDeploymentBranchPolicy.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a deployment branch policy
    ///
    /// Updates a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/put(repos/update-deployment-branch-policy)`.
    public enum ReposUpdateDeploymentBranchPolicy {
        public static let id: Swift.String = "repos/update-deployment-branch-policy"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The unique identifier of the branch policy.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/path/branch_policy_id`.
                public var branchPolicyId: Components.Parameters.BranchPolicyId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - branchPolicyId: The unique identifier of the branch policy.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName,
                    branchPolicyId: Components.Parameters.BranchPolicyId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                    self.branchPolicyId = branchPolicyId
                }
            }
            public var path: Operations.ReposUpdateDeploymentBranchPolicy.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateDeploymentBranchPolicy.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateDeploymentBranchPolicy.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateDeploymentBranchPolicy.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/requestBody/content/application\/json`.
                case json(Components.Schemas.DeploymentBranchPolicyNamePattern)
            }
            public var body: Operations.ReposUpdateDeploymentBranchPolicy.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateDeploymentBranchPolicy.Input.Path,
                headers: Operations.ReposUpdateDeploymentBranchPolicy.Input.Headers = .init(),
                body: Operations.ReposUpdateDeploymentBranchPolicy.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/PUT/responses/200/content/application\/json`.
                    case json(Components.Schemas.DeploymentBranchPolicy)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeploymentBranchPolicy {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateDeploymentBranchPolicy.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateDeploymentBranchPolicy.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/put(repos/update-deployment-branch-policy)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateDeploymentBranchPolicy.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateDeploymentBranchPolicy.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a deployment branch policy
    ///
    /// Deletes a deployment branch or tag policy for an environment.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/delete(repos/delete-deployment-branch-policy)`.
    public enum ReposDeleteDeploymentBranchPolicy {
        public static let id: Swift.String = "repos/delete-deployment-branch-policy"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/DELETE/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The unique identifier of the branch policy.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/DELETE/path/branch_policy_id`.
                public var branchPolicyId: Components.Parameters.BranchPolicyId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - branchPolicyId: The unique identifier of the branch policy.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName,
                    branchPolicyId: Components.Parameters.BranchPolicyId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                    self.branchPolicyId = branchPolicyId
                }
            }
            public var path: Operations.ReposDeleteDeploymentBranchPolicy.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDeleteDeploymentBranchPolicy.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/delete(repos/delete-deployment-branch-policy)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteDeploymentBranchPolicy.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}/delete(repos/delete-deployment-branch-policy)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteDeploymentBranchPolicy.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Get all deployment protection rules for an environment
    ///
    /// Gets all custom deployment protection rules that are enabled for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/get(repos/get-all-deployment-protection-rules)`.
    public enum ReposGetAllDeploymentProtectionRules {
        public static let id: Swift.String = "repos/get-all-deployment-protection-rules"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                public init(
                    environmentName: Components.Parameters.EnvironmentName,
                    repo: Components.Parameters.Repo,
                    owner: Components.Parameters.Owner
                ) {
                    self.environmentName = environmentName
                    self.repo = repo
                    self.owner = owner
                }
            }
            public var path: Operations.ReposGetAllDeploymentProtectionRules.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllDeploymentProtectionRules.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllDeploymentProtectionRules.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAllDeploymentProtectionRules.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetAllDeploymentProtectionRules.Input.Path,
                headers: Operations.ReposGetAllDeploymentProtectionRules.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/responses/200/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// The number of enabled custom deployment protection rules for this environment
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/responses/200/content/json/total_count`.
                        public var totalCount: Swift.Int?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/responses/200/content/json/custom_deployment_protection_rules`.
                        public var customDeploymentProtectionRules: [Components.Schemas.DeploymentProtectionRule]?
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - totalCount: The number of enabled custom deployment protection rules for this environment
                        ///   - customDeploymentProtectionRules:
                        public init(
                            totalCount: Swift.Int? = nil,
                            customDeploymentProtectionRules: [Components.Schemas.DeploymentProtectionRule]? = nil
                        ) {
                            self.totalCount = totalCount
                            self.customDeploymentProtectionRules = customDeploymentProtectionRules
                        }
                        public enum CodingKeys: String, CodingKey {
                            case totalCount = "total_count"
                            case customDeploymentProtectionRules = "custom_deployment_protection_rules"
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/GET/responses/200/content/application\/json`.
                    case json(Operations.ReposGetAllDeploymentProtectionRules.Output.Ok.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposGetAllDeploymentProtectionRules.Output.Ok.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAllDeploymentProtectionRules.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAllDeploymentProtectionRules.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// List of deployment protection rules
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/get(repos/get-all-deployment-protection-rules)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAllDeploymentProtectionRules.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAllDeploymentProtectionRules.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a custom deployment protection rule on an environment
    ///
    /// Enable a custom deployment protection rule for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// For more information about the app that is providing this custom deployment rule, see the [documentation for the `GET /apps/{app_slug}` endpoint](https://docs.github.com/rest/apps/apps#get-an-app), as well as the [guide to creating custom deployment protection rules](https://docs.github.com/actions/managing-workflow-runs-and-deployments/managing-deployments/creating-custom-deployment-protection-rules).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/post(repos/create-deployment-protection-rule)`.
    public enum ReposCreateDeploymentProtectionRule {
        public static let id: Swift.String = "repos/create-deployment-protection-rule"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                public init(
                    environmentName: Components.Parameters.EnvironmentName,
                    repo: Components.Parameters.Repo,
                    owner: Components.Parameters.Owner
                ) {
                    self.environmentName = environmentName
                    self.repo = repo
                    self.owner = owner
                }
            }
            public var path: Operations.ReposCreateDeploymentProtectionRule.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeploymentProtectionRule.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeploymentProtectionRule.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateDeploymentProtectionRule.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The ID of the custom app that will be enabled on the environment.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/requestBody/json/integration_id`.
                    public var integrationId: Swift.Int?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - integrationId: The ID of the custom app that will be enabled on the environment.
                    public init(integrationId: Swift.Int? = nil) {
                        self.integrationId = integrationId
                    }
                    public enum CodingKeys: String, CodingKey {
                        case integrationId = "integration_id"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateDeploymentProtectionRule.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateDeploymentProtectionRule.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateDeploymentProtectionRule.Input.Path,
                headers: Operations.ReposCreateDeploymentProtectionRule.Input.Headers = .init(),
                body: Operations.ReposCreateDeploymentProtectionRule.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.DeploymentProtectionRule)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeploymentProtectionRule {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateDeploymentProtectionRule.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateDeploymentProtectionRule.Output.Created.Body) {
                    self.body = body
                }
            }
            /// The enabled custom deployment protection rule
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/post(repos/create-deployment-protection-rule)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateDeploymentProtectionRule.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateDeploymentProtectionRule.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List custom deployment rule integrations available for an environment
    ///
    /// Gets all custom deployment protection rule integrations that are available for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see "[GET an app](https://docs.github.com/rest/apps/apps#get-an-app)".
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/get(repos/list-custom-deployment-rule-integrations)`.
    public enum ReposListCustomDeploymentRuleIntegrations {
        public static let id: Swift.String = "repos/list-custom-deployment-rule-integrations"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                public init(
                    environmentName: Components.Parameters.EnvironmentName,
                    repo: Components.Parameters.Repo,
                    owner: Components.Parameters.Owner
                ) {
                    self.environmentName = environmentName
                    self.repo = repo
                    self.owner = owner
                }
            }
            public var path: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    page: Components.Parameters.Page? = nil,
                    perPage: Components.Parameters.PerPage? = nil
                ) {
                    self.page = page
                    self.perPage = perPage
                }
            }
            public var query: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCustomDeploymentRuleIntegrations.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListCustomDeploymentRuleIntegrations.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Path,
                query: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Query = .init(),
                headers: Operations.ReposListCustomDeploymentRuleIntegrations.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/responses/200/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// The total number of custom deployment protection rule integrations available for this environment.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/responses/200/content/json/total_count`.
                        public var totalCount: Swift.Int?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/responses/200/content/json/available_custom_deployment_protection_rule_integrations`.
                        public var availableCustomDeploymentProtectionRuleIntegrations: [Components.Schemas.CustomDeploymentRuleApp]?
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - totalCount: The total number of custom deployment protection rule integrations available for this environment.
                        ///   - availableCustomDeploymentProtectionRuleIntegrations:
                        public init(
                            totalCount: Swift.Int? = nil,
                            availableCustomDeploymentProtectionRuleIntegrations: [Components.Schemas.CustomDeploymentRuleApp]? = nil
                        ) {
                            self.totalCount = totalCount
                            self.availableCustomDeploymentProtectionRuleIntegrations = availableCustomDeploymentProtectionRuleIntegrations
                        }
                        public enum CodingKeys: String, CodingKey {
                            case totalCount = "total_count"
                            case availableCustomDeploymentProtectionRuleIntegrations = "available_custom_deployment_protection_rule_integrations"
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/GET/responses/200/content/application\/json`.
                    case json(Operations.ReposListCustomDeploymentRuleIntegrations.Output.Ok.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposListCustomDeploymentRuleIntegrations.Output.Ok.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListCustomDeploymentRuleIntegrations.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListCustomDeploymentRuleIntegrations.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// A list of custom deployment rule integrations available for this environment.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps/get(repos/list-custom-deployment-rule-integrations)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListCustomDeploymentRuleIntegrations.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListCustomDeploymentRuleIntegrations.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a custom deployment protection rule
    ///
    /// Gets an enabled custom deployment protection rule for an environment. Anyone with read access to the repository can use this endpoint. For more information about environments, see "[Using environments for deployment](https://docs.github.com/actions/deployment/targeting-different-environments/using-environments-for-deployment)."
    ///
    /// For more information about the app that is providing this custom deployment rule, see [`GET /apps/{app_slug}`](https://docs.github.com/rest/apps/apps#get-an-app).
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/get(repos/get-custom-deployment-protection-rule)`.
    public enum ReposGetCustomDeploymentProtectionRule {
        public static let id: Swift.String = "repos/get-custom-deployment-protection-rule"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The unique identifier of the protection rule.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/path/protection_rule_id`.
                public var protectionRuleId: Components.Parameters.ProtectionRuleId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - protectionRuleId: The unique identifier of the protection rule.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    environmentName: Components.Parameters.EnvironmentName,
                    protectionRuleId: Components.Parameters.ProtectionRuleId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.environmentName = environmentName
                    self.protectionRuleId = protectionRuleId
                }
            }
            public var path: Operations.ReposGetCustomDeploymentProtectionRule.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCustomDeploymentProtectionRule.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCustomDeploymentProtectionRule.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCustomDeploymentProtectionRule.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCustomDeploymentProtectionRule.Input.Path,
                headers: Operations.ReposGetCustomDeploymentProtectionRule.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.DeploymentProtectionRule)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeploymentProtectionRule {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCustomDeploymentProtectionRule.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCustomDeploymentProtectionRule.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/get(repos/get-custom-deployment-protection-rule)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCustomDeploymentProtectionRule.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCustomDeploymentProtectionRule.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Disable a custom protection rule for an environment
    ///
    /// Disables a custom deployment protection rule for an environment.
    ///
    /// The authenticated user must have admin or owner permissions to the repository to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/delete(repos/disable-deployment-protection-rule)`.
    public enum ReposDisableDeploymentProtectionRule {
        public static let id: Swift.String = "repos/disable-deployment-protection-rule"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/DELETE/path/environment_name`.
                public var environmentName: Components.Parameters.EnvironmentName
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The unique identifier of the protection rule.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/DELETE/path/protection_rule_id`.
                public var protectionRuleId: Components.Parameters.ProtectionRuleId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - environmentName: The name of the environment. The name must be URL encoded. For example, any slashes in the name must be replaced with `%2F`.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - protectionRuleId: The unique identifier of the protection rule.
                public init(
                    environmentName: Components.Parameters.EnvironmentName,
                    repo: Components.Parameters.Repo,
                    owner: Components.Parameters.Owner,
                    protectionRuleId: Components.Parameters.ProtectionRuleId
                ) {
                    self.environmentName = environmentName
                    self.repo = repo
                    self.owner = owner
                    self.protectionRuleId = protectionRuleId
                }
            }
            public var path: Operations.ReposDisableDeploymentProtectionRule.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDisableDeploymentProtectionRule.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/delete(repos/disable-deployment-protection-rule)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDisableDeploymentProtectionRule.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}/delete(repos/disable-deployment-protection-rule)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDisableDeploymentProtectionRule.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// List forks
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/forks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/get(repos/list-forks)`.
    public enum ReposListForks {
        public static let id: Swift.String = "repos/list-forks"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListForks.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/query/sort`.
                @frozen public enum SortPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case newest = "newest"
                    case oldest = "oldest"
                    case stargazers = "stargazers"
                    case watchers = "watchers"
                }
                /// The sort order. `stargazers` will sort by star count.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/query/sort`.
                public var sort: Operations.ReposListForks.Input.Query.SortPayload?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - sort: The sort order. `stargazers` will sort by star count.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    sort: Operations.ReposListForks.Input.Query.SortPayload? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.sort = sort
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListForks.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForks.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForks.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListForks.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListForks.Input.Path,
                query: Operations.ReposListForks.Input.Query = .init(),
                headers: Operations.ReposListForks.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListForks.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.MinimalRepository])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.MinimalRepository] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListForks.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListForks.Output.Ok.Headers = .init(),
                    body: Operations.ReposListForks.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/get(repos/list-forks)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListForks.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListForks.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/get(repos/list-forks)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Create a fork
    ///
    /// Create a fork for the authenticated user.
    ///
    /// > [!NOTE]
    /// > Forking a Repository happens asynchronously. You may have to wait a short period of time before you can access the git objects. If this takes longer than 5 minutes, be sure to contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
    ///
    /// > [!NOTE]
    /// > Although this endpoint works with GitHub Apps, the GitHub App must be installed on the destination account with access to all repositories and on the source account with access to the source repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/forks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)`.
    public enum ReposCreateFork {
        public static let id: Swift.String = "repos/create-fork"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateFork.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateFork.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateFork.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateFork.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Optional parameter to specify the organization name if forking into an organization.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/requestBody/json/organization`.
                    public var organization: Swift.String?
                    /// When forking from an existing repository, a new name for the fork.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/requestBody/json/name`.
                    public var name: Swift.String?
                    /// When forking from an existing repository, fork with only the default branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/requestBody/json/default_branch_only`.
                    public var defaultBranchOnly: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - organization: Optional parameter to specify the organization name if forking into an organization.
                    ///   - name: When forking from an existing repository, a new name for the fork.
                    ///   - defaultBranchOnly: When forking from an existing repository, fork with only the default branch.
                    public init(
                        organization: Swift.String? = nil,
                        name: Swift.String? = nil,
                        defaultBranchOnly: Swift.Bool? = nil
                    ) {
                        self.organization = organization
                        self.name = name
                        self.defaultBranchOnly = defaultBranchOnly
                    }
                    public enum CodingKeys: String, CodingKey {
                        case organization
                        case name
                        case defaultBranchOnly = "default_branch_only"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateFork.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateFork.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateFork.Input.Path,
                headers: Operations.ReposCreateFork.Input.Headers = .init(),
                body: Operations.ReposCreateFork.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Accepted: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/responses/202/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/forks/POST/responses/202/content/application\/json`.
                    case json(Components.Schemas.FullRepository)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FullRepository {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateFork.Output.Accepted.Body
                /// Creates a new `Accepted`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateFork.Output.Accepted.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Operations.ReposCreateFork.Output.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Operations.ReposCreateFork.Output.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/forks/post(repos/create-fork)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// List repository webhooks
    ///
    /// Lists webhooks for a repository. `last response` may return null if there have not been any deliveries within 30 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/get(repos/list-webhooks)`.
    public enum ReposListWebhooks {
        public static let id: Swift.String = "repos/list-webhooks"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListWebhooks.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListWebhooks.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListWebhooks.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListWebhooks.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListWebhooks.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListWebhooks.Input.Path,
                query: Operations.ReposListWebhooks.Input.Query = .init(),
                headers: Operations.ReposListWebhooks.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListWebhooks.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Hook])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Hook] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListWebhooks.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListWebhooks.Output.Ok.Headers = .init(),
                    body: Operations.ReposListWebhooks.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/get(repos/list-webhooks)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListWebhooks.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListWebhooks.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/get(repos/list-webhooks)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a repository webhook
    ///
    /// Repositories can have multiple webhooks installed. Each webhook should have a unique `config`. Multiple webhooks can
    /// share the same `config` as long as those webhooks do not have any `events` that overlap.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/post(repos/create-webhook)`.
    public enum ReposCreateWebhook {
        public static let id: Swift.String = "repos/create-webhook"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateWebhook.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateWebhook.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateWebhook.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateWebhook.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/name`.
                    public var name: Swift.String?
                    /// Key/value pairs to provide settings for this webhook.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/config`.
                    public struct ConfigPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/config/url`.
                        public var url: Components.Schemas.WebhookConfigUrl?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/config/content_type`.
                        public var contentType: Components.Schemas.WebhookConfigContentType?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/config/secret`.
                        public var secret: Components.Schemas.WebhookConfigSecret?
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/config/insecure_ssl`.
                        public var insecureSsl: Components.Schemas.WebhookConfigInsecureSsl?
                        /// Creates a new `ConfigPayload`.
                        ///
                        /// - Parameters:
                        ///   - url:
                        ///   - contentType:
                        ///   - secret:
                        ///   - insecureSsl:
                        public init(
                            url: Components.Schemas.WebhookConfigUrl? = nil,
                            contentType: Components.Schemas.WebhookConfigContentType? = nil,
                            secret: Components.Schemas.WebhookConfigSecret? = nil,
                            insecureSsl: Components.Schemas.WebhookConfigInsecureSsl? = nil
                        ) {
                            self.url = url
                            self.contentType = contentType
                            self.secret = secret
                            self.insecureSsl = insecureSsl
                        }
                        public enum CodingKeys: String, CodingKey {
                            case url
                            case contentType = "content_type"
                            case secret
                            case insecureSsl = "insecure_ssl"
                        }
                    }
                    /// Key/value pairs to provide settings for this webhook.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/config`.
                    public var config: Operations.ReposCreateWebhook.Input.Body.JsonPayload.ConfigPayload?
                    /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/events`.
                    public var events: [Swift.String]?
                    /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/json/active`.
                    public var active: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.
                    ///   - config: Key/value pairs to provide settings for this webhook.
                    ///   - events: Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.
                    ///   - active: Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
                    public init(
                        name: Swift.String? = nil,
                        config: Operations.ReposCreateWebhook.Input.Body.JsonPayload.ConfigPayload? = nil,
                        events: [Swift.String]? = nil,
                        active: Swift.Bool? = nil
                    ) {
                        self.name = name
                        self.config = config
                        self.events = events
                        self.active = active
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case config
                        case events
                        case active
                    }
                    public init(from decoder: any Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)
                        self.name = try container.decodeIfPresent(
                            Swift.String.self,
                            forKey: .name
                        )
                        self.config = try container.decodeIfPresent(
                            Operations.ReposCreateWebhook.Input.Body.JsonPayload.ConfigPayload.self,
                            forKey: .config
                        )
                        self.events = try container.decodeIfPresent(
                            [Swift.String].self,
                            forKey: .events
                        )
                        self.active = try container.decodeIfPresent(
                            Swift.Bool.self,
                            forKey: .active
                        )
                        try decoder.ensureNoAdditionalProperties(knownKeys: [
                            "name",
                            "config",
                            "events",
                            "active"
                        ])
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateWebhook.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateWebhook.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateWebhook.Input.Path,
                headers: Operations.ReposCreateWebhook.Input.Headers = .init(),
                body: Operations.ReposCreateWebhook.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateWebhook.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.Hook)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Hook {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateWebhook.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateWebhook.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateWebhook.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/post(repos/create-webhook)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateWebhook.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateWebhook.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/post(repos/create-webhook)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/post(repos/create-webhook)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/post(repos/create-webhook)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a repository webhook
    ///
    /// Returns a webhook configured in a repository. To get only the webhook `config` properties, see "[Get a webhook configuration for a repository](/rest/webhooks/repo-config#get-a-webhook-configuration-for-a-repository)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/get(repos/get-webhook)`.
    public enum ReposGetWebhook {
        public static let id: Swift.String = "repos/get-webhook"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/GET/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposGetWebhook.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetWebhook.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetWebhook.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetWebhook.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetWebhook.Input.Path,
                headers: Operations.ReposGetWebhook.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Hook)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Hook {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetWebhook.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetWebhook.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/get(repos/get-webhook)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetWebhook.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetWebhook.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/get(repos/get-webhook)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a repository webhook
    ///
    /// Updates a webhook configured in a repository. If you previously had a `secret` set, you must provide the same `secret` or set a new `secret` or the secret will be removed. If you are only updating individual webhook `config` properties, use "[Update a webhook configuration for a repository](/rest/webhooks/repo-config#update-a-webhook-configuration-for-a-repository)."
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/patch(repos/update-webhook)`.
    public enum ReposUpdateWebhook {
        public static let id: Swift.String = "repos/update-webhook"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposUpdateWebhook.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateWebhook.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateWebhook.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateWebhook.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody/json/config`.
                    public var config: Components.Schemas.WebhookConfig?
                    /// Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody/json/events`.
                    public var events: [Swift.String]?
                    /// Determines a list of events to be added to the list of events that the Hook triggers for.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody/json/add_events`.
                    public var addEvents: [Swift.String]?
                    /// Determines a list of events to be removed from the list of events that the Hook triggers for.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody/json/remove_events`.
                    public var removeEvents: [Swift.String]?
                    /// Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody/json/active`.
                    public var active: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - config:
                    ///   - events: Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.
                    ///   - addEvents: Determines a list of events to be added to the list of events that the Hook triggers for.
                    ///   - removeEvents: Determines a list of events to be removed from the list of events that the Hook triggers for.
                    ///   - active: Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.
                    public init(
                        config: Components.Schemas.WebhookConfig? = nil,
                        events: [Swift.String]? = nil,
                        addEvents: [Swift.String]? = nil,
                        removeEvents: [Swift.String]? = nil,
                        active: Swift.Bool? = nil
                    ) {
                        self.config = config
                        self.events = events
                        self.addEvents = addEvents
                        self.removeEvents = removeEvents
                        self.active = active
                    }
                    public enum CodingKeys: String, CodingKey {
                        case config
                        case events
                        case addEvents = "add_events"
                        case removeEvents = "remove_events"
                        case active
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateWebhook.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateWebhook.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateWebhook.Input.Path,
                headers: Operations.ReposUpdateWebhook.Input.Headers = .init(),
                body: Operations.ReposUpdateWebhook.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.Hook)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Hook {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateWebhook.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateWebhook.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/patch(repos/update-webhook)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateWebhook.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateWebhook.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/patch(repos/update-webhook)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/patch(repos/update-webhook)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a repository webhook
    ///
    /// Delete a webhook for an organization.
    ///
    /// The authenticated user must be a repository owner, or have admin access in the repository, to delete the webhook.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/hooks/{hook_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/delete(repos/delete-webhook)`.
    public enum ReposDeleteWebhook {
        public static let id: Swift.String = "repos/delete-webhook"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/DELETE/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposDeleteWebhook.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteWebhook.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteWebhook.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteWebhook.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteWebhook.Input.Path,
                headers: Operations.ReposDeleteWebhook.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/delete(repos/delete-webhook)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteWebhook.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/delete(repos/delete-webhook)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteWebhook.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/delete(repos/delete-webhook)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a webhook configuration for a repository
    ///
    /// Returns the webhook configuration for a repository. To get more information about the webhook, including the `active` state and `events`, use "[Get a repository webhook](/rest/webhooks/repos#get-a-repository-webhook)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `read:repo_hook` or `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/config`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/get(repos/get-webhook-config-for-repo)`.
    public enum ReposGetWebhookConfigForRepo {
        public static let id: Swift.String = "repos/get-webhook-config-for-repo"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/GET/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposGetWebhookConfigForRepo.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetWebhookConfigForRepo.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetWebhookConfigForRepo.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetWebhookConfigForRepo.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetWebhookConfigForRepo.Input.Path,
                headers: Operations.ReposGetWebhookConfigForRepo.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.WebhookConfig)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.WebhookConfig {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetWebhookConfigForRepo.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetWebhookConfigForRepo.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/get(repos/get-webhook-config-for-repo)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetWebhookConfigForRepo.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetWebhookConfigForRepo.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a webhook configuration for a repository
    ///
    /// Updates the webhook configuration for a repository. To update more information about the webhook, including the `active` state and `events`, use "[Update a repository webhook](/rest/webhooks/repos#update-a-repository-webhook)."
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `write:repo_hook` or `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/patch(repos/update-webhook-config-for-repo)`.
    public enum ReposUpdateWebhookConfigForRepo {
        public static let id: Swift.String = "repos/update-webhook-config-for-repo"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposUpdateWebhookConfigForRepo.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateWebhookConfigForRepo.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateWebhookConfigForRepo.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateWebhookConfigForRepo.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/requestBody/json/url`.
                    public var url: Components.Schemas.WebhookConfigUrl?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/requestBody/json/content_type`.
                    public var contentType: Components.Schemas.WebhookConfigContentType?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/requestBody/json/secret`.
                    public var secret: Components.Schemas.WebhookConfigSecret?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/requestBody/json/insecure_ssl`.
                    public var insecureSsl: Components.Schemas.WebhookConfigInsecureSsl?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - url:
                    ///   - contentType:
                    ///   - secret:
                    ///   - insecureSsl:
                    public init(
                        url: Components.Schemas.WebhookConfigUrl? = nil,
                        contentType: Components.Schemas.WebhookConfigContentType? = nil,
                        secret: Components.Schemas.WebhookConfigSecret? = nil,
                        insecureSsl: Components.Schemas.WebhookConfigInsecureSsl? = nil
                    ) {
                        self.url = url
                        self.contentType = contentType
                        self.secret = secret
                        self.insecureSsl = insecureSsl
                    }
                    public enum CodingKeys: String, CodingKey {
                        case url
                        case contentType = "content_type"
                        case secret
                        case insecureSsl = "insecure_ssl"
                    }
                    public init(from decoder: any Decoder) throws {
                        let container = try decoder.container(keyedBy: CodingKeys.self)
                        self.url = try container.decodeIfPresent(
                            Components.Schemas.WebhookConfigUrl.self,
                            forKey: .url
                        )
                        self.contentType = try container.decodeIfPresent(
                            Components.Schemas.WebhookConfigContentType.self,
                            forKey: .contentType
                        )
                        self.secret = try container.decodeIfPresent(
                            Components.Schemas.WebhookConfigSecret.self,
                            forKey: .secret
                        )
                        self.insecureSsl = try container.decodeIfPresent(
                            Components.Schemas.WebhookConfigInsecureSsl.self,
                            forKey: .insecureSsl
                        )
                        try decoder.ensureNoAdditionalProperties(knownKeys: [
                            "url",
                            "content_type",
                            "secret",
                            "insecure_ssl"
                        ])
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateWebhookConfigForRepo.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateWebhookConfigForRepo.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateWebhookConfigForRepo.Input.Path,
                headers: Operations.ReposUpdateWebhookConfigForRepo.Input.Headers = .init(),
                body: Operations.ReposUpdateWebhookConfigForRepo.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/config/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.WebhookConfig)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.WebhookConfig {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateWebhookConfigForRepo.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateWebhookConfigForRepo.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/config/patch(repos/update-webhook-config-for-repo)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateWebhookConfigForRepo.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateWebhookConfigForRepo.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List deliveries for a repository webhook
    ///
    /// Returns a list of webhook deliveries for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/get(repos/list-webhook-deliveries)`.
    public enum ReposListWebhookDeliveries {
        public static let id: Swift.String = "repos/list-webhook-deliveries"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposListWebhookDeliveries.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/query/cursor`.
                public var cursor: Components.Parameters.Cursor?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - cursor: Used for pagination: the starting delivery from which the page of deliveries is fetched. Refer to the `link` header for the next and previous page cursors.
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    cursor: Components.Parameters.Cursor? = nil
                ) {
                    self.perPage = perPage
                    self.cursor = cursor
                }
            }
            public var query: Operations.ReposListWebhookDeliveries.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListWebhookDeliveries.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListWebhookDeliveries.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListWebhookDeliveries.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListWebhookDeliveries.Input.Path,
                query: Operations.ReposListWebhookDeliveries.Input.Query = .init(),
                headers: Operations.ReposListWebhookDeliveries.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.HookDeliveryItem])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.HookDeliveryItem] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListWebhookDeliveries.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListWebhookDeliveries.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/get(repos/list-webhook-deliveries)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListWebhookDeliveries.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListWebhookDeliveries.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/get(repos/list-webhook-deliveries)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/get(repos/list-webhook-deliveries)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Get a delivery for a repository webhook
    ///
    /// Returns a delivery for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/get(repos/get-webhook-delivery)`.
    public enum ReposGetWebhookDelivery {
        public static let id: Swift.String = "repos/get-webhook-delivery"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/path/delivery_id`.
                public var deliveryId: Components.Parameters.DeliveryId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///   - deliveryId:
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId,
                    deliveryId: Components.Parameters.DeliveryId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                    self.deliveryId = deliveryId
                }
            }
            public var path: Operations.ReposGetWebhookDelivery.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetWebhookDelivery.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetWebhookDelivery.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetWebhookDelivery.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetWebhookDelivery.Input.Path,
                headers: Operations.ReposGetWebhookDelivery.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.HookDelivery)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.HookDelivery {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetWebhookDelivery.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetWebhookDelivery.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/get(repos/get-webhook-delivery)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetWebhookDelivery.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetWebhookDelivery.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/get(repos/get-webhook-delivery)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/get(repos/get-webhook-delivery)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Redeliver a delivery for a repository webhook
    ///
    /// Redeliver a webhook delivery for a webhook configured in a repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/post(repos/redeliver-webhook-delivery)`.
    public enum ReposRedeliverWebhookDelivery {
        public static let id: Swift.String = "repos/redeliver-webhook-delivery"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/POST/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/POST/path/delivery_id`.
                public var deliveryId: Components.Parameters.DeliveryId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///   - deliveryId:
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId,
                    deliveryId: Components.Parameters.DeliveryId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                    self.deliveryId = deliveryId
                }
            }
            public var path: Operations.ReposRedeliverWebhookDelivery.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRedeliverWebhookDelivery.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRedeliverWebhookDelivery.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRedeliverWebhookDelivery.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposRedeliverWebhookDelivery.Input.Path,
                headers: Operations.ReposRedeliverWebhookDelivery.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            /// Accepted
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/post(repos/redeliver-webhook-delivery)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Components.Responses.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Components.Responses.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/post(repos/redeliver-webhook-delivery)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts/post(repos/redeliver-webhook-delivery)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Ping a repository webhook
    ///
    /// This will trigger a [ping event](https://docs.github.com/webhooks/#ping-event) to be sent to the hook.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/pings`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/pings/post(repos/ping-webhook)`.
    public enum ReposPingWebhook {
        public static let id: Swift.String = "repos/ping-webhook"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/pings/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/pings/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/pings/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/pings/POST/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposPingWebhook.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/pings/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposPingWebhook.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposPingWebhook.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposPingWebhook.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposPingWebhook.Input.Path,
                headers: Operations.ReposPingWebhook.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/pings/post(repos/ping-webhook)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposPingWebhook.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/pings/post(repos/ping-webhook)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposPingWebhook.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/pings/post(repos/ping-webhook)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Test the push repository webhook
    ///
    /// This will trigger the hook with the latest push to the current repository if the hook is subscribed to `push` events. If the hook is not subscribed to `push` events, the server will respond with 204 but no test POST will be generated.
    ///
    /// > [!NOTE]
    /// > Previously `/repos/:owner/:repo/hooks/:hook_id/test`
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/hooks/{hook_id}/tests`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/tests/post(repos/test-push-webhook)`.
    public enum ReposTestPushWebhook {
        public static let id: Swift.String = "repos/test-push-webhook"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/tests/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/tests/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/tests/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/tests/POST/path/hook_id`.
                public var hookId: Components.Parameters.HookId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - hookId: The unique identifier of the hook. You can find this value in the `X-GitHub-Hook-ID` header of a webhook delivery.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    hookId: Components.Parameters.HookId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.hookId = hookId
                }
            }
            public var path: Operations.ReposTestPushWebhook.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/hooks/{hook_id}/tests/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposTestPushWebhook.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposTestPushWebhook.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposTestPushWebhook.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposTestPushWebhook.Input.Path,
                headers: Operations.ReposTestPushWebhook.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/tests/post(repos/test-push-webhook)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposTestPushWebhook.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/tests/post(repos/test-push-webhook)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposTestPushWebhook.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/hooks/{hook_id}/tests/post(repos/test-push-webhook)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repository invitations
    ///
    /// When authenticating as a user with admin rights to a repository, this endpoint will list all currently open repository invitations.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/invitations`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/get(repos/list-invitations)`.
    public enum ReposListInvitations {
        public static let id: Swift.String = "repos/list-invitations"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListInvitations.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListInvitations.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListInvitations.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListInvitations.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListInvitations.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListInvitations.Input.Path,
                query: Operations.ReposListInvitations.Input.Query = .init(),
                headers: Operations.ReposListInvitations.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListInvitations.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.RepositoryInvitation])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.RepositoryInvitation] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListInvitations.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListInvitations.Output.Ok.Headers = .init(),
                    body: Operations.ReposListInvitations.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/get(repos/list-invitations)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListInvitations.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListInvitations.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/patch(repos/update-invitation)`.
    public enum ReposUpdateInvitation {
        public static let id: Swift.String = "repos/update-invitation"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the invitation.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/path/invitation_id`.
                public var invitationId: Components.Parameters.InvitationId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - invitationId: The unique identifier of the invitation.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    invitationId: Components.Parameters.InvitationId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.invitationId = invitationId
                }
            }
            public var path: Operations.ReposUpdateInvitation.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateInvitation.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateInvitation.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateInvitation.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/requestBody/json/permissions`.
                    @frozen public enum PermissionsPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case read = "read"
                        case write = "write"
                        case maintain = "maintain"
                        case triage = "triage"
                        case admin = "admin"
                    }
                    /// The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/requestBody/json/permissions`.
                    public var permissions: Operations.ReposUpdateInvitation.Input.Body.JsonPayload.PermissionsPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - permissions: The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.
                    public init(permissions: Operations.ReposUpdateInvitation.Input.Body.JsonPayload.PermissionsPayload? = nil) {
                        self.permissions = permissions
                    }
                    public enum CodingKeys: String, CodingKey {
                        case permissions
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateInvitation.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateInvitation.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateInvitation.Input.Path,
                headers: Operations.ReposUpdateInvitation.Input.Headers = .init(),
                body: Operations.ReposUpdateInvitation.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.RepositoryInvitation)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryInvitation {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateInvitation.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateInvitation.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/patch(repos/update-invitation)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateInvitation.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateInvitation.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/delete(repos/delete-invitation)`.
    public enum ReposDeleteInvitation {
        public static let id: Swift.String = "repos/delete-invitation"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the invitation.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/invitations/{invitation_id}/DELETE/path/invitation_id`.
                public var invitationId: Components.Parameters.InvitationId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - invitationId: The unique identifier of the invitation.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    invitationId: Components.Parameters.InvitationId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.invitationId = invitationId
                }
            }
            public var path: Operations.ReposDeleteInvitation.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDeleteInvitation.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/delete(repos/delete-invitation)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteInvitation.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/invitations/{invitation_id}/delete(repos/delete-invitation)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteInvitation.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// List deploy keys
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/keys`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/get(repos/list-deploy-keys)`.
    public enum ReposListDeployKeys {
        public static let id: Swift.String = "repos/list-deploy-keys"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListDeployKeys.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListDeployKeys.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeployKeys.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListDeployKeys.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListDeployKeys.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListDeployKeys.Input.Path,
                query: Operations.ReposListDeployKeys.Input.Query = .init(),
                headers: Operations.ReposListDeployKeys.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListDeployKeys.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.DeployKey])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.DeployKey] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListDeployKeys.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListDeployKeys.Output.Ok.Headers = .init(),
                    body: Operations.ReposListDeployKeys.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/get(repos/list-deploy-keys)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListDeployKeys.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListDeployKeys.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a deploy key
    ///
    /// You can create a read-only deploy key.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/keys`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/post(repos/create-deploy-key)`.
    public enum ReposCreateDeployKey {
        public static let id: Swift.String = "repos/create-deploy-key"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateDeployKey.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeployKey.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateDeployKey.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateDeployKey.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// A name for the key.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/requestBody/json/title`.
                    public var title: Swift.String?
                    /// The contents of the key.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/requestBody/json/key`.
                    public var key: Swift.String
                    /// If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  
                    ///   
                    /// Deploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/requestBody/json/read_only`.
                    public var readOnly: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - title: A name for the key.
                    ///   - key: The contents of the key.
                    ///   - readOnly: If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  
                    public init(
                        title: Swift.String? = nil,
                        key: Swift.String,
                        readOnly: Swift.Bool? = nil
                    ) {
                        self.title = title
                        self.key = key
                        self.readOnly = readOnly
                    }
                    public enum CodingKeys: String, CodingKey {
                        case title
                        case key
                        case readOnly = "read_only"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateDeployKey.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateDeployKey.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateDeployKey.Input.Path,
                headers: Operations.ReposCreateDeployKey.Input.Headers = .init(),
                body: Operations.ReposCreateDeployKey.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateDeployKey.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.DeployKey)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeployKey {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateDeployKey.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateDeployKey.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateDeployKey.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/post(repos/create-deploy-key)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateDeployKey.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateDeployKey.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/post(repos/create-deploy-key)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a deploy key
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/keys/{key_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/get(repos/get-deploy-key)`.
    public enum ReposGetDeployKey {
        public static let id: Swift.String = "repos/get-deploy-key"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the key.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/GET/path/key_id`.
                public var keyId: Components.Parameters.KeyId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - keyId: The unique identifier of the key.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    keyId: Components.Parameters.KeyId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.keyId = keyId
                }
            }
            public var path: Operations.ReposGetDeployKey.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeployKey.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetDeployKey.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetDeployKey.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetDeployKey.Input.Path,
                headers: Operations.ReposGetDeployKey.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.DeployKey)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.DeployKey {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetDeployKey.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetDeployKey.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/get(repos/get-deploy-key)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetDeployKey.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetDeployKey.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/get(repos/get-deploy-key)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a deploy key
    ///
    /// Deploy keys are immutable. If you need to update a key, remove the key and create a new one instead.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/keys/{key_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/delete(repos/delete-deploy-key)`.
    public enum ReposDeleteDeployKey {
        public static let id: Swift.String = "repos/delete-deploy-key"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the key.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/keys/{key_id}/DELETE/path/key_id`.
                public var keyId: Components.Parameters.KeyId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - keyId: The unique identifier of the key.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    keyId: Components.Parameters.KeyId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.keyId = keyId
                }
            }
            public var path: Operations.ReposDeleteDeployKey.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDeleteDeployKey.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/delete(repos/delete-deploy-key)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteDeployKey.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/keys/{key_id}/delete(repos/delete-deploy-key)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteDeployKey.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// List repository languages
    ///
    /// Lists languages for the specified repository. The value shown for each language is the number of bytes of code written in that language.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/languages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/languages/get(repos/list-languages)`.
    public enum ReposListLanguages {
        public static let id: Swift.String = "repos/list-languages"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/languages/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/languages/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/languages/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListLanguages.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/languages/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListLanguages.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListLanguages.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListLanguages.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposListLanguages.Input.Path,
                headers: Operations.ReposListLanguages.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/languages/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/languages/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Language)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Language {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListLanguages.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListLanguages.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/languages/get(repos/list-languages)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListLanguages.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListLanguages.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Sync a fork branch with the upstream repository
    ///
    /// Sync a branch of a forked repository to keep it up-to-date with the upstream repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/merge-upstream`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)`.
    public enum ReposMergeUpstream {
        public static let id: Swift.String = "repos/merge-upstream"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposMergeUpstream.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposMergeUpstream.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposMergeUpstream.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposMergeUpstream.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the branch which should be updated to match upstream.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/requestBody/json/branch`.
                    public var branch: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - branch: The name of the branch which should be updated to match upstream.
                    public init(branch: Swift.String) {
                        self.branch = branch
                    }
                    public enum CodingKeys: String, CodingKey {
                        case branch
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/requestBody/content/application\/json`.
                case json(Operations.ReposMergeUpstream.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposMergeUpstream.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposMergeUpstream.Input.Path,
                headers: Operations.ReposMergeUpstream.Input.Headers = .init(),
                body: Operations.ReposMergeUpstream.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merge-upstream/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.MergedUpstream)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MergedUpstream {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposMergeUpstream.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposMergeUpstream.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The branch has been successfully synced with the upstream repository
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposMergeUpstream.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposMergeUpstream.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Conflict: Sendable, Hashable {
                /// Creates a new `Conflict`.
                public init() {}
            }
            /// The branch could not be synced because of a merge conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Operations.ReposMergeUpstream.Output.Conflict)
            /// The branch could not be synced because of a merge conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            public static var conflict: Self {
                .conflict(.init())
            }
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Operations.ReposMergeUpstream.Output.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            public struct UnprocessableContent: Sendable, Hashable {
                /// Creates a new `UnprocessableContent`.
                public init() {}
            }
            /// The branch could not be synced for some other reason
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Operations.ReposMergeUpstream.Output.UnprocessableContent)
            /// The branch could not be synced for some other reason
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merge-upstream/post(repos/merge-upstream)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            public static var unprocessableContent: Self {
                .unprocessableContent(.init())
            }
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Operations.ReposMergeUpstream.Output.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Merge a branch
    ///
    ///
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/merges`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)`.
    public enum ReposMerge {
        public static let id: Swift.String = "repos/merge"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposMerge.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposMerge.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposMerge.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposMerge.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the base branch that the head will be merged into.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/requestBody/json/base`.
                    public var base: Swift.String
                    /// The head to merge. This can be a branch name or a commit SHA1.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/requestBody/json/head`.
                    public var head: Swift.String
                    /// Commit message to use for the merge commit. If omitted, a default message will be used.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/requestBody/json/commit_message`.
                    public var commitMessage: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - base: The name of the base branch that the head will be merged into.
                    ///   - head: The head to merge. This can be a branch name or a commit SHA1.
                    ///   - commitMessage: Commit message to use for the merge commit. If omitted, a default message will be used.
                    public init(
                        base: Swift.String,
                        head: Swift.String,
                        commitMessage: Swift.String? = nil
                    ) {
                        self.base = base
                        self.head = head
                        self.commitMessage = commitMessage
                    }
                    public enum CodingKeys: String, CodingKey {
                        case base
                        case head
                        case commitMessage = "commit_message"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/requestBody/content/application\/json`.
                case json(Operations.ReposMerge.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposMerge.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposMerge.Input.Path,
                headers: Operations.ReposMerge.Input.Headers = .init(),
                body: Operations.ReposMerge.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/merges/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.Commit)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Commit {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposMerge.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposMerge.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Successful Response (The resulting merge commit)
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposMerge.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposMerge.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response when already merged
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposMerge.Output.NoContent)
            /// Response when already merged
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposMerge.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// Creates a new `NotFound`.
                public init() {}
            }
            /// Not Found when the base or head does not exist
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposMerge.Output.NotFound)
            /// Not Found when the base or head does not exist
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            public static var notFound: Self {
                .notFound(.init())
            }
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposMerge.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            public struct Conflict: Sendable, Hashable {
                /// Creates a new `Conflict`.
                public init() {}
            }
            /// Conflict when there is a merge conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Operations.ReposMerge.Output.Conflict)
            /// Conflict when there is a merge conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            public static var conflict: Self {
                .conflict(.init())
            }
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Operations.ReposMerge.Output.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/merges/post(repos/merge)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a GitHub Pages site
    ///
    /// Gets information about a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/get(repos/get-pages)`.
    public enum ReposGetPages {
        public static let id: Swift.String = "repos/get-pages"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetPages.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPages.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPages.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetPages.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetPages.Input.Path,
                headers: Operations.ReposGetPages.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Page)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Page {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetPages.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetPages.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/get(repos/get-pages)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetPages.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetPages.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/get(repos/get-pages)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a GitHub Pages site
    ///
    /// Configures a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages)."
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/post(repos/create-pages-site)`.
    public enum ReposCreatePagesSite {
        public static let id: Swift.String = "repos/create-pages-site"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreatePagesSite.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreatePagesSite.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreatePagesSite.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreatePagesSite.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// The source branch and directory used to publish your Pages site.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/requestBody/json/value1`.
                    public struct Value1Payload: Codable, Hashable, Sendable {
                        /// Creates a new `Value1Payload`.
                        public init() {}
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/requestBody/json/value1`.
                    public var value1: Operations.ReposCreatePagesSite.Input.Body.JsonPayload.Value1Payload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/requestBody/json/value2`.
                    public struct Value2Payload: Codable, Hashable, Sendable {
                        /// Creates a new `Value2Payload`.
                        public init() {}
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/requestBody/json/value2`.
                    public var value2: Operations.ReposCreatePagesSite.Input.Body.JsonPayload.Value2Payload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    ///   - value2:
                    public init(
                        value1: Operations.ReposCreatePagesSite.Input.Body.JsonPayload.Value1Payload? = nil,
                        value2: Operations.ReposCreatePagesSite.Input.Body.JsonPayload.Value2Payload? = nil
                    ) {
                        self.value1 = value1
                        self.value2 = value2
                    }
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self.value1 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self.value2 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                            [
                                self.value1,
                                self.value2
                            ],
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try self.value1?.encode(to: encoder)
                        try self.value2?.encode(to: encoder)
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreatePagesSite.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreatePagesSite.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreatePagesSite.Input.Path,
                headers: Operations.ReposCreatePagesSite.Input.Headers = .init(),
                body: Operations.ReposCreatePagesSite.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.Page)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Page {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreatePagesSite.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreatePagesSite.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/post(repos/create-pages-site)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreatePagesSite.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreatePagesSite.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/post(repos/create-pages-site)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/post(repos/create-pages-site)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update information about a GitHub Pages site
    ///
    /// Updates information for a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)`.
    public enum ReposUpdateInformationAboutPagesSite {
        public static let id: Swift.String = "repos/update-information-about-pages-site"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposUpdateInformationAboutPagesSite.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateInformationAboutPagesSite.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateInformationAboutPagesSite.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateInformationAboutPagesSite.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value1`.
                    public struct Value1Payload: Codable, Hashable, Sendable {
                        /// Creates a new `Value1Payload`.
                        public init() {}
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value1`.
                    public var value1: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value1Payload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value2`.
                    public struct Value2Payload: Codable, Hashable, Sendable {
                        /// Creates a new `Value2Payload`.
                        public init() {}
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value2`.
                    public var value2: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value2Payload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value3`.
                    public struct Value3Payload: Codable, Hashable, Sendable {
                        /// Creates a new `Value3Payload`.
                        public init() {}
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value3`.
                    public var value3: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value3Payload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value4`.
                    public struct Value4Payload: Codable, Hashable, Sendable {
                        /// Creates a new `Value4Payload`.
                        public init() {}
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value4`.
                    public var value4: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value4Payload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value5`.
                    public struct Value5Payload: Codable, Hashable, Sendable {
                        /// Creates a new `Value5Payload`.
                        public init() {}
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/json/value5`.
                    public var value5: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value5Payload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    ///   - value2:
                    ///   - value3:
                    ///   - value4:
                    ///   - value5:
                    public init(
                        value1: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value1Payload? = nil,
                        value2: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value2Payload? = nil,
                        value3: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value3Payload? = nil,
                        value4: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value4Payload? = nil,
                        value5: Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload.Value5Payload? = nil
                    ) {
                        self.value1 = value1
                        self.value2 = value2
                        self.value3 = value3
                        self.value4 = value4
                        self.value5 = value5
                    }
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self.value1 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self.value2 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self.value3 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self.value4 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self.value5 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                            [
                                self.value1,
                                self.value2,
                                self.value3,
                                self.value4,
                                self.value5
                            ],
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try self.value1?.encode(to: encoder)
                        try self.value2?.encode(to: encoder)
                        try self.value3?.encode(to: encoder)
                        try self.value4?.encode(to: encoder)
                        try self.value5?.encode(to: encoder)
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateInformationAboutPagesSite.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateInformationAboutPagesSite.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateInformationAboutPagesSite.Input.Path,
                headers: Operations.ReposUpdateInformationAboutPagesSite.Input.Headers = .init(),
                body: Operations.ReposUpdateInformationAboutPagesSite.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposUpdateInformationAboutPagesSite.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposUpdateInformationAboutPagesSite.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/put(repos/update-information-about-pages-site)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Delete a GitHub Pages site
    ///
    /// Deletes a GitHub Pages site. For more information, see "[About GitHub Pages](/github/working-with-github-pages/about-github-pages).
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/pages`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)`.
    public enum ReposDeletePagesSite {
        public static let id: Swift.String = "repos/delete-pages-site"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposDeletePagesSite.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeletePagesSite.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeletePagesSite.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeletePagesSite.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeletePagesSite.Input.Path,
                headers: Operations.ReposDeletePagesSite.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeletePagesSite.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeletePagesSite.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/delete(repos/delete-pages-site)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List GitHub Pages builds
    ///
    /// Lists builts of a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/get(repos/list-pages-builds)`.
    public enum ReposListPagesBuilds {
        public static let id: Swift.String = "repos/list-pages-builds"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListPagesBuilds.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListPagesBuilds.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListPagesBuilds.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListPagesBuilds.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListPagesBuilds.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListPagesBuilds.Input.Path,
                query: Operations.ReposListPagesBuilds.Input.Query = .init(),
                headers: Operations.ReposListPagesBuilds.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListPagesBuilds.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.PageBuild])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.PageBuild] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListPagesBuilds.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListPagesBuilds.Output.Ok.Headers = .init(),
                    body: Operations.ReposListPagesBuilds.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/get(repos/list-pages-builds)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListPagesBuilds.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListPagesBuilds.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Request a GitHub Pages build
    ///
    /// You can request that your site be built from the latest revision on the default branch. This has the same effect as pushing a commit to your default branch, but does not require an additional commit. Manually triggering page builds can be helpful when diagnosing build warnings and failures.
    ///
    /// Build requests are limited to one concurrent build per repository and one concurrent build per requester. If you request a build while another is still in progress, the second request will be queued until the first completes.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/builds`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/post(repos/request-pages-build)`.
    public enum ReposRequestPagesBuild {
        public static let id: Swift.String = "repos/request-pages-build"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposRequestPagesBuild.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRequestPagesBuild.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposRequestPagesBuild.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposRequestPagesBuild.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposRequestPagesBuild.Input.Path,
                headers: Operations.ReposRequestPagesBuild.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.PageBuildStatus)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PageBuildStatus {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposRequestPagesBuild.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposRequestPagesBuild.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/post(repos/request-pages-build)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposRequestPagesBuild.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposRequestPagesBuild.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get latest Pages build
    ///
    /// Gets information about the single most recent build of a GitHub Pages site.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/latest/get(repos/get-latest-pages-build)`.
    public enum ReposGetLatestPagesBuild {
        public static let id: Swift.String = "repos/get-latest-pages-build"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/latest/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/latest/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetLatestPagesBuild.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetLatestPagesBuild.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetLatestPagesBuild.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetLatestPagesBuild.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetLatestPagesBuild.Input.Path,
                headers: Operations.ReposGetLatestPagesBuild.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.PageBuild)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PageBuild {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetLatestPagesBuild.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetLatestPagesBuild.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/latest/get(repos/get-latest-pages-build)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetLatestPagesBuild.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetLatestPagesBuild.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get GitHub Pages build
    ///
    /// Gets information about a GitHub Pages build.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/builds/{build_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/{build_id}/get(repos/get-pages-build)`.
    public enum ReposGetPagesBuild {
        public static let id: Swift.String = "repos/get-pages-build"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/{build_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/{build_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/{build_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/{build_id}/GET/path/build_id`.
                public var buildId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - buildId:
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    buildId: Swift.Int
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.buildId = buildId
                }
            }
            public var path: Operations.ReposGetPagesBuild.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/{build_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPagesBuild.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPagesBuild.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetPagesBuild.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetPagesBuild.Input.Path,
                headers: Operations.ReposGetPagesBuild.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/{build_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/builds/{build_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.PageBuild)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PageBuild {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetPagesBuild.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetPagesBuild.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/builds/{build_id}/get(repos/get-pages-build)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetPagesBuild.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetPagesBuild.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a GitHub Pages deployment
    ///
    /// Create a GitHub Pages deployment for a repository.
    ///
    /// The authenticated user must have write permission to the repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/deployments`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/post(repos/create-pages-deployment)`.
    public enum ReposCreatePagesDeployment {
        public static let id: Swift.String = "repos/create-pages-deployment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreatePagesDeployment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreatePagesDeployment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreatePagesDeployment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreatePagesDeployment.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// The object used to create GitHub Pages deployment
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody/json/artifact_id`.
                    public var artifactId: Swift.Double?
                    /// The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody/json/artifact_url`.
                    public var artifactUrl: Swift.String?
                    /// The target environment for this GitHub Pages deployment.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody/json/environment`.
                    public var environment: Swift.String?
                    /// A unique string that represents the version of the build for this deployment.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody/json/pages_build_version`.
                    public var pagesBuildVersion: Swift.String
                    /// The OIDC token issued by GitHub Actions certifying the origin of the deployment.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody/json/oidc_token`.
                    public var oidcToken: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - artifactId: The ID of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
                    ///   - artifactUrl: The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository. Either `artifact_id` or `artifact_url` are required.
                    ///   - environment: The target environment for this GitHub Pages deployment.
                    ///   - pagesBuildVersion: A unique string that represents the version of the build for this deployment.
                    ///   - oidcToken: The OIDC token issued by GitHub Actions certifying the origin of the deployment.
                    public init(
                        artifactId: Swift.Double? = nil,
                        artifactUrl: Swift.String? = nil,
                        environment: Swift.String? = nil,
                        pagesBuildVersion: Swift.String,
                        oidcToken: Swift.String
                    ) {
                        self.artifactId = artifactId
                        self.artifactUrl = artifactUrl
                        self.environment = environment
                        self.pagesBuildVersion = pagesBuildVersion
                        self.oidcToken = oidcToken
                    }
                    public enum CodingKeys: String, CodingKey {
                        case artifactId = "artifact_id"
                        case artifactUrl = "artifact_url"
                        case environment
                        case pagesBuildVersion = "pages_build_version"
                        case oidcToken = "oidc_token"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreatePagesDeployment.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreatePagesDeployment.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreatePagesDeployment.Input.Path,
                headers: Operations.ReposCreatePagesDeployment.Input.Headers = .init(),
                body: Operations.ReposCreatePagesDeployment.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.PageDeployment)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PageDeployment {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreatePagesDeployment.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreatePagesDeployment.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/post(repos/create-pages-deployment)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCreatePagesDeployment.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCreatePagesDeployment.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/post(repos/create-pages-deployment)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/post(repos/create-pages-deployment)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/post(repos/create-pages-deployment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Get the status of a GitHub Pages deployment
    ///
    /// Gets the current status of a GitHub Pages deployment.
    ///
    /// The authenticated user must have read permission for the GitHub Pages site.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/get(repos/get-pages-deployment)`.
    public enum ReposGetPagesDeployment {
        public static let id: Swift.String = "repos/get-pages-deployment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// - Remark: Generated from `#/components/parameters/pages-deployment-id`.
                @frozen public enum PagesDeploymentId: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/parameters/pages-deployment-id/case1`.
                    case case1(Swift.Int)
                    /// - Remark: Generated from `#/components/parameters/pages-deployment-id/case2`.
                    case case2(Swift.String)
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try encoder.encodeToSingleValueContainer(value)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// The ID of the Pages deployment. You can also give the commit SHA of the deployment.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/GET/path/pages_deployment_id`.
                public var pagesDeploymentId: Components.Parameters.PagesDeploymentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - pagesDeploymentId: The ID of the Pages deployment. You can also give the commit SHA of the deployment.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    pagesDeploymentId: Components.Parameters.PagesDeploymentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.pagesDeploymentId = pagesDeploymentId
                }
            }
            public var path: Operations.ReposGetPagesDeployment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPagesDeployment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPagesDeployment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetPagesDeployment.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetPagesDeployment.Input.Path,
                headers: Operations.ReposGetPagesDeployment.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.PagesDeploymentStatus)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PagesDeploymentStatus {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetPagesDeployment.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetPagesDeployment.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/get(repos/get-pages-deployment)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetPagesDeployment.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetPagesDeployment.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/get(repos/get-pages-deployment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Cancel a GitHub Pages deployment
    ///
    /// Cancels a GitHub Pages deployment.
    ///
    /// The authenticated user must have write permissions for the GitHub Pages site.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/post(repos/cancel-pages-deployment)`.
    public enum ReposCancelPagesDeployment {
        public static let id: Swift.String = "repos/cancel-pages-deployment"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// - Remark: Generated from `#/components/parameters/pages-deployment-id`.
                @frozen public enum PagesDeploymentId: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/parameters/pages-deployment-id/case1`.
                    case case1(Swift.Int)
                    /// - Remark: Generated from `#/components/parameters/pages-deployment-id/case2`.
                    case case2(Swift.String)
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self = .case1(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self = .case2(try decoder.decodeFromSingleValueContainer())
                            return
                        } catch {
                            errors.append(error)
                        }
                        throw Swift.DecodingError.failedToDecodeOneOfSchema(
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        switch self {
                        case let .case1(value):
                            try encoder.encodeToSingleValueContainer(value)
                        case let .case2(value):
                            try encoder.encodeToSingleValueContainer(value)
                        }
                    }
                }
                /// The ID of the Pages deployment. You can also give the commit SHA of the deployment.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/POST/path/pages_deployment_id`.
                public var pagesDeploymentId: Components.Parameters.PagesDeploymentId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - pagesDeploymentId: The ID of the Pages deployment. You can also give the commit SHA of the deployment.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    pagesDeploymentId: Components.Parameters.PagesDeploymentId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.pagesDeploymentId = pagesDeploymentId
                }
            }
            public var path: Operations.ReposCancelPagesDeployment.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCancelPagesDeployment.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCancelPagesDeployment.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCancelPagesDeployment.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposCancelPagesDeployment.Input.Path,
                headers: Operations.ReposCancelPagesDeployment.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/post(repos/cancel-pages-deployment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Components.Responses.NoContent)
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/post(repos/cancel-pages-deployment)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Components.Responses.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel/post(repos/cancel-pages-deployment)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a DNS health check for GitHub Pages
    ///
    /// Gets a health check of the DNS settings for the `CNAME` record configured for a repository's GitHub Pages.
    ///
    /// The first request to this endpoint returns a `202 Accepted` status and starts an asynchronous background task to get the results for the domain. After the background task completes, subsequent requests to this endpoint return a `200 OK` status with the health check results in the response.
    ///
    /// The authenticated user must be a repository administrator, maintainer, or have the 'manage GitHub Pages settings' permission to use this endpoint.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `repo` scope to use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/pages/health`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)`.
    public enum ReposGetPagesHealthCheck {
        public static let id: Swift.String = "repos/get-pages-health-check"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetPagesHealthCheck.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPagesHealthCheck.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPagesHealthCheck.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetPagesHealthCheck.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetPagesHealthCheck.Input.Path,
                headers: Operations.ReposGetPagesHealthCheck.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.PagesHealthCheck)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.PagesHealthCheck {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetPagesHealthCheck.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetPagesHealthCheck.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetPagesHealthCheck.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetPagesHealthCheck.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Accepted: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/responses/202/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/pages/health/GET/responses/202/content/application\/json`.
                    case json(Components.Schemas.EmptyObject)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.EmptyObject {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetPagesHealthCheck.Output.Accepted.Body
                /// Creates a new `Accepted`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetPagesHealthCheck.Output.Accepted.Body) {
                    self.body = body
                }
            }
            /// Empty response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Operations.ReposGetPagesHealthCheck.Output.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Operations.ReposGetPagesHealthCheck.Output.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            public struct BadRequest: Sendable, Hashable {
                /// Creates a new `BadRequest`.
                public init() {}
            }
            /// Custom domains are not available for GitHub Pages
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Operations.ReposGetPagesHealthCheck.Output.BadRequest)
            /// Custom domains are not available for GitHub Pages
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            public static var badRequest: Self {
                .badRequest(.init())
            }
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Operations.ReposGetPagesHealthCheck.Output.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            public struct UnprocessableContent: Sendable, Hashable {
                /// Creates a new `UnprocessableContent`.
                public init() {}
            }
            /// There isn't a CNAME for this page
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Operations.ReposGetPagesHealthCheck.Output.UnprocessableContent)
            /// There isn't a CNAME for this page
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            public static var unprocessableContent: Self {
                .unprocessableContent(.init())
            }
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Operations.ReposGetPagesHealthCheck.Output.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/pages/health/get(repos/get-pages-health-check)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Check if private vulnerability reporting is enabled for a repository
    ///
    /// Returns a boolean indicating whether or not private vulnerability reporting is enabled for the repository. For more information, see "[Evaluating the security settings of a repository](https://docs.github.com/code-security/security-advisories/working-with-repository-security-advisories/evaluating-the-security-settings-of-a-repository)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/get(repos/check-private-vulnerability-reporting)`.
    public enum ReposCheckPrivateVulnerabilityReporting {
        public static let id: Swift.String = "repos/check-private-vulnerability-reporting"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCheckPrivateVulnerabilityReporting.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCheckPrivateVulnerabilityReporting.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCheckPrivateVulnerabilityReporting.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCheckPrivateVulnerabilityReporting.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposCheckPrivateVulnerabilityReporting.Input.Path,
                headers: Operations.ReposCheckPrivateVulnerabilityReporting.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/responses/200/content/json`.
                    public struct JsonPayload: Codable, Hashable, Sendable {
                        /// Whether or not private vulnerability reporting is enabled for the repository.
                        ///
                        /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/responses/200/content/json/enabled`.
                        public var enabled: Swift.Bool
                        /// Creates a new `JsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - enabled: Whether or not private vulnerability reporting is enabled for the repository.
                        public init(enabled: Swift.Bool) {
                            self.enabled = enabled
                        }
                        public enum CodingKeys: String, CodingKey {
                            case enabled
                        }
                    }
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/GET/responses/200/content/application\/json`.
                    case json(Operations.ReposCheckPrivateVulnerabilityReporting.Output.Ok.Body.JsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.ReposCheckPrivateVulnerabilityReporting.Output.Ok.Body.JsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCheckPrivateVulnerabilityReporting.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCheckPrivateVulnerabilityReporting.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Private vulnerability reporting status
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/get(repos/check-private-vulnerability-reporting)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposCheckPrivateVulnerabilityReporting.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposCheckPrivateVulnerabilityReporting.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/get(repos/check-private-vulnerability-reporting)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Enable private vulnerability reporting for a repository
    ///
    /// Enables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)."
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/put(repos/enable-private-vulnerability-reporting)`.
    public enum ReposEnablePrivateVulnerabilityReporting {
        public static let id: Swift.String = "repos/enable-private-vulnerability-reporting"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposEnablePrivateVulnerabilityReporting.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposEnablePrivateVulnerabilityReporting.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposEnablePrivateVulnerabilityReporting.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposEnablePrivateVulnerabilityReporting.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposEnablePrivateVulnerabilityReporting.Input.Path,
                headers: Operations.ReposEnablePrivateVulnerabilityReporting.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/put(repos/enable-private-vulnerability-reporting)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Components.Responses.NoContent)
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/put(repos/enable-private-vulnerability-reporting)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Components.Responses.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/put(repos/enable-private-vulnerability-reporting)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Disable private vulnerability reporting for a repository
    ///
    /// Disables private vulnerability reporting for a repository. The authenticated user must have admin access to the repository. For more information, see "[Privately reporting a security vulnerability](https://docs.github.com/code-security/security-advisories/guidance-on-reporting-and-writing/privately-reporting-a-security-vulnerability)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/private-vulnerability-reporting`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/delete(repos/disable-private-vulnerability-reporting)`.
    public enum ReposDisablePrivateVulnerabilityReporting {
        public static let id: Swift.String = "repos/disable-private-vulnerability-reporting"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposDisablePrivateVulnerabilityReporting.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/private-vulnerability-reporting/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDisablePrivateVulnerabilityReporting.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDisablePrivateVulnerabilityReporting.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDisablePrivateVulnerabilityReporting.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDisablePrivateVulnerabilityReporting.Input.Path,
                headers: Operations.ReposDisablePrivateVulnerabilityReporting.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/delete(repos/disable-private-vulnerability-reporting)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Components.Responses.NoContent)
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/delete(repos/disable-private-vulnerability-reporting)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Components.Responses.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/private-vulnerability-reporting/delete(repos/disable-private-vulnerability-reporting)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// Get all custom property values for a repository
    ///
    /// Gets all custom property values that are set for a repository.
    /// Users with read access to the repository can use this endpoint.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/properties/values`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/get(repos/get-custom-properties-values)`.
    public enum ReposGetCustomPropertiesValues {
        public static let id: Swift.String = "repos/get-custom-properties-values"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetCustomPropertiesValues.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCustomPropertiesValues.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCustomPropertiesValues.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCustomPropertiesValues.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCustomPropertiesValues.Input.Path,
                headers: Operations.ReposGetCustomPropertiesValues.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.CustomPropertyValue])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.CustomPropertyValue] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCustomPropertiesValues.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCustomPropertiesValues.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/get(repos/get-custom-properties-values)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCustomPropertiesValues.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCustomPropertiesValues.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/get(repos/get-custom-properties-values)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/get(repos/get-custom-properties-values)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create or update custom property values for a repository
    ///
    /// Create new or update existing custom property values for a repository.
    /// Using a value of `null` for a custom property will remove or 'unset' the property value from the repository.
    ///
    /// Repository admins and other users with the repository-level "edit custom property values" fine-grained permission can use this endpoint.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/properties/values`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)`.
    public enum ReposCreateOrUpdateCustomPropertiesValues {
        public static let id: Swift.String = "repos/create-or-update-custom-properties-values"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrUpdateCustomPropertiesValues.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateOrUpdateCustomPropertiesValues.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// A list of custom property names and associated values to apply to the repositories.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/requestBody/json/properties`.
                    public var properties: [Components.Schemas.CustomPropertyValue]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - properties: A list of custom property names and associated values to apply to the repositories.
                    public init(properties: [Components.Schemas.CustomPropertyValue]) {
                        self.properties = properties
                    }
                    public enum CodingKeys: String, CodingKey {
                        case properties
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/properties/values/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Path,
                headers: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Headers = .init(),
                body: Operations.ReposCreateOrUpdateCustomPropertiesValues.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// No Content when custom property values are successfully created or updated
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposCreateOrUpdateCustomPropertiesValues.Output.NoContent)
            /// No Content when custom property values are successfully created or updated
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposCreateOrUpdateCustomPropertiesValues.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/properties/values/patch(repos/create-or-update-custom-properties-values)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a repository README
    ///
    /// Gets the preferred README for a repository.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
    /// - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/readme`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)`.
    public enum ReposGetReadme {
        public static let id: Swift.String = "repos/get-readme"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetReadme.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The name of the commit/branch/tag. Default: the repositorys default branch.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/query/ref`.
                public var ref: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - ref: The name of the commit/branch/tag. Default: the repositorys default branch.
                public init(ref: Swift.String? = nil) {
                    self.ref = ref
                }
            }
            public var query: Operations.ReposGetReadme.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReadme.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReadme.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetReadme.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetReadme.Input.Path,
                query: Operations.ReposGetReadme.Input.Query = .init(),
                headers: Operations.ReposGetReadme.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ContentFile)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ContentFile {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetReadme.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetReadme.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetReadme.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetReadme.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/get(repos/get-readme)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a repository README for a directory
    ///
    /// Gets the README from a repository directory.
    ///
    /// This endpoint supports the following custom media types. For more information, see "[Media types](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types)."
    ///
    /// - **`application/vnd.github.raw+json`**: Returns the raw file contents. This is the default if you do not specify a media type.
    /// - **`application/vnd.github.html+json`**: Returns the README in HTML. Markup languages are rendered to HTML using GitHub's open-source [Markup library](https://github.com/github/markup).
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/readme/{dir}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/{dir}/get(repos/get-readme-in-directory)`.
    public enum ReposGetReadmeInDirectory {
        public static let id: Swift.String = "repos/get-readme-in-directory"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The alternate path to look for a README file
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/path/dir`.
                public var dir: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - dir: The alternate path to look for a README file
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    dir: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.dir = dir
                }
            }
            public var path: Operations.ReposGetReadmeInDirectory.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The name of the commit/branch/tag. Default: the repositorys default branch.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/query/ref`.
                public var ref: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - ref: The name of the commit/branch/tag. Default: the repositorys default branch.
                public init(ref: Swift.String? = nil) {
                    self.ref = ref
                }
            }
            public var query: Operations.ReposGetReadmeInDirectory.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReadmeInDirectory.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReadmeInDirectory.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetReadmeInDirectory.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetReadmeInDirectory.Input.Path,
                query: Operations.ReposGetReadmeInDirectory.Input.Query = .init(),
                headers: Operations.ReposGetReadmeInDirectory.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/readme/{dir}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ContentFile)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ContentFile {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetReadmeInDirectory.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetReadmeInDirectory.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/{dir}/get(repos/get-readme-in-directory)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetReadmeInDirectory.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetReadmeInDirectory.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/{dir}/get(repos/get-readme-in-directory)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/readme/{dir}/get(repos/get-readme-in-directory)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List releases
    ///
    /// This returns a list of releases, which does not include regular Git tags that have not been associated with a release. To get a list of Git tags, use the [Repository Tags API](https://docs.github.com/rest/repos/repos#list-repository-tags).
    ///
    /// Information about published releases are available to everyone. Only users with push access will receive listings for draft releases.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)`.
    public enum ReposListReleases {
        public static let id: Swift.String = "repos/list-releases"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListReleases.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListReleases.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListReleases.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListReleases.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListReleases.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListReleases.Input.Path,
                query: Operations.ReposListReleases.Input.Query = .init(),
                headers: Operations.ReposListReleases.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListReleases.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Release])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Release] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListReleases.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListReleases.Output.Ok.Headers = .init(),
                    body: Operations.ReposListReleases.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListReleases.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListReleases.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/get(repos/list-releases)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a release
    ///
    /// Users with push access to the repository can create a release.
    ///
    /// This endpoint triggers [notifications](https://docs.github.com/github/managing-subscriptions-and-notifications-on-github/about-notifications). Creating content too quickly using this endpoint may result in secondary rate limiting. For more information, see "[Rate limits for the API](https://docs.github.com/rest/using-the-rest-api/rate-limits-for-the-rest-api#about-secondary-rate-limits)" and "[Best practices for using the REST API](https://docs.github.com/rest/guides/best-practices-for-using-the-rest-api)."
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)`.
    public enum ReposCreateRelease {
        public static let id: Swift.String = "repos/create-release"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateRelease.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateRelease.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateRelease.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateRelease.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the tag.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/tag_name`.
                    public var tagName: Swift.String
                    /// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/target_commitish`.
                    public var targetCommitish: Swift.String?
                    /// The name of the release.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/name`.
                    public var name: Swift.String?
                    /// Text describing the contents of the tag.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/body`.
                    public var body: Swift.String?
                    /// `true` to create a draft (unpublished) release, `false` to create a published one.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/draft`.
                    public var draft: Swift.Bool?
                    /// `true` to identify the release as a prerelease. `false` to identify the release as a full release.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/prerelease`.
                    public var prerelease: Swift.Bool?
                    /// If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/discussion_category_name`.
                    public var discussionCategoryName: Swift.String?
                    /// Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/generate_release_notes`.
                    public var generateReleaseNotes: Swift.Bool?
                    /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/make_latest`.
                    @frozen public enum MakeLatestPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case _true = "true"
                        case _false = "false"
                        case legacy = "legacy"
                    }
                    /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/json/make_latest`.
                    public var makeLatest: Operations.ReposCreateRelease.Input.Body.JsonPayload.MakeLatestPayload?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - tagName: The name of the tag.
                    ///   - targetCommitish: Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
                    ///   - name: The name of the release.
                    ///   - body: Text describing the contents of the tag.
                    ///   - draft: `true` to create a draft (unpublished) release, `false` to create a published one.
                    ///   - prerelease: `true` to identify the release as a prerelease. `false` to identify the release as a full release.
                    ///   - discussionCategoryName: If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
                    ///   - generateReleaseNotes: Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.
                    ///   - makeLatest: Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
                    public init(
                        tagName: Swift.String,
                        targetCommitish: Swift.String? = nil,
                        name: Swift.String? = nil,
                        body: Swift.String? = nil,
                        draft: Swift.Bool? = nil,
                        prerelease: Swift.Bool? = nil,
                        discussionCategoryName: Swift.String? = nil,
                        generateReleaseNotes: Swift.Bool? = nil,
                        makeLatest: Operations.ReposCreateRelease.Input.Body.JsonPayload.MakeLatestPayload? = nil
                    ) {
                        self.tagName = tagName
                        self.targetCommitish = targetCommitish
                        self.name = name
                        self.body = body
                        self.draft = draft
                        self.prerelease = prerelease
                        self.discussionCategoryName = discussionCategoryName
                        self.generateReleaseNotes = generateReleaseNotes
                        self.makeLatest = makeLatest
                    }
                    public enum CodingKeys: String, CodingKey {
                        case tagName = "tag_name"
                        case targetCommitish = "target_commitish"
                        case name
                        case body
                        case draft
                        case prerelease
                        case discussionCategoryName = "discussion_category_name"
                        case generateReleaseNotes = "generate_release_notes"
                        case makeLatest = "make_latest"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateRelease.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateRelease.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateRelease.Input.Path,
                headers: Operations.ReposCreateRelease.Input.Headers = .init(),
                body: Operations.ReposCreateRelease.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateRelease.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.Release)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Release {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateRelease.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateRelease.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateRelease.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateRelease.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateRelease.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/responses/404/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/POST/responses/404/content/application\/json`.
                    case json(Components.Schemas.BasicError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BasicError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateRelease.Output.NotFound.Body
                /// Creates a new `NotFound`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateRelease.Output.NotFound.Body) {
                    self.body = body
                }
            }
            /// Not Found if the discussion category name is invalid
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposCreateRelease.Output.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposCreateRelease.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/post(repos/create-release)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a release asset
    ///
    /// To download the asset's binary content:
    ///
    /// - If within a browser, fetch the location specified in the `browser_download_url` key provided in the response.
    /// - Alternatively, set the `Accept` header of the request to 
    ///   [`application/octet-stream`](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#media-types). 
    ///   The API will either redirect the client to the location, or stream it directly if possible.
    ///   API clients should handle both a `200` or `302` response.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/get(repos/get-release-asset)`.
    public enum ReposGetReleaseAsset {
        public static let id: Swift.String = "repos/get-release-asset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the asset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/GET/path/asset_id`.
                public var assetId: Components.Parameters.AssetId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - assetId: The unique identifier of the asset.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    assetId: Components.Parameters.AssetId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.assetId = assetId
                }
            }
            public var path: Operations.ReposGetReleaseAsset.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReleaseAsset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReleaseAsset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetReleaseAsset.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetReleaseAsset.Input.Path,
                headers: Operations.ReposGetReleaseAsset.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ReleaseAsset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ReleaseAsset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetReleaseAsset.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetReleaseAsset.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/get(repos/get-release-asset)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetReleaseAsset.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetReleaseAsset.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/get(repos/get-release-asset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/get(repos/get-release-asset)/responses/302`.
            ///
            /// HTTP response code: `302 found`.
            case found(Components.Responses.Found)
            /// Found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/get(repos/get-release-asset)/responses/302`.
            ///
            /// HTTP response code: `302 found`.
            public static var found: Self {
                .found(.init())
            }
            /// The associated value of the enum case if `self` is `.found`.
            ///
            /// - Throws: An error if `self` is not `.found`.
            /// - SeeAlso: `.found`.
            public var found: Components.Responses.Found {
                get throws {
                    switch self {
                    case let .found(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "found",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a release asset
    ///
    /// Users with push access to the repository can edit a release asset.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/patch(repos/update-release-asset)`.
    public enum ReposUpdateReleaseAsset {
        public static let id: Swift.String = "repos/update-release-asset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the asset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/path/asset_id`.
                public var assetId: Components.Parameters.AssetId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - assetId: The unique identifier of the asset.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    assetId: Components.Parameters.AssetId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.assetId = assetId
                }
            }
            public var path: Operations.ReposUpdateReleaseAsset.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateReleaseAsset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateReleaseAsset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateReleaseAsset.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The file name of the asset.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/requestBody/json/name`.
                    public var name: Swift.String?
                    /// An alternate short description of the asset. Used in place of the filename.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/requestBody/json/label`.
                    public var label: Swift.String?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/requestBody/json/state`.
                    public var state: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The file name of the asset.
                    ///   - label: An alternate short description of the asset. Used in place of the filename.
                    ///   - state:
                    public init(
                        name: Swift.String? = nil,
                        label: Swift.String? = nil,
                        state: Swift.String? = nil
                    ) {
                        self.name = name
                        self.label = label
                        self.state = state
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case label
                        case state
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateReleaseAsset.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateReleaseAsset.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateReleaseAsset.Input.Path,
                headers: Operations.ReposUpdateReleaseAsset.Input.Headers = .init(),
                body: Operations.ReposUpdateReleaseAsset.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.ReleaseAsset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ReleaseAsset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateReleaseAsset.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateReleaseAsset.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/patch(repos/update-release-asset)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateReleaseAsset.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateReleaseAsset.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a release asset
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/delete(repos/delete-release-asset)`.
    public enum ReposDeleteReleaseAsset {
        public static let id: Swift.String = "repos/delete-release-asset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the asset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/assets/{asset_id}/DELETE/path/asset_id`.
                public var assetId: Components.Parameters.AssetId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - assetId: The unique identifier of the asset.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    assetId: Components.Parameters.AssetId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.assetId = assetId
                }
            }
            public var path: Operations.ReposDeleteReleaseAsset.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDeleteReleaseAsset.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/delete(repos/delete-release-asset)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteReleaseAsset.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/assets/{asset_id}/delete(repos/delete-release-asset)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteReleaseAsset.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Generate release notes content for a release
    ///
    /// Generate a name and body describing a [release](https://docs.github.com/rest/releases/releases#get-a-release). The body content will be markdown formatted and contain information like the changes since last release and users who contributed. The generated release notes are not saved anywhere. They are intended to be generated and used when creating a new release.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases/generate-notes`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/generate-notes/post(repos/generate-release-notes)`.
    public enum ReposGenerateReleaseNotes {
        public static let id: Swift.String = "repos/generate-release-notes"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGenerateReleaseNotes.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGenerateReleaseNotes.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGenerateReleaseNotes.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGenerateReleaseNotes.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The tag name for the release. This can be an existing tag or a new one.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/requestBody/json/tag_name`.
                    public var tagName: Swift.String
                    /// Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/requestBody/json/target_commitish`.
                    public var targetCommitish: Swift.String?
                    /// The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/requestBody/json/previous_tag_name`.
                    public var previousTagName: Swift.String?
                    /// Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/requestBody/json/configuration_file_path`.
                    public var configurationFilePath: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - tagName: The tag name for the release. This can be an existing tag or a new one.
                    ///   - targetCommitish: Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists.
                    ///   - previousTagName: The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.
                    ///   - configurationFilePath: Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used.
                    public init(
                        tagName: Swift.String,
                        targetCommitish: Swift.String? = nil,
                        previousTagName: Swift.String? = nil,
                        configurationFilePath: Swift.String? = nil
                    ) {
                        self.tagName = tagName
                        self.targetCommitish = targetCommitish
                        self.previousTagName = previousTagName
                        self.configurationFilePath = configurationFilePath
                    }
                    public enum CodingKeys: String, CodingKey {
                        case tagName = "tag_name"
                        case targetCommitish = "target_commitish"
                        case previousTagName = "previous_tag_name"
                        case configurationFilePath = "configuration_file_path"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/requestBody/content/application\/json`.
                case json(Operations.ReposGenerateReleaseNotes.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposGenerateReleaseNotes.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposGenerateReleaseNotes.Input.Path,
                headers: Operations.ReposGenerateReleaseNotes.Input.Headers = .init(),
                body: Operations.ReposGenerateReleaseNotes.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/generate-notes/POST/responses/200/content/application\/json`.
                    case json(Components.Schemas.ReleaseNotesContent)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ReleaseNotesContent {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGenerateReleaseNotes.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGenerateReleaseNotes.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Name and body of generated release notes
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/generate-notes/post(repos/generate-release-notes)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGenerateReleaseNotes.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGenerateReleaseNotes.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/generate-notes/post(repos/generate-release-notes)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get the latest release
    ///
    /// View the latest published full release for the repository.
    ///
    /// The latest release is the most recent non-prerelease, non-draft release, sorted by the `created_at` attribute. The `created_at` attribute is the date of the commit used for the release, and not the date when the release was drafted or published.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/latest`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)`.
    public enum ReposGetLatestRelease {
        public static let id: Swift.String = "repos/get-latest-release"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/latest/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/latest/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/latest/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetLatestRelease.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/latest/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetLatestRelease.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetLatestRelease.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetLatestRelease.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetLatestRelease.Input.Path,
                headers: Operations.ReposGetLatestRelease.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/latest/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/latest/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Release)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Release {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetLatestRelease.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetLatestRelease.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/latest/get(repos/get-latest-release)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetLatestRelease.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetLatestRelease.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a release by tag name
    ///
    /// Get a published release with the specified tag.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/tags/{tag}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/tags/{tag}/get(repos/get-release-by-tag)`.
    public enum ReposGetReleaseByTag {
        public static let id: Swift.String = "repos/get-release-by-tag"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/tags/{tag}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/tags/{tag}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/tags/{tag}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// tag parameter
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/tags/{tag}/GET/path/tag`.
                public var tag: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - tag: tag parameter
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    tag: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.tag = tag
                }
            }
            public var path: Operations.ReposGetReleaseByTag.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/tags/{tag}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReleaseByTag.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetReleaseByTag.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetReleaseByTag.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetReleaseByTag.Input.Path,
                headers: Operations.ReposGetReleaseByTag.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/tags/{tag}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/tags/{tag}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Release)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Release {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetReleaseByTag.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetReleaseByTag.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/tags/{tag}/get(repos/get-release-by-tag)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetReleaseByTag.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetReleaseByTag.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/tags/{tag}/get(repos/get-release-by-tag)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a release
    ///
    /// Gets a public release with the specified release ID.
    ///
    /// > [!NOTE]
    /// > This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/get(repos/get-release)`.
    public enum ReposGetRelease {
        public static let id: Swift.String = "repos/get-release"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the release.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/GET/path/release_id`.
                public var releaseId: Components.Parameters.ReleaseId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - releaseId: The unique identifier of the release.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    releaseId: Components.Parameters.ReleaseId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.releaseId = releaseId
                }
            }
            public var path: Operations.ReposGetRelease.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRelease.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRelease.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetRelease.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetRelease.Input.Path,
                headers: Operations.ReposGetRelease.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Release)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Release {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetRelease.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetRelease.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// **Note:** This returns an `upload_url` key corresponding to the endpoint for uploading release assets. This key is a hypermedia resource. For more information, see "[Getting started with the REST API](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia)."
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/get(repos/get-release)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetRelease.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetRelease.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Unauthorized: Sendable, Hashable {
                /// Creates a new `Unauthorized`.
                public init() {}
            }
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/get(repos/get-release)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Operations.ReposGetRelease.Output.Unauthorized)
            /// Unauthorized
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/get(repos/get-release)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            public static var unauthorized: Self {
                .unauthorized(.init())
            }
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Operations.ReposGetRelease.Output.Unauthorized {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a release
    ///
    /// Users with push access to the repository can edit a release.
    ///
    /// - Remark: HTTP `PATCH /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/patch(repos/update-release)`.
    public enum ReposUpdateRelease {
        public static let id: Swift.String = "repos/update-release"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the release.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/path/release_id`.
                public var releaseId: Components.Parameters.ReleaseId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - releaseId: The unique identifier of the release.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    releaseId: Components.Parameters.ReleaseId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.releaseId = releaseId
                }
            }
            public var path: Operations.ReposUpdateRelease.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateRelease.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateRelease.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateRelease.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the tag.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/tag_name`.
                    public var tagName: Swift.String?
                    /// Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/target_commitish`.
                    public var targetCommitish: Swift.String?
                    /// The name of the release.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/name`.
                    public var name: Swift.String?
                    /// Text describing the contents of the tag.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/body`.
                    public var body: Swift.String?
                    /// `true` makes the release a draft, and `false` publishes the release.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/draft`.
                    public var draft: Swift.Bool?
                    /// `true` to identify the release as a prerelease, `false` to identify the release as a full release.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/prerelease`.
                    public var prerelease: Swift.Bool?
                    /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/make_latest`.
                    @frozen public enum MakeLatestPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case _true = "true"
                        case _false = "false"
                        case legacy = "legacy"
                    }
                    /// Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/make_latest`.
                    public var makeLatest: Operations.ReposUpdateRelease.Input.Body.JsonPayload.MakeLatestPayload?
                    /// If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/json/discussion_category_name`.
                    public var discussionCategoryName: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - tagName: The name of the tag.
                    ///   - targetCommitish: Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch.
                    ///   - name: The name of the release.
                    ///   - body: Text describing the contents of the tag.
                    ///   - draft: `true` makes the release a draft, and `false` publishes the release.
                    ///   - prerelease: `true` to identify the release as a prerelease, `false` to identify the release as a full release.
                    ///   - makeLatest: Specifies whether this release should be set as the latest release for the repository. Drafts and prereleases cannot be set as latest. Defaults to `true` for newly published releases. `legacy` specifies that the latest release should be determined based on the release creation date and higher semantic version.
                    ///   - discussionCategoryName: If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."
                    public init(
                        tagName: Swift.String? = nil,
                        targetCommitish: Swift.String? = nil,
                        name: Swift.String? = nil,
                        body: Swift.String? = nil,
                        draft: Swift.Bool? = nil,
                        prerelease: Swift.Bool? = nil,
                        makeLatest: Operations.ReposUpdateRelease.Input.Body.JsonPayload.MakeLatestPayload? = nil,
                        discussionCategoryName: Swift.String? = nil
                    ) {
                        self.tagName = tagName
                        self.targetCommitish = targetCommitish
                        self.name = name
                        self.body = body
                        self.draft = draft
                        self.prerelease = prerelease
                        self.makeLatest = makeLatest
                        self.discussionCategoryName = discussionCategoryName
                    }
                    public enum CodingKeys: String, CodingKey {
                        case tagName = "tag_name"
                        case targetCommitish = "target_commitish"
                        case name
                        case body
                        case draft
                        case prerelease
                        case makeLatest = "make_latest"
                        case discussionCategoryName = "discussion_category_name"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateRelease.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateRelease.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateRelease.Input.Path,
                headers: Operations.ReposUpdateRelease.Input.Headers = .init(),
                body: Operations.ReposUpdateRelease.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/responses/200/content/application\/json`.
                    case json(Components.Schemas.Release)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Release {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateRelease.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateRelease.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/patch(repos/update-release)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateRelease.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateRelease.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/responses/404/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/PATCH/responses/404/content/application\/json`.
                    case json(Components.Schemas.BasicError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.BasicError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateRelease.Output.NotFound.Body
                /// Creates a new `NotFound`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateRelease.Output.NotFound.Body) {
                    self.body = body
                }
            }
            /// Not Found if the discussion category name is invalid
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/patch(repos/update-release)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposUpdateRelease.Output.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposUpdateRelease.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a release
    ///
    /// Users with push access to the repository can delete a release.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/releases/{release_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/delete(repos/delete-release)`.
    public enum ReposDeleteRelease {
        public static let id: Swift.String = "repos/delete-release"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the release.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/DELETE/path/release_id`.
                public var releaseId: Components.Parameters.ReleaseId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - releaseId: The unique identifier of the release.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    releaseId: Components.Parameters.ReleaseId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.releaseId = releaseId
                }
            }
            public var path: Operations.ReposDeleteRelease.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDeleteRelease.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/delete(repos/delete-release)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteRelease.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/delete(repos/delete-release)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteRelease.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// List release assets
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/releases/{release_id}/assets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/get(repos/list-release-assets)`.
    public enum ReposListReleaseAssets {
        public static let id: Swift.String = "repos/list-release-assets"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the release.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/path/release_id`.
                public var releaseId: Components.Parameters.ReleaseId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - releaseId: The unique identifier of the release.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    releaseId: Components.Parameters.ReleaseId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.releaseId = releaseId
                }
            }
            public var path: Operations.ReposListReleaseAssets.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListReleaseAssets.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListReleaseAssets.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListReleaseAssets.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListReleaseAssets.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListReleaseAssets.Input.Path,
                query: Operations.ReposListReleaseAssets.Input.Query = .init(),
                headers: Operations.ReposListReleaseAssets.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListReleaseAssets.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.ReleaseAsset])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.ReleaseAsset] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListReleaseAssets.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListReleaseAssets.Output.Ok.Headers = .init(),
                    body: Operations.ReposListReleaseAssets.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/get(repos/list-release-assets)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListReleaseAssets.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListReleaseAssets.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Upload a release asset
    ///
    /// This endpoint makes use of a [Hypermedia relation](https://docs.github.com/rest/using-the-rest-api/getting-started-with-the-rest-api#hypermedia) to determine which URL to access. The endpoint you call to upload release assets is specific to your release. Use the `upload_url` returned in
    /// the response of the [Create a release endpoint](https://docs.github.com/rest/releases/releases#create-a-release) to upload a release asset.
    ///
    /// You need to use an HTTP client which supports [SNI](http://en.wikipedia.org/wiki/Server_Name_Indication) to make calls to this endpoint.
    ///
    /// Most libraries will set the required `Content-Length` header automatically. Use the required `Content-Type` header to provide the media type of the asset. For a list of media types, see [Media Types](https://www.iana.org/assignments/media-types/media-types.xhtml). For example: 
    ///
    /// `application/zip`
    ///
    /// GitHub expects the asset data in its raw binary form, rather than JSON. You will send the raw binary content of the asset as the request body. Everything else about the endpoint is the same as the rest of the API. For example,
    /// you'll still need to pass your authentication to be able to upload an asset.
    ///
    /// When an upstream failure occurs, you will receive a `502 Bad Gateway` status. This may leave an empty asset with a state of `starter`. It can be safely deleted.
    ///
    /// **Notes:**
    /// *   GitHub renames asset filenames that have special characters, non-alphanumeric characters, and leading or trailing periods. The "[List release assets](https://docs.github.com/rest/releases/assets#list-release-assets)"
    /// endpoint lists the renamed filenames. For more information and help, contact [GitHub Support](https://support.github.com/contact?tags=dotcom-rest-api).
    /// *   To find the `release_id` query the [`GET /repos/{owner}/{repo}/releases/latest` endpoint](https://docs.github.com/rest/releases/releases#get-the-latest-release). 
    /// *   If you upload an asset with the same filename as another uploaded asset, you'll receive an error and must delete the old file before you can re-upload the new asset.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/releases/{release_id}/assets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/post(repos/upload-release-asset)`.
    public enum ReposUploadReleaseAsset {
        public static let id: Swift.String = "repos/upload-release-asset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the release.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/path/release_id`.
                public var releaseId: Components.Parameters.ReleaseId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - releaseId: The unique identifier of the release.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    releaseId: Components.Parameters.ReleaseId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.releaseId = releaseId
                }
            }
            public var path: Operations.ReposUploadReleaseAsset.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/query/name`.
                public var name: Swift.String
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/query/label`.
                public var label: Swift.String?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - name:
                ///   - label:
                public init(
                    name: Swift.String,
                    label: Swift.String? = nil
                ) {
                    self.name = name
                    self.label = label
                }
            }
            public var query: Operations.ReposUploadReleaseAsset.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUploadReleaseAsset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUploadReleaseAsset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUploadReleaseAsset.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/requestBody/content/application\/octet-stream`.
                case binary(OpenAPIRuntime.HTTPBody)
            }
            public var body: Operations.ReposUploadReleaseAsset.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUploadReleaseAsset.Input.Path,
                query: Operations.ReposUploadReleaseAsset.Input.Query,
                headers: Operations.ReposUploadReleaseAsset.Input.Headers = .init(),
                body: Operations.ReposUploadReleaseAsset.Input.Body? = nil
            ) {
                self.path = path
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/releases/{release_id}/assets/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.ReleaseAsset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ReleaseAsset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUploadReleaseAsset.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUploadReleaseAsset.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response for successful upload
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/post(repos/upload-release-asset)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposUploadReleaseAsset.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposUploadReleaseAsset.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            public struct UnprocessableContent: Sendable, Hashable {
                /// Creates a new `UnprocessableContent`.
                public init() {}
            }
            /// Response if you upload an asset with the same filename as another uploaded asset
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/post(repos/upload-release-asset)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Operations.ReposUploadReleaseAsset.Output.UnprocessableContent)
            /// Response if you upload an asset with the same filename as another uploaded asset
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/releases/{release_id}/assets/post(repos/upload-release-asset)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            public static var unprocessableContent: Self {
                .unprocessableContent(.init())
            }
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Operations.ReposUploadReleaseAsset.Output.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get rules for a branch
    ///
    /// Returns all active rules that apply to the specified branch. The branch does not need to exist; rules that would apply
    /// to a branch with that name will be returned. All active rules that apply will be returned, regardless of the level
    /// at which they are configured (e.g. repository or organization). Rules in rulesets with "evaluate" or "disabled"
    /// enforcement statuses are not returned.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rules/branches/{branch}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rules/branches/{branch}/get(repos/get-branch-rules)`.
    public enum ReposGetBranchRules {
        public static let id: Swift.String = "repos/get-branch-rules"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/path/branch`.
                public var branch: Components.Parameters.Branch
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - branch: The name of the branch. Cannot contain wildcard characters. To use wildcard characters in branch names, use [the GraphQL API](https://docs.github.com/graphql).
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    branch: Components.Parameters.Branch
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.branch = branch
                }
            }
            public var path: Operations.ReposGetBranchRules.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposGetBranchRules.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetBranchRules.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetBranchRules.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetBranchRules.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetBranchRules.Input.Path,
                query: Operations.ReposGetBranchRules.Input.Query = .init(),
                headers: Operations.ReposGetBranchRules.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rules/branches/{branch}/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.RepositoryRuleDetailed])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.RepositoryRuleDetailed] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetBranchRules.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetBranchRules.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rules/branches/{branch}/get(repos/get-branch-rules)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetBranchRules.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetBranchRules.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get all repository rulesets
    ///
    /// Get all the rulesets for a repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/get(repos/get-repo-rulesets)`.
    public enum ReposGetRepoRulesets {
        public static let id: Swift.String = "repos/get-repo-rulesets"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetRepoRulesets.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Include rulesets configured at higher levels that apply to this repository
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/query/includes_parents`.
                public var includesParents: Swift.Bool?
                /// A comma-separated list of rule targets to filter by.
                /// If provided, only rulesets that apply to the specified targets will be returned.
                /// For example, `branch,tag,push`.
                ///
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/query/targets`.
                public var targets: Components.Parameters.RulesetTargets?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - includesParents: Include rulesets configured at higher levels that apply to this repository
                ///   - targets: A comma-separated list of rule targets to filter by.
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil,
                    includesParents: Swift.Bool? = nil,
                    targets: Components.Parameters.RulesetTargets? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                    self.includesParents = includesParents
                    self.targets = targets
                }
            }
            public var query: Operations.ReposGetRepoRulesets.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRulesets.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRulesets.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetRepoRulesets.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetRepoRulesets.Input.Path,
                query: Operations.ReposGetRepoRulesets.Input.Query = .init(),
                headers: Operations.ReposGetRepoRulesets.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.RepositoryRuleset])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.RepositoryRuleset] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetRepoRulesets.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetRepoRulesets.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/get(repos/get-repo-rulesets)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetRepoRulesets.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetRepoRulesets.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/get(repos/get-repo-rulesets)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/get(repos/get-repo-rulesets)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a repository ruleset
    ///
    /// Create a ruleset for a repository.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/rulesets`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/post(repos/create-repo-ruleset)`.
    public enum ReposCreateRepoRuleset {
        public static let id: Swift.String = "repos/create-repo-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateRepoRuleset.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateRepoRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateRepoRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateRepoRuleset.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json/name`.
                    public var name: Swift.String
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json/target`.
                    @frozen public enum TargetPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case branch = "branch"
                        case tag = "tag"
                        case push = "push"
                    }
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json/target`.
                    public var target: Operations.ReposCreateRepoRuleset.Input.Body.JsonPayload.TargetPayload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json/enforcement`.
                    public var enforcement: Components.Schemas.RepositoryRuleEnforcement
                    /// The actors that can bypass the rules in this ruleset
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json/bypass_actors`.
                    public var bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json/conditions`.
                    public var conditions: Components.Schemas.RepositoryRulesetConditions?
                    /// An array of rules within the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/json/rules`.
                    public var rules: [Components.Schemas.RepositoryRule]?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The name of the ruleset.
                    ///   - target: The target of the ruleset
                    ///   - enforcement:
                    ///   - bypassActors: The actors that can bypass the rules in this ruleset
                    ///   - conditions:
                    ///   - rules: An array of rules within the ruleset.
                    public init(
                        name: Swift.String,
                        target: Operations.ReposCreateRepoRuleset.Input.Body.JsonPayload.TargetPayload? = nil,
                        enforcement: Components.Schemas.RepositoryRuleEnforcement,
                        bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]? = nil,
                        conditions: Components.Schemas.RepositoryRulesetConditions? = nil,
                        rules: [Components.Schemas.RepositoryRule]? = nil
                    ) {
                        self.name = name
                        self.target = target
                        self.enforcement = enforcement
                        self.bypassActors = bypassActors
                        self.conditions = conditions
                        self.rules = rules
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case target
                        case enforcement
                        case bypassActors = "bypass_actors"
                        case conditions
                        case rules
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateRepoRuleset.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateRepoRuleset.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateRepoRuleset.Input.Path,
                headers: Operations.ReposCreateRepoRuleset.Input.Headers = .init(),
                body: Operations.ReposCreateRepoRuleset.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.RepositoryRuleset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryRuleset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateRepoRuleset.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateRepoRuleset.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/post(repos/create-repo-ruleset)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateRepoRuleset.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateRepoRuleset.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/post(repos/create-repo-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/post(repos/create-repo-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repository rule suites
    ///
    /// Lists suites of rule evaluations at the repository level.
    /// For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/rule-suites`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/get(repos/get-repo-rule-suites)`.
    public enum ReposGetRepoRuleSuites {
        public static let id: Swift.String = "repos/get-repo-rule-suites"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetRepoRuleSuites.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/query/ref`.
                public var ref: Components.Parameters.RefInQuery?
                /// - Remark: Generated from `#/components/parameters/time-period`.
                @frozen public enum TimePeriod: String, Codable, Hashable, Sendable, CaseIterable {
                    case hour = "hour"
                    case day = "day"
                    case week = "week"
                    case month = "month"
                }
                /// The time period to filter by.
                ///
                /// For example, `day` will filter for rule suites that occurred in the past 24 hours, and `week` will filter for insights that occurred in the past 7 days (168 hours).
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/query/time_period`.
                public var timePeriod: Components.Parameters.TimePeriod?
                /// The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/query/actor_name`.
                public var actorName: Components.Parameters.ActorNameInQuery?
                /// - Remark: Generated from `#/components/parameters/rule-suite-result`.
                @frozen public enum RuleSuiteResult: String, Codable, Hashable, Sendable, CaseIterable {
                    case pass = "pass"
                    case fail = "fail"
                    case bypass = "bypass"
                    case all = "all"
                }
                /// The rule results to filter on. When specified, only suites with this result will be returned.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/query/rule_suite_result`.
                public var ruleSuiteResult: Components.Parameters.RuleSuiteResult?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - ref: The name of the ref. Cannot contain wildcard characters. Optionally prefix with `refs/heads/` to limit to branches or `refs/tags/` to limit to tags. Omit the prefix to search across all refs. When specified, only rule evaluations triggered for this ref will be returned.
                ///   - timePeriod: The time period to filter by.
                ///   - actorName: The handle for the GitHub user account to filter on. When specified, only rule evaluations triggered by this actor will be returned.
                ///   - ruleSuiteResult: The rule results to filter on. When specified, only suites with this result will be returned.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    ref: Components.Parameters.RefInQuery? = nil,
                    timePeriod: Components.Parameters.TimePeriod? = nil,
                    actorName: Components.Parameters.ActorNameInQuery? = nil,
                    ruleSuiteResult: Components.Parameters.RuleSuiteResult? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.ref = ref
                    self.timePeriod = timePeriod
                    self.actorName = actorName
                    self.ruleSuiteResult = ruleSuiteResult
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposGetRepoRuleSuites.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRuleSuites.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRuleSuites.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetRepoRuleSuites.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetRepoRuleSuites.Input.Path,
                query: Operations.ReposGetRepoRuleSuites.Input.Query = .init(),
                headers: Operations.ReposGetRepoRuleSuites.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RuleSuites)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RuleSuites {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetRepoRuleSuites.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetRepoRuleSuites.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/get(repos/get-repo-rule-suites)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetRepoRuleSuites.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetRepoRuleSuites.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/get(repos/get-repo-rule-suites)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/get(repos/get-repo-rule-suites)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a repository rule suite
    ///
    /// Gets information about a suite of rule evaluations from within a repository.
    /// For more information, see "[Managing rulesets for a repository](https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-rulesets/managing-rulesets-for-a-repository#viewing-insights-for-rulesets)."
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-repo-rule-suite)`.
    public enum ReposGetRepoRuleSuite {
        public static let id: Swift.String = "repos/get-repo-rule-suite"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the rule suite result.
                /// To get this ID, you can use [GET /repos/{owner}/{repo}/rulesets/rule-suites](https://docs.github.com/rest/repos/rule-suites#list-repository-rule-suites)
                /// for repositories and [GET /orgs/{org}/rulesets/rule-suites](https://docs.github.com/rest/orgs/rule-suites#list-organization-rule-suites)
                /// for organizations.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/GET/path/rule_suite_id`.
                public var ruleSuiteId: Components.Parameters.RuleSuiteId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - ruleSuiteId: The unique identifier of the rule suite result.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    ruleSuiteId: Components.Parameters.RuleSuiteId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.ruleSuiteId = ruleSuiteId
                }
            }
            public var path: Operations.ReposGetRepoRuleSuite.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRuleSuite.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRuleSuite.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetRepoRuleSuite.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetRepoRuleSuite.Input.Path,
                headers: Operations.ReposGetRepoRuleSuite.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RuleSuite)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RuleSuite {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetRepoRuleSuite.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetRepoRuleSuite.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-repo-rule-suite)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetRepoRuleSuite.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetRepoRuleSuite.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-repo-rule-suite)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}/get(repos/get-repo-rule-suite)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get a repository ruleset
    ///
    /// Get a ruleset for a repository.
    ///
    /// **Note:** To prevent leaking sensitive information, the `bypass_actors` property is only returned if the user
    /// making the API request has write access to the ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/get(repos/get-repo-ruleset)`.
    public enum ReposGetRepoRuleset {
        public static let id: Swift.String = "repos/get-repo-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    rulesetId: Swift.Int
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.rulesetId = rulesetId
                }
            }
            public var path: Operations.ReposGetRepoRuleset.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/query`.
            public struct Query: Sendable, Hashable {
                /// Include rulesets configured at higher levels that apply to this repository
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/query/includes_parents`.
                public var includesParents: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - includesParents: Include rulesets configured at higher levels that apply to this repository
                public init(includesParents: Swift.Bool? = nil) {
                    self.includesParents = includesParents
                }
            }
            public var query: Operations.ReposGetRepoRuleset.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetRepoRuleset.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetRepoRuleset.Input.Path,
                query: Operations.ReposGetRepoRuleset.Input.Query = .init(),
                headers: Operations.ReposGetRepoRuleset.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RepositoryRuleset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryRuleset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetRepoRuleset.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetRepoRuleset.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/get(repos/get-repo-ruleset)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetRepoRuleset.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetRepoRuleset.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/get(repos/get-repo-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/get(repos/get-repo-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Update a repository ruleset
    ///
    /// Update a ruleset for a repository.
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/put(repos/update-repo-ruleset)`.
    public enum ReposUpdateRepoRuleset {
        public static let id: Swift.String = "repos/update-repo-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    rulesetId: Swift.Int
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.rulesetId = rulesetId
                }
            }
            public var path: Operations.ReposUpdateRepoRuleset.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateRepoRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposUpdateRepoRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposUpdateRepoRuleset.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json/name`.
                    public var name: Swift.String?
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json/target`.
                    @frozen public enum TargetPayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case branch = "branch"
                        case tag = "tag"
                        case push = "push"
                    }
                    /// The target of the ruleset
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json/target`.
                    public var target: Operations.ReposUpdateRepoRuleset.Input.Body.JsonPayload.TargetPayload?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json/enforcement`.
                    public var enforcement: Components.Schemas.RepositoryRuleEnforcement?
                    /// The actors that can bypass the rules in this ruleset
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json/bypass_actors`.
                    public var bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]?
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json/conditions`.
                    public var conditions: Components.Schemas.RepositoryRulesetConditions?
                    /// An array of rules within the ruleset.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/json/rules`.
                    public var rules: [Components.Schemas.RepositoryRule]?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The name of the ruleset.
                    ///   - target: The target of the ruleset
                    ///   - enforcement:
                    ///   - bypassActors: The actors that can bypass the rules in this ruleset
                    ///   - conditions:
                    ///   - rules: An array of rules within the ruleset.
                    public init(
                        name: Swift.String? = nil,
                        target: Operations.ReposUpdateRepoRuleset.Input.Body.JsonPayload.TargetPayload? = nil,
                        enforcement: Components.Schemas.RepositoryRuleEnforcement? = nil,
                        bypassActors: [Components.Schemas.RepositoryRulesetBypassActor]? = nil,
                        conditions: Components.Schemas.RepositoryRulesetConditions? = nil,
                        rules: [Components.Schemas.RepositoryRule]? = nil
                    ) {
                        self.name = name
                        self.target = target
                        self.enforcement = enforcement
                        self.bypassActors = bypassActors
                        self.conditions = conditions
                        self.rules = rules
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case target
                        case enforcement
                        case bypassActors = "bypass_actors"
                        case conditions
                        case rules
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposUpdateRepoRuleset.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposUpdateRepoRuleset.Input.Body?
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposUpdateRepoRuleset.Input.Path,
                headers: Operations.ReposUpdateRepoRuleset.Input.Headers = .init(),
                body: Operations.ReposUpdateRepoRuleset.Input.Body? = nil
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/PUT/responses/200/content/application\/json`.
                    case json(Components.Schemas.RepositoryRuleset)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RepositoryRuleset {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposUpdateRepoRuleset.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposUpdateRepoRuleset.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/put(repos/update-repo-ruleset)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposUpdateRepoRuleset.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposUpdateRepoRuleset.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/put(repos/update-repo-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/put(repos/update-repo-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Delete a repository ruleset
    ///
    /// Delete a ruleset for a repository.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/delete(repos/delete-repo-ruleset)`.
    public enum ReposDeleteRepoRuleset {
        public static let id: Swift.String = "repos/delete-repo-ruleset"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/DELETE/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    rulesetId: Swift.Int
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.rulesetId = rulesetId
                }
            }
            public var path: Operations.ReposDeleteRepoRuleset.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteRepoRuleset.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteRepoRuleset.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteRepoRuleset.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteRepoRuleset.Input.Path,
                headers: Operations.ReposDeleteRepoRuleset.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/delete(repos/delete-repo-ruleset)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteRepoRuleset.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/delete(repos/delete-repo-ruleset)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteRepoRuleset.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/delete(repos/delete-repo-ruleset)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/delete(repos/delete-repo-ruleset)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get repository ruleset history
    ///
    /// Get the history of a repository ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/get(repos/get-repo-ruleset-history)`.
    public enum ReposGetRepoRulesetHistory {
        public static let id: Swift.String = "repos/get-repo-ruleset-history"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    rulesetId: Swift.Int
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.rulesetId = rulesetId
                }
            }
            public var path: Operations.ReposGetRepoRulesetHistory.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposGetRepoRulesetHistory.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRulesetHistory.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRulesetHistory.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetRepoRulesetHistory.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetRepoRulesetHistory.Input.Path,
                query: Operations.ReposGetRepoRulesetHistory.Input.Query = .init(),
                headers: Operations.ReposGetRepoRulesetHistory.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.RulesetVersion])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.RulesetVersion] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetRepoRulesetHistory.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetRepoRulesetHistory.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/get(repos/get-repo-ruleset-history)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetRepoRulesetHistory.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetRepoRulesetHistory.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/get(repos/get-repo-ruleset-history)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/get(repos/get-repo-ruleset-history)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get repository ruleset version
    ///
    /// Get a version of a repository ruleset.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/get(repos/get-repo-ruleset-version)`.
    public enum ReposGetRepoRulesetVersion {
        public static let id: Swift.String = "repos/get-repo-ruleset-version"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The ID of the ruleset.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/path/ruleset_id`.
                public var rulesetId: Swift.Int
                /// The ID of the version
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/path/version_id`.
                public var versionId: Swift.Int
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - rulesetId: The ID of the ruleset.
                ///   - versionId: The ID of the version
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    rulesetId: Swift.Int,
                    versionId: Swift.Int
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.rulesetId = rulesetId
                    self.versionId = versionId
                }
            }
            public var path: Operations.ReposGetRepoRulesetVersion.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRulesetVersion.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetRepoRulesetVersion.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetRepoRulesetVersion.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetRepoRulesetVersion.Input.Path,
                headers: Operations.ReposGetRepoRulesetVersion.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.RulesetVersionWithState)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.RulesetVersionWithState {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetRepoRulesetVersion.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetRepoRulesetVersion.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/get(repos/get-repo-ruleset-version)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetRepoRulesetVersion.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetRepoRulesetVersion.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/get(repos/get-repo-ruleset-version)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Internal Error
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/rulesets/{ruleset_id}/history/{version_id}/get(repos/get-repo-ruleset-version)/responses/500`.
            ///
            /// HTTP response code: `500 internalServerError`.
            case internalServerError(Components.Responses.InternalError)
            /// The associated value of the enum case if `self` is `.internalServerError`.
            ///
            /// - Throws: An error if `self` is not `.internalServerError`.
            /// - SeeAlso: `.internalServerError`.
            public var internalServerError: Components.Responses.InternalError {
                get throws {
                    switch self {
                    case let .internalServerError(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "internalServerError",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get the weekly commit activity
    ///
    /// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
    ///
    /// > [!NOTE]
    /// > This endpoint can only be used for repositories with fewer than 10,000 commits. If the repository contains 10,000 or more commits, a 422 status code will be returned.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/code_frequency`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)`.
    public enum ReposGetCodeFrequencyStats {
        public static let id: Swift.String = "repos/get-code-frequency-stats"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/code_frequency/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/code_frequency/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/code_frequency/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetCodeFrequencyStats.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/code_frequency/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCodeFrequencyStats.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCodeFrequencyStats.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCodeFrequencyStats.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCodeFrequencyStats.Input.Path,
                headers: Operations.ReposGetCodeFrequencyStats.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/code_frequency/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/code_frequency/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.CodeFrequencyStat])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.CodeFrequencyStat] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCodeFrequencyStats.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCodeFrequencyStats.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Returns a weekly aggregate of the number of additions and deletions pushed to a repository.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCodeFrequencyStats.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCodeFrequencyStats.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Accepted
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Components.Responses.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Components.Responses.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Components.Responses.NoContent)
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Components.Responses.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            public struct UnprocessableContent: Sendable, Hashable {
                /// Creates a new `UnprocessableContent`.
                public init() {}
            }
            /// Repository contains more than 10,000 commits
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Operations.ReposGetCodeFrequencyStats.Output.UnprocessableContent)
            /// Repository contains more than 10,000 commits
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/code_frequency/get(repos/get-code-frequency-stats)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            public static var unprocessableContent: Self {
                .unprocessableContent(.init())
            }
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Operations.ReposGetCodeFrequencyStats.Output.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get the last year of commit activity
    ///
    /// Returns the last year of commit activity grouped by week. The `days` array is a group of commits per day, starting on `Sunday`.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/commit_activity`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/commit_activity/get(repos/get-commit-activity-stats)`.
    public enum ReposGetCommitActivityStats {
        public static let id: Swift.String = "repos/get-commit-activity-stats"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/commit_activity/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/commit_activity/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/commit_activity/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetCommitActivityStats.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/commit_activity/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommitActivityStats.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetCommitActivityStats.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetCommitActivityStats.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetCommitActivityStats.Input.Path,
                headers: Operations.ReposGetCommitActivityStats.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/commit_activity/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/commit_activity/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.CommitActivity])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.CommitActivity] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetCommitActivityStats.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetCommitActivityStats.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/commit_activity/get(repos/get-commit-activity-stats)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetCommitActivityStats.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetCommitActivityStats.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Accepted
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/commit_activity/get(repos/get-commit-activity-stats)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Components.Responses.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Components.Responses.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/commit_activity/get(repos/get-commit-activity-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Components.Responses.NoContent)
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/commit_activity/get(repos/get-commit-activity-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Components.Responses.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get all contributor commit activity
    ///
    ///
    /// Returns the `total` number of commits authored by the contributor. In addition, the response includes a Weekly Hash (`weeks` array) with the following information:
    ///
    /// *   `w` - Start of the week, given as a [Unix timestamp](https://en.wikipedia.org/wiki/Unix_time).
    /// *   `a` - Number of additions
    /// *   `d` - Number of deletions
    /// *   `c` - Number of commits
    ///
    /// > [!NOTE]
    /// > This endpoint will return `0` values for all addition and deletion counts in repositories with 10,000 or more commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/contributors`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/contributors/get(repos/get-contributors-stats)`.
    public enum ReposGetContributorsStats {
        public static let id: Swift.String = "repos/get-contributors-stats"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/contributors/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/contributors/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/contributors/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetContributorsStats.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/contributors/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetContributorsStats.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetContributorsStats.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetContributorsStats.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetContributorsStats.Input.Path,
                headers: Operations.ReposGetContributorsStats.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/contributors/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/contributors/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.ContributorActivity])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.ContributorActivity] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetContributorsStats.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetContributorsStats.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/contributors/get(repos/get-contributors-stats)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetContributorsStats.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetContributorsStats.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Accepted
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/contributors/get(repos/get-contributors-stats)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Components.Responses.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Components.Responses.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/contributors/get(repos/get-contributors-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Components.Responses.NoContent)
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/contributors/get(repos/get-contributors-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Components.Responses.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get the weekly commit count
    ///
    /// Returns the total commit counts for the `owner` and total commit counts in `all`. `all` is everyone combined, including the `owner` in the last 52 weeks. If you'd like to get the commit counts for non-owners, you can subtract `owner` from `all`.
    ///
    /// The array order is oldest week (index 0) to most recent week.
    ///
    /// The most recent week is seven days ago at UTC midnight to today at UTC midnight.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/participation`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/participation/get(repos/get-participation-stats)`.
    public enum ReposGetParticipationStats {
        public static let id: Swift.String = "repos/get-participation-stats"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/participation/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/participation/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/participation/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetParticipationStats.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/participation/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetParticipationStats.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetParticipationStats.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetParticipationStats.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetParticipationStats.Input.Path,
                headers: Operations.ReposGetParticipationStats.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/participation/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/participation/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ParticipationStats)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ParticipationStats {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetParticipationStats.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetParticipationStats.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// The array order is oldest week (index 0) to most recent week.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/participation/get(repos/get-participation-stats)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetParticipationStats.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetParticipationStats.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/participation/get(repos/get-participation-stats)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get the hourly commit count for each day
    ///
    /// Each array contains the day number, hour number, and number of commits:
    ///
    /// *   `0-6`: Sunday - Saturday
    /// *   `0-23`: Hour of day
    /// *   Number of commits
    ///
    /// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/stats/punch_card`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/punch_card/get(repos/get-punch-card-stats)`.
    public enum ReposGetPunchCardStats {
        public static let id: Swift.String = "repos/get-punch-card-stats"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/punch_card/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/punch_card/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/punch_card/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetPunchCardStats.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/punch_card/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPunchCardStats.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetPunchCardStats.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetPunchCardStats.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetPunchCardStats.Input.Path,
                headers: Operations.ReposGetPunchCardStats.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/punch_card/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/stats/punch_card/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.CodeFrequencyStat])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.CodeFrequencyStat] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetPunchCardStats.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetPunchCardStats.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// For example, `[2, 14, 25]` indicates that there were 25 total commits, during the 2:00pm hour on Tuesdays. All times are based on the time zone of individual commits.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/punch_card/get(repos/get-punch-card-stats)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetPunchCardStats.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetPunchCardStats.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/punch_card/get(repos/get-punch-card-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Components.Responses.NoContent)
            /// A header with no content is returned.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/stats/punch_card/get(repos/get-punch-card-stats)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Components.Responses.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a commit status
    ///
    /// Users with push access in a repository can create commit statuses for a given SHA.
    ///
    /// Note: there is a limit of 1000 statuses per `sha` and `context` within a repository. Attempts to create more than 1000 statuses will result in a validation error.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/statuses/{sha}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/statuses/{sha}/post(repos/create-commit-status)`.
    public enum ReposCreateCommitStatus {
        public static let id: Swift.String = "repos/create-commit-status"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/path/sha`.
                public var sha: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - sha:
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    sha: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.sha = sha
                }
            }
            public var path: Operations.ReposCreateCommitStatus.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateCommitStatus.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateCommitStatus.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateCommitStatus.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The state of the status.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody/json/state`.
                    @frozen public enum StatePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case error = "error"
                        case failure = "failure"
                        case pending = "pending"
                        case success = "success"
                    }
                    /// The state of the status.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody/json/state`.
                    public var state: Operations.ReposCreateCommitStatus.Input.Body.JsonPayload.StatePayload
                    /// The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  
                    /// For example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  
                    /// `http://ci.example.com/user/repo/build/sha`
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody/json/target_url`.
                    public var targetUrl: Swift.String?
                    /// A short description of the status.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody/json/description`.
                    public var description: Swift.String?
                    /// A string label to differentiate this status from the status of other systems. This field is case-insensitive.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody/json/context`.
                    public var context: Swift.String?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - state: The state of the status.
                    ///   - targetUrl: The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  
                    ///   - description: A short description of the status.
                    ///   - context: A string label to differentiate this status from the status of other systems. This field is case-insensitive.
                    public init(
                        state: Operations.ReposCreateCommitStatus.Input.Body.JsonPayload.StatePayload,
                        targetUrl: Swift.String? = nil,
                        description: Swift.String? = nil,
                        context: Swift.String? = nil
                    ) {
                        self.state = state
                        self.targetUrl = targetUrl
                        self.description = description
                        self.context = context
                    }
                    public enum CodingKeys: String, CodingKey {
                        case state
                        case targetUrl = "target_url"
                        case description
                        case context
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateCommitStatus.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateCommitStatus.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateCommitStatus.Input.Path,
                headers: Operations.ReposCreateCommitStatus.Input.Headers = .init(),
                body: Operations.ReposCreateCommitStatus.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateCommitStatus.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/statuses/{sha}/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.Status)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Status {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateCommitStatus.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateCommitStatus.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateCommitStatus.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/statuses/{sha}/post(repos/create-commit-status)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateCommitStatus.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateCommitStatus.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repository tags
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/get(repos/list-tags)`.
    public enum ReposListTags {
        public static let id: Swift.String = "repos/list-tags"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListTags.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListTags.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListTags.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListTags.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListTags.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListTags.Input.Path,
                query: Operations.ReposListTags.Input.Query = .init(),
                headers: Operations.ReposListTags.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListTags.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Tag])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Tag] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListTags.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListTags.Output.Ok.Headers = .init(),
                    body: Operations.ReposListTags.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/get(repos/list-tags)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListTags.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListTags.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Closing down - List tag protection states for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#get-all-repository-rulesets)" endpoint instead.
    ///
    /// This returns the tag protection states of a repository.
    ///
    /// This information is only available to repository administrators.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tags/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/get(repos/list-tag-protection)`.
    public enum ReposListTagProtection {
        public static let id: Swift.String = "repos/list-tag-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListTagProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListTagProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListTagProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListTagProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposListTagProtection.Input.Path,
                headers: Operations.ReposListTagProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.TagProtection])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.TagProtection] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListTagProtection.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposListTagProtection.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/get(repos/list-tag-protection)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListTagProtection.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListTagProtection.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/get(repos/list-tag-protection)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/get(repos/list-tag-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Closing down - Create a tag protection state for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#create-a-repository-ruleset)" endpoint instead.
    ///
    /// This creates a tag protection state for a repository.
    /// This endpoint is only available to repository administrators.
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/tags/protection`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/post(repos/create-tag-protection)`.
    public enum ReposCreateTagProtection {
        public static let id: Swift.String = "repos/create-tag-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCreateTagProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateTagProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateTagProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateTagProtection.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// An optional glob pattern to match against when enforcing tag protection.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/requestBody/json/pattern`.
                    public var pattern: Swift.String
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - pattern: An optional glob pattern to match against when enforcing tag protection.
                    public init(pattern: Swift.String) {
                        self.pattern = pattern
                    }
                    public enum CodingKeys: String, CodingKey {
                        case pattern
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateTagProtection.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateTagProtection.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateTagProtection.Input.Path,
                headers: Operations.ReposCreateTagProtection.Input.Headers = .init(),
                body: Operations.ReposCreateTagProtection.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.TagProtection)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.TagProtection {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateTagProtection.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposCreateTagProtection.Output.Created.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/post(repos/create-tag-protection)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateTagProtection.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateTagProtection.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/post(repos/create-tag-protection)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/post(repos/create-tag-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Closing down - Delete a tag protection state for a repository
    ///
    /// > [!WARNING]
    /// > **Closing down notice:** This operation is closing down and will be removed after August 30, 2024. Use the "[Repository Rulesets](https://docs.github.com/rest/repos/rules#delete-a-repository-ruleset)" endpoint instead.
    ///
    /// This deletes a tag protection state for a repository.
    /// This endpoint is only available to repository administrators.
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/{tag_protection_id}/delete(repos/delete-tag-protection)`.
    public enum ReposDeleteTagProtection {
        public static let id: Swift.String = "repos/delete-tag-protection"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/{tag_protection_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/{tag_protection_id}/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/{tag_protection_id}/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// The unique identifier of the tag protection.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/{tag_protection_id}/DELETE/path/tag_protection_id`.
                public var tagProtectionId: Components.Parameters.TagProtectionId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - tagProtectionId: The unique identifier of the tag protection.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    tagProtectionId: Components.Parameters.TagProtectionId
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.tagProtectionId = tagProtectionId
                }
            }
            public var path: Operations.ReposDeleteTagProtection.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tags/protection/{tag_protection_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteTagProtection.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeleteTagProtection.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeleteTagProtection.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeleteTagProtection.Input.Path,
                headers: Operations.ReposDeleteTagProtection.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/{tag_protection_id}/delete(repos/delete-tag-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeleteTagProtection.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/{tag_protection_id}/delete(repos/delete-tag-protection)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeleteTagProtection.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/{tag_protection_id}/delete(repos/delete-tag-protection)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tags/protection/{tag_protection_id}/delete(repos/delete-tag-protection)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Download a repository archive (tar)
    ///
    /// Gets a redirect URL to download a tar archive for a repository. If you omit `:ref`, the repositorys default branch (usually
    /// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    /// the `Location` header to make a second `GET` request.
    ///
    /// > [!NOTE]
    /// > For private repositories, these links are temporary and expire after five minutes.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/tarball/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tarball/{ref}/get(repos/download-tarball-archive)`.
    public enum ReposDownloadTarballArchive {
        public static let id: Swift.String = "repos/download-tarball-archive"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tarball/{ref}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tarball/{ref}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tarball/{ref}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tarball/{ref}/GET/path/ref`.
                public var ref: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - ref:
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    ref: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.ref = ref
                }
            }
            public var path: Operations.ReposDownloadTarballArchive.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDownloadTarballArchive.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Found: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tarball/{ref}/GET/responses/302/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/tarball/{ref}/GET/responses/302/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposDownloadTarballArchive.Output.Found.Headers
                /// Creates a new `Found`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                public init(headers: Operations.ReposDownloadTarballArchive.Output.Found.Headers = .init()) {
                    self.headers = headers
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/tarball/{ref}/get(repos/download-tarball-archive)/responses/302`.
            ///
            /// HTTP response code: `302 found`.
            case found(Operations.ReposDownloadTarballArchive.Output.Found)
            /// The associated value of the enum case if `self` is `.found`.
            ///
            /// - Throws: An error if `self` is not `.found`.
            /// - SeeAlso: `.found`.
            public var found: Operations.ReposDownloadTarballArchive.Output.Found {
                get throws {
                    switch self {
                    case let .found(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "found",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// List repository teams
    ///
    /// Lists the teams that have access to the specified repository and that are also visible to the authenticated user.
    ///
    /// For a public repository, a team is listed only if that team added the public repository explicitly.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to use this endpoint with a public repository, and `repo` scope to use this endpoint with a private repository.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/teams`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/teams/get(repos/list-teams)`.
    public enum ReposListTeams {
        public static let id: Swift.String = "repos/list-teams"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposListTeams.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListTeams.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListTeams.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListTeams.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListTeams.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListTeams.Input.Path,
                query: Operations.ReposListTeams.Input.Query = .init(),
                headers: Operations.ReposListTeams.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListTeams.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/teams/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Team])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Team] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListTeams.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListTeams.Output.Ok.Headers = .init(),
                    body: Operations.ReposListTeams.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/teams/get(repos/list-teams)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListTeams.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListTeams.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/teams/get(repos/list-teams)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get all repository topics
    ///
    ///
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/topics`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/get(repos/get-all-topics)`.
    public enum ReposGetAllTopics {
        public static let id: Swift.String = "repos/get-all-topics"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetAllTopics.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    page: Components.Parameters.Page? = nil,
                    perPage: Components.Parameters.PerPage? = nil
                ) {
                    self.page = page
                    self.perPage = perPage
                }
            }
            public var query: Operations.ReposGetAllTopics.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllTopics.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetAllTopics.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetAllTopics.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetAllTopics.Input.Path,
                query: Operations.ReposGetAllTopics.Input.Query = .init(),
                headers: Operations.ReposGetAllTopics.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.Topic)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Topic {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetAllTopics.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetAllTopics.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/get(repos/get-all-topics)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetAllTopics.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetAllTopics.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/get(repos/get-all-topics)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Replace all repository topics
    ///
    ///
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/topics`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/put(repos/replace-all-topics)`.
    public enum ReposReplaceAllTopics {
        public static let id: Swift.String = "repos/replace-all-topics"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposReplaceAllTopics.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposReplaceAllTopics.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposReplaceAllTopics.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposReplaceAllTopics.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/requestBody/json/names`.
                    public var names: [Swift.String]
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - names: An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` will be saved as lowercase.
                    public init(names: [Swift.String]) {
                        self.names = names
                    }
                    public enum CodingKeys: String, CodingKey {
                        case names
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/requestBody/content/application\/json`.
                case json(Operations.ReposReplaceAllTopics.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposReplaceAllTopics.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposReplaceAllTopics.Input.Path,
                headers: Operations.ReposReplaceAllTopics.Input.Headers = .init(),
                body: Operations.ReposReplaceAllTopics.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/topics/PUT/responses/200/content/application\/json`.
                    case json(Components.Schemas.Topic)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.Topic {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposReplaceAllTopics.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposReplaceAllTopics.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/put(repos/replace-all-topics)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposReplaceAllTopics.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposReplaceAllTopics.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/put(repos/replace-all-topics)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/topics/put(repos/replace-all-topics)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailedSimple)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailedSimple {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get repository clones
    ///
    /// Get the total number of clones and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/clones`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/clones/get(repos/get-clones)`.
    public enum ReposGetClones {
        public static let id: Swift.String = "repos/get-clones"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetClones.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/per`.
                @frozen public enum Per: String, Codable, Hashable, Sendable, CaseIterable {
                    case day = "day"
                    case week = "week"
                }
                /// The time frame to display results for.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/query/per`.
                public var per: Components.Parameters.Per?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - per: The time frame to display results for.
                public init(per: Components.Parameters.Per? = nil) {
                    self.per = per
                }
            }
            public var query: Operations.ReposGetClones.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetClones.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetClones.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetClones.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetClones.Input.Path,
                query: Operations.ReposGetClones.Input.Query = .init(),
                headers: Operations.ReposGetClones.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/clones/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.CloneTraffic)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.CloneTraffic {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetClones.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetClones.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/clones/get(repos/get-clones)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetClones.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetClones.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/clones/get(repos/get-clones)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get top referral paths
    ///
    /// Get the top 10 popular contents over the last 14 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/popular/paths`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/paths/get(repos/get-top-paths)`.
    public enum ReposGetTopPaths {
        public static let id: Swift.String = "repos/get-top-paths"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/paths/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/paths/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/paths/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetTopPaths.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/paths/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetTopPaths.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetTopPaths.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetTopPaths.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetTopPaths.Input.Path,
                headers: Operations.ReposGetTopPaths.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/paths/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/paths/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.ContentTraffic])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.ContentTraffic] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetTopPaths.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetTopPaths.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/paths/get(repos/get-top-paths)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetTopPaths.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetTopPaths.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/paths/get(repos/get-top-paths)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get top referral sources
    ///
    /// Get the top 10 referrers over the last 14 days.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/popular/referrers`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/referrers/get(repos/get-top-referrers)`.
    public enum ReposGetTopReferrers {
        public static let id: Swift.String = "repos/get-top-referrers"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/referrers/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/referrers/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/referrers/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetTopReferrers.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/referrers/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetTopReferrers.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetTopReferrers.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetTopReferrers.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposGetTopReferrers.Input.Path,
                headers: Operations.ReposGetTopReferrers.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/referrers/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/popular/referrers/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.ReferrerTraffic])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.ReferrerTraffic] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetTopReferrers.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetTopReferrers.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/referrers/get(repos/get-top-referrers)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetTopReferrers.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetTopReferrers.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/popular/referrers/get(repos/get-top-referrers)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Get page views
    ///
    /// Get the total number of views and breakdown per day or week for the last 14 days. Timestamps are aligned to UTC midnight of the beginning of the day or week. Week begins on Monday.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/traffic/views`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/views/get(repos/get-views)`.
    public enum ReposGetViews {
        public static let id: Swift.String = "repos/get-views"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposGetViews.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/components/parameters/per`.
                @frozen public enum Per: String, Codable, Hashable, Sendable, CaseIterable {
                    case day = "day"
                    case week = "week"
                }
                /// The time frame to display results for.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/query/per`.
                public var per: Components.Parameters.Per?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - per: The time frame to display results for.
                public init(per: Components.Parameters.Per? = nil) {
                    self.per = per
                }
            }
            public var query: Operations.ReposGetViews.Input.Query
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetViews.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposGetViews.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposGetViews.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposGetViews.Input.Path,
                query: Operations.ReposGetViews.Input.Query = .init(),
                headers: Operations.ReposGetViews.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/traffic/views/GET/responses/200/content/application\/json`.
                    case json(Components.Schemas.ViewTraffic)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.ViewTraffic {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposGetViews.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposGetViews.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/views/get(repos/get-views)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposGetViews.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposGetViews.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/traffic/views/get(repos/get-views)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Transfer a repository
    ///
    /// A transfer request will need to be accepted by the new owner when transferring a personal repository to another user. The response will contain the original `owner`, and the transfer will continue asynchronously. For more details on the requirements to transfer personal and organization-owned repositories, see [about repository transfers](https://docs.github.com/articles/about-repository-transfers/).
    ///
    /// - Remark: HTTP `POST /repos/{owner}/{repo}/transfer`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/transfer/post(repos/transfer)`.
    public enum ReposTransfer {
        public static let id: Swift.String = "repos/transfer"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposTransfer.Input.Path
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposTransfer.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposTransfer.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposTransfer.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The username or organization name the repository will be transferred to.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/requestBody/json/new_owner`.
                    public var newOwner: Swift.String
                    /// The new name to be given to the repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/requestBody/json/new_name`.
                    public var newName: Swift.String?
                    /// ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/requestBody/json/team_ids`.
                    public var teamIds: [Swift.Int]?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - newOwner: The username or organization name the repository will be transferred to.
                    ///   - newName: The new name to be given to the repository.
                    ///   - teamIds: ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.
                    public init(
                        newOwner: Swift.String,
                        newName: Swift.String? = nil,
                        teamIds: [Swift.Int]? = nil
                    ) {
                        self.newOwner = newOwner
                        self.newName = newName
                        self.teamIds = teamIds
                    }
                    public enum CodingKeys: String, CodingKey {
                        case newOwner = "new_owner"
                        case newName = "new_name"
                        case teamIds = "team_ids"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/requestBody/content/application\/json`.
                case json(Operations.ReposTransfer.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposTransfer.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposTransfer.Input.Path,
                headers: Operations.ReposTransfer.Input.Headers = .init(),
                body: Operations.ReposTransfer.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Accepted: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/responses/202/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/transfer/POST/responses/202/content/application\/json`.
                    case json(Components.Schemas.MinimalRepository)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.MinimalRepository {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposTransfer.Output.Accepted.Body
                /// Creates a new `Accepted`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.ReposTransfer.Output.Accepted.Body) {
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/transfer/post(repos/transfer)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Operations.ReposTransfer.Output.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Operations.ReposTransfer.Output.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Check if vulnerability alerts are enabled for a repository
    ///
    /// Shows whether dependency alerts are enabled or disabled for a repository. The authenticated user must have admin read access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/get(repos/check-vulnerability-alerts)`.
    public enum ReposCheckVulnerabilityAlerts {
        public static let id: Swift.String = "repos/check-vulnerability-alerts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposCheckVulnerabilityAlerts.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposCheckVulnerabilityAlerts.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response if repository is enabled with vulnerability alerts
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/get(repos/check-vulnerability-alerts)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposCheckVulnerabilityAlerts.Output.NoContent)
            /// Response if repository is enabled with vulnerability alerts
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/get(repos/check-vulnerability-alerts)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposCheckVulnerabilityAlerts.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            public struct NotFound: Sendable, Hashable {
                /// Creates a new `NotFound`.
                public init() {}
            }
            /// Not Found if repository is not enabled with vulnerability alerts
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/get(repos/check-vulnerability-alerts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Operations.ReposCheckVulnerabilityAlerts.Output.NotFound)
            /// Not Found if repository is not enabled with vulnerability alerts
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/get(repos/check-vulnerability-alerts)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            public static var notFound: Self {
                .notFound(.init())
            }
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Operations.ReposCheckVulnerabilityAlerts.Output.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Enable vulnerability alerts
    ///
    /// Enables dependency alerts and the dependency graph for a repository. The authenticated user must have admin access to the repository. For more information, see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `PUT /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/put(repos/enable-vulnerability-alerts)`.
    public enum ReposEnableVulnerabilityAlerts {
        public static let id: Swift.String = "repos/enable-vulnerability-alerts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/PUT/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/PUT/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/PUT/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposEnableVulnerabilityAlerts.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposEnableVulnerabilityAlerts.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/put(repos/enable-vulnerability-alerts)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposEnableVulnerabilityAlerts.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/put(repos/enable-vulnerability-alerts)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposEnableVulnerabilityAlerts.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Disable vulnerability alerts
    ///
    /// Disables dependency alerts and the dependency graph for a repository.
    /// The authenticated user must have admin access to the repository. For more information,
    /// see "[About security alerts for vulnerable dependencies](https://docs.github.com/articles/about-security-alerts-for-vulnerable-dependencies)".
    ///
    /// - Remark: HTTP `DELETE /repos/{owner}/{repo}/vulnerability-alerts`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/delete(repos/disable-vulnerability-alerts)`.
    public enum ReposDisableVulnerabilityAlerts {
        public static let id: Swift.String = "repos/disable-vulnerability-alerts"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/DELETE/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/vulnerability-alerts/DELETE/path/repo`.
                public var repo: Components.Parameters.Repo
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo
                ) {
                    self.owner = owner
                    self.repo = repo
                }
            }
            public var path: Operations.ReposDisableVulnerabilityAlerts.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDisableVulnerabilityAlerts.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/delete(repos/disable-vulnerability-alerts)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDisableVulnerabilityAlerts.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/vulnerability-alerts/delete(repos/disable-vulnerability-alerts)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDisableVulnerabilityAlerts.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Download a repository archive (zip)
    ///
    /// Gets a redirect URL to download a zip archive for a repository. If you omit `:ref`, the repositorys default branch (usually
    /// `main`) will be used. Please make sure your HTTP framework is configured to follow redirects or you will need to use
    /// the `Location` header to make a second `GET` request.
    ///
    /// > [!NOTE]
    /// > For private repositories, these links are temporary and expire after five minutes. If the repository is empty, you will receive a 404 when you follow the redirect.
    ///
    /// - Remark: HTTP `GET /repos/{owner}/{repo}/zipball/{ref}`.
    /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/zipball/{ref}/get(repos/download-zipball-archive)`.
    public enum ReposDownloadZipballArchive {
        public static let id: Swift.String = "repos/download-zipball-archive"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/zipball/{ref}/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/zipball/{ref}/GET/path/owner`.
                public var owner: Components.Parameters.Owner
                /// The name of the repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/zipball/{ref}/GET/path/repo`.
                public var repo: Components.Parameters.Repo
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/zipball/{ref}/GET/path/ref`.
                public var ref: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - owner: The account owner of the repository. The name is not case sensitive.
                ///   - repo: The name of the repository without the `.git` extension. The name is not case sensitive.
                ///   - ref:
                public init(
                    owner: Components.Parameters.Owner,
                    repo: Components.Parameters.Repo,
                    ref: Swift.String
                ) {
                    self.owner = owner
                    self.repo = repo
                    self.ref = ref
                }
            }
            public var path: Operations.ReposDownloadZipballArchive.Input.Path
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            public init(path: Operations.ReposDownloadZipballArchive.Input.Path) {
                self.path = path
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Found: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/zipball/{ref}/GET/responses/302/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{owner}/{repo}/zipball/{ref}/GET/responses/302/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposDownloadZipballArchive.Output.Found.Headers
                /// Creates a new `Found`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                public init(headers: Operations.ReposDownloadZipballArchive.Output.Found.Headers = .init()) {
                    self.headers = headers
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{owner}/{repo}/zipball/{ref}/get(repos/download-zipball-archive)/responses/302`.
            ///
            /// HTTP response code: `302 found`.
            case found(Operations.ReposDownloadZipballArchive.Output.Found)
            /// The associated value of the enum case if `self` is `.found`.
            ///
            /// - Throws: An error if `self` is not `.found`.
            /// - SeeAlso: `.found`.
            public var found: Operations.ReposDownloadZipballArchive.Output.Found {
                get throws {
                    switch self {
                    case let .found(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "found",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
    }
    /// Create a repository using a template
    ///
    /// Creates a new repository using a repository template. Use the `template_owner` and `template_repo` route parameters to specify the repository to use as the template. If the repository is not public, the authenticated user must own or be a member of an organization that owns the repository. To check if a repository is available to use as a template, get the repository's information using the [Get a repository](https://docs.github.com/rest/repos/repos#get-a-repository) endpoint and check that the `is_template` key is `true`.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /repos/{template_owner}/{template_repo}/generate`.
    /// - Remark: Generated from `#/paths//repos/{template_owner}/{template_repo}/generate/post(repos/create-using-template)`.
    public enum ReposCreateUsingTemplate {
        public static let id: Swift.String = "repos/create-using-template"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/path`.
            public struct Path: Sendable, Hashable {
                /// The account owner of the template repository. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/path/template_owner`.
                public var templateOwner: Swift.String
                /// The name of the template repository without the `.git` extension. The name is not case sensitive.
                ///
                /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/path/template_repo`.
                public var templateRepo: Swift.String
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - templateOwner: The account owner of the template repository. The name is not case sensitive.
                ///   - templateRepo: The name of the template repository without the `.git` extension. The name is not case sensitive.
                public init(
                    templateOwner: Swift.String,
                    templateRepo: Swift.String
                ) {
                    self.templateOwner = templateOwner
                    self.templateRepo = templateRepo
                }
            }
            public var path: Operations.ReposCreateUsingTemplate.Input.Path
            /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateUsingTemplate.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateUsingTemplate.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateUsingTemplate.Input.Headers
            /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody/json/owner`.
                    public var owner: Swift.String?
                    /// The name of the new repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody/json/name`.
                    public var name: Swift.String
                    /// A short description of the new repository.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody/json/description`.
                    public var description: Swift.String?
                    /// Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody/json/include_all_branches`.
                    public var includeAllBranches: Swift.Bool?
                    /// Either `true` to create a new private repository or `false` to create a new public one.
                    ///
                    /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody/json/private`.
                    public var _private: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - owner: The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.
                    ///   - name: The name of the new repository.
                    ///   - description: A short description of the new repository.
                    ///   - includeAllBranches: Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.
                    ///   - _private: Either `true` to create a new private repository or `false` to create a new public one.
                    public init(
                        owner: Swift.String? = nil,
                        name: Swift.String,
                        description: Swift.String? = nil,
                        includeAllBranches: Swift.Bool? = nil,
                        _private: Swift.Bool? = nil
                    ) {
                        self.owner = owner
                        self.name = name
                        self.description = description
                        self.includeAllBranches = includeAllBranches
                        self._private = _private
                    }
                    public enum CodingKeys: String, CodingKey {
                        case owner
                        case name
                        case description
                        case includeAllBranches = "include_all_branches"
                        case _private = "private"
                    }
                }
                /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateUsingTemplate.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateUsingTemplate.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            ///   - body:
            public init(
                path: Operations.ReposCreateUsingTemplate.Input.Path,
                headers: Operations.ReposCreateUsingTemplate.Input.Headers = .init(),
                body: Operations.ReposCreateUsingTemplate.Input.Body
            ) {
                self.path = path
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateUsingTemplate.Output.Created.Headers
                /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repos/{template_owner}/{template_repo}/generate/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.FullRepository)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FullRepository {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateUsingTemplate.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateUsingTemplate.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateUsingTemplate.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repos/{template_owner}/{template_repo}/generate/post(repos/create-using-template)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateUsingTemplate.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateUsingTemplate.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List public repositories
    ///
    /// Lists all public repositories in the order that they were created.
    ///
    /// Note:
    /// - For GitHub Enterprise Server, this endpoint will only list repositories available to all users on the enterprise.
    /// - Pagination is powered exclusively by the `since` parameter. Use the [Link header](https://docs.github.com/rest/guides/using-pagination-in-the-rest-api#using-link-headers) to get the URL for the next page of repositories.
    ///
    /// - Remark: HTTP `GET /repositories`.
    /// - Remark: Generated from `#/paths//repositories/get(repos/list-public)`.
    public enum ReposListPublic {
        public static let id: Swift.String = "repos/list-public"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/repositories/GET/query`.
            public struct Query: Sendable, Hashable {
                /// A repository ID. Only return repositories with an ID greater than this ID.
                ///
                /// - Remark: Generated from `#/paths/repositories/GET/query/since`.
                public var since: Components.Parameters.SinceRepo?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - since: A repository ID. Only return repositories with an ID greater than this ID.
                public init(since: Components.Parameters.SinceRepo? = nil) {
                    self.since = since
                }
            }
            public var query: Operations.ReposListPublic.Input.Query
            /// - Remark: Generated from `#/paths/repositories/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListPublic.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListPublic.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListPublic.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.ReposListPublic.Input.Query = .init(),
                headers: Operations.ReposListPublic.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/repositories/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repositories/GET/responses/200/headers/Link`.
                    public var link: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Swift.String? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListPublic.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/repositories/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/repositories/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.MinimalRepository])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.MinimalRepository] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListPublic.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListPublic.Output.Ok.Headers = .init(),
                    body: Operations.ReposListPublic.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//repositories/get(repos/list-public)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListPublic.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListPublic.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//repositories/get(repos/list-public)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//repositories/get(repos/list-public)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//repositories/get(repos/list-public)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repositories for the authenticated user
    ///
    /// Lists repositories that the authenticated user has explicit permission (`:read`, `:write`, or `:admin`) to access.
    ///
    /// The authenticated user has explicit permission to access repositories they own, repositories where they are a collaborator, and repositories that they can access through an organization membership.
    ///
    /// - Remark: HTTP `GET /user/repos`.
    /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)`.
    public enum ReposListForAuthenticatedUser {
        public static let id: Swift.String = "repos/list-for-authenticated-user"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/user/repos/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/user/repos/GET/query/visibility`.
                @frozen public enum VisibilityPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case all = "all"
                    case _public = "public"
                    case _private = "private"
                }
                /// Limit results to repositories with the specified visibility.
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/visibility`.
                public var visibility: Operations.ReposListForAuthenticatedUser.Input.Query.VisibilityPayload?
                /// Comma-separated list of values. Can include:  
                ///  * `owner`: Repositories that are owned by the authenticated user.  
                ///  * `collaborator`: Repositories that the user has been added to as a collaborator.  
                ///  * `organization_member`: Repositories that the user has access to through being a member of an organization. This includes every repository on every team that the user is on.
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/affiliation`.
                public var affiliation: Swift.String?
                /// - Remark: Generated from `#/paths/user/repos/GET/query/type`.
                @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case all = "all"
                    case owner = "owner"
                    case _public = "public"
                    case _private = "private"
                    case member = "member"
                }
                /// Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/type`.
                public var _type: Operations.ReposListForAuthenticatedUser.Input.Query._TypePayload?
                /// - Remark: Generated from `#/paths/user/repos/GET/query/sort`.
                @frozen public enum SortPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case created = "created"
                    case updated = "updated"
                    case pushed = "pushed"
                    case fullName = "full_name"
                }
                /// The property to sort the results by.
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/sort`.
                public var sort: Operations.ReposListForAuthenticatedUser.Input.Query.SortPayload?
                /// - Remark: Generated from `#/paths/user/repos/GET/query/direction`.
                @frozen public enum DirectionPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case asc = "asc"
                    case desc = "desc"
                }
                /// The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/direction`.
                public var direction: Operations.ReposListForAuthenticatedUser.Input.Query.DirectionPayload?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/since`.
                public var since: Components.Parameters.SinceRepoDate?
                /// Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
                ///
                /// - Remark: Generated from `#/paths/user/repos/GET/query/before`.
                public var before: Components.Parameters.BeforeRepoDate?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - visibility: Limit results to repositories with the specified visibility.
                ///   - affiliation: Comma-separated list of values. Can include:  
                ///   - _type: Limit results to repositories of the specified type. Will cause a `422` error if used in the same request as **visibility** or **affiliation**.
                ///   - sort: The property to sort the results by.
                ///   - direction: The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - since: Only show repositories updated after the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
                ///   - before: Only show repositories updated before the given time. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.
                public init(
                    visibility: Operations.ReposListForAuthenticatedUser.Input.Query.VisibilityPayload? = nil,
                    affiliation: Swift.String? = nil,
                    _type: Operations.ReposListForAuthenticatedUser.Input.Query._TypePayload? = nil,
                    sort: Operations.ReposListForAuthenticatedUser.Input.Query.SortPayload? = nil,
                    direction: Operations.ReposListForAuthenticatedUser.Input.Query.DirectionPayload? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil,
                    since: Components.Parameters.SinceRepoDate? = nil,
                    before: Components.Parameters.BeforeRepoDate? = nil
                ) {
                    self.visibility = visibility
                    self.affiliation = affiliation
                    self._type = _type
                    self.sort = sort
                    self.direction = direction
                    self.perPage = perPage
                    self.page = page
                    self.since = since
                    self.before = before
                }
            }
            public var query: Operations.ReposListForAuthenticatedUser.Input.Query
            /// - Remark: Generated from `#/paths/user/repos/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForAuthenticatedUser.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForAuthenticatedUser.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListForAuthenticatedUser.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.ReposListForAuthenticatedUser.Input.Query = .init(),
                headers: Operations.ReposListForAuthenticatedUser.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/user/repos/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/user/repos/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListForAuthenticatedUser.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/user/repos/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/user/repos/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.Repository])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.Repository] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListForAuthenticatedUser.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListForAuthenticatedUser.Output.Ok.Headers = .init(),
                    body: Operations.ReposListForAuthenticatedUser.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListForAuthenticatedUser.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListForAuthenticatedUser.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Requires authentication
            ///
            /// - Remark: Generated from `#/paths//user/repos/get(repos/list-for-authenticated-user)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.RequiresAuthentication)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.RequiresAuthentication {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Create a repository for the authenticated user
    ///
    /// Creates a new repository for the authenticated user.
    ///
    /// OAuth app tokens and personal access tokens (classic) need the `public_repo` or `repo` scope to create a public repository, and `repo` scope to create a private repository.
    ///
    /// - Remark: HTTP `POST /user/repos`.
    /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)`.
    public enum ReposCreateForAuthenticatedUser {
        public static let id: Swift.String = "repos/create-for-authenticated-user"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/user/repos/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateForAuthenticatedUser.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposCreateForAuthenticatedUser.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposCreateForAuthenticatedUser.Input.Headers
            /// - Remark: Generated from `#/paths/user/repos/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json`.
                public struct JsonPayload: Codable, Hashable, Sendable {
                    /// The name of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/name`.
                    public var name: Swift.String
                    /// A short description of the repository.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/description`.
                    public var description: Swift.String?
                    /// A URL with more information about the repository.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/homepage`.
                    public var homepage: Swift.String?
                    /// Whether the repository is private.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/private`.
                    public var _private: Swift.Bool?
                    /// Whether issues are enabled.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/has_issues`.
                    public var hasIssues: Swift.Bool?
                    /// Whether projects are enabled.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/has_projects`.
                    public var hasProjects: Swift.Bool?
                    /// Whether the wiki is enabled.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/has_wiki`.
                    public var hasWiki: Swift.Bool?
                    /// Whether discussions are enabled.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/has_discussions`.
                    public var hasDiscussions: Swift.Bool?
                    /// The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/team_id`.
                    public var teamId: Swift.Int?
                    /// Whether the repository is initialized with a minimal README.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/auto_init`.
                    public var autoInit: Swift.Bool?
                    /// The desired language or platform to apply to the .gitignore.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/gitignore_template`.
                    public var gitignoreTemplate: Swift.String?
                    /// The license keyword of the open source license for this repository.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/license_template`.
                    public var licenseTemplate: Swift.String?
                    /// Whether to allow squash merges for pull requests.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/allow_squash_merge`.
                    public var allowSquashMerge: Swift.Bool?
                    /// Whether to allow merge commits for pull requests.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/allow_merge_commit`.
                    public var allowMergeCommit: Swift.Bool?
                    /// Whether to allow rebase merges for pull requests.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/allow_rebase_merge`.
                    public var allowRebaseMerge: Swift.Bool?
                    /// Whether to allow Auto-merge to be used on pull requests.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/allow_auto_merge`.
                    public var allowAutoMerge: Swift.Bool?
                    /// Whether to delete head branches when pull requests are merged
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/delete_branch_on_merge`.
                    public var deleteBranchOnMerge: Swift.Bool?
                    /// Required when using `squash_merge_commit_message`.
                    ///
                    /// The default value for a squash merge commit title:
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/squash_merge_commit_title`.
                    @frozen public enum SquashMergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prTitle = "PR_TITLE"
                        case commitOrPrTitle = "COMMIT_OR_PR_TITLE"
                    }
                    /// Required when using `squash_merge_commit_message`.
                    ///
                    /// The default value for a squash merge commit title:
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit).
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/squash_merge_commit_title`.
                    public var squashMergeCommitTitle: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.SquashMergeCommitTitlePayload?
                    /// The default value for a squash merge commit message:
                    ///
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/squash_merge_commit_message`.
                    @frozen public enum SquashMergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prBody = "PR_BODY"
                        case commitMessages = "COMMIT_MESSAGES"
                        case blank = "BLANK"
                    }
                    /// The default value for a squash merge commit message:
                    ///
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `COMMIT_MESSAGES` - default to the branch's commit messages.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/squash_merge_commit_message`.
                    public var squashMergeCommitMessage: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.SquashMergeCommitMessagePayload?
                    /// Required when using `merge_commit_message`.
                    ///
                    /// The default value for a merge commit title.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/merge_commit_title`.
                    @frozen public enum MergeCommitTitlePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prTitle = "PR_TITLE"
                        case mergeMessage = "MERGE_MESSAGE"
                    }
                    /// Required when using `merge_commit_message`.
                    ///
                    /// The default value for a merge commit title.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name).
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/merge_commit_title`.
                    public var mergeCommitTitle: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.MergeCommitTitlePayload?
                    /// The default value for a merge commit message.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/merge_commit_message`.
                    @frozen public enum MergeCommitMessagePayload: String, Codable, Hashable, Sendable, CaseIterable {
                        case prBody = "PR_BODY"
                        case prTitle = "PR_TITLE"
                        case blank = "BLANK"
                    }
                    /// The default value for a merge commit message.
                    ///
                    /// - `PR_TITLE` - default to the pull request's title.
                    /// - `PR_BODY` - default to the pull request's body.
                    /// - `BLANK` - default to a blank commit message.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/merge_commit_message`.
                    public var mergeCommitMessage: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.MergeCommitMessagePayload?
                    /// Whether downloads are enabled.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/has_downloads`.
                    public var hasDownloads: Swift.Bool?
                    /// Whether this repository acts as a template that can be used to generate new repositories.
                    ///
                    /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/json/is_template`.
                    public var isTemplate: Swift.Bool?
                    /// Creates a new `JsonPayload`.
                    ///
                    /// - Parameters:
                    ///   - name: The name of the repository.
                    ///   - description: A short description of the repository.
                    ///   - homepage: A URL with more information about the repository.
                    ///   - _private: Whether the repository is private.
                    ///   - hasIssues: Whether issues are enabled.
                    ///   - hasProjects: Whether projects are enabled.
                    ///   - hasWiki: Whether the wiki is enabled.
                    ///   - hasDiscussions: Whether discussions are enabled.
                    ///   - teamId: The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.
                    ///   - autoInit: Whether the repository is initialized with a minimal README.
                    ///   - gitignoreTemplate: The desired language or platform to apply to the .gitignore.
                    ///   - licenseTemplate: The license keyword of the open source license for this repository.
                    ///   - allowSquashMerge: Whether to allow squash merges for pull requests.
                    ///   - allowMergeCommit: Whether to allow merge commits for pull requests.
                    ///   - allowRebaseMerge: Whether to allow rebase merges for pull requests.
                    ///   - allowAutoMerge: Whether to allow Auto-merge to be used on pull requests.
                    ///   - deleteBranchOnMerge: Whether to delete head branches when pull requests are merged
                    ///   - squashMergeCommitTitle: Required when using `squash_merge_commit_message`.
                    ///   - squashMergeCommitMessage: The default value for a squash merge commit message:
                    ///   - mergeCommitTitle: Required when using `merge_commit_message`.
                    ///   - mergeCommitMessage: The default value for a merge commit message.
                    ///   - hasDownloads: Whether downloads are enabled.
                    ///   - isTemplate: Whether this repository acts as a template that can be used to generate new repositories.
                    public init(
                        name: Swift.String,
                        description: Swift.String? = nil,
                        homepage: Swift.String? = nil,
                        _private: Swift.Bool? = nil,
                        hasIssues: Swift.Bool? = nil,
                        hasProjects: Swift.Bool? = nil,
                        hasWiki: Swift.Bool? = nil,
                        hasDiscussions: Swift.Bool? = nil,
                        teamId: Swift.Int? = nil,
                        autoInit: Swift.Bool? = nil,
                        gitignoreTemplate: Swift.String? = nil,
                        licenseTemplate: Swift.String? = nil,
                        allowSquashMerge: Swift.Bool? = nil,
                        allowMergeCommit: Swift.Bool? = nil,
                        allowRebaseMerge: Swift.Bool? = nil,
                        allowAutoMerge: Swift.Bool? = nil,
                        deleteBranchOnMerge: Swift.Bool? = nil,
                        squashMergeCommitTitle: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.SquashMergeCommitTitlePayload? = nil,
                        squashMergeCommitMessage: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.SquashMergeCommitMessagePayload? = nil,
                        mergeCommitTitle: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.MergeCommitTitlePayload? = nil,
                        mergeCommitMessage: Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload.MergeCommitMessagePayload? = nil,
                        hasDownloads: Swift.Bool? = nil,
                        isTemplate: Swift.Bool? = nil
                    ) {
                        self.name = name
                        self.description = description
                        self.homepage = homepage
                        self._private = _private
                        self.hasIssues = hasIssues
                        self.hasProjects = hasProjects
                        self.hasWiki = hasWiki
                        self.hasDiscussions = hasDiscussions
                        self.teamId = teamId
                        self.autoInit = autoInit
                        self.gitignoreTemplate = gitignoreTemplate
                        self.licenseTemplate = licenseTemplate
                        self.allowSquashMerge = allowSquashMerge
                        self.allowMergeCommit = allowMergeCommit
                        self.allowRebaseMerge = allowRebaseMerge
                        self.allowAutoMerge = allowAutoMerge
                        self.deleteBranchOnMerge = deleteBranchOnMerge
                        self.squashMergeCommitTitle = squashMergeCommitTitle
                        self.squashMergeCommitMessage = squashMergeCommitMessage
                        self.mergeCommitTitle = mergeCommitTitle
                        self.mergeCommitMessage = mergeCommitMessage
                        self.hasDownloads = hasDownloads
                        self.isTemplate = isTemplate
                    }
                    public enum CodingKeys: String, CodingKey {
                        case name
                        case description
                        case homepage
                        case _private = "private"
                        case hasIssues = "has_issues"
                        case hasProjects = "has_projects"
                        case hasWiki = "has_wiki"
                        case hasDiscussions = "has_discussions"
                        case teamId = "team_id"
                        case autoInit = "auto_init"
                        case gitignoreTemplate = "gitignore_template"
                        case licenseTemplate = "license_template"
                        case allowSquashMerge = "allow_squash_merge"
                        case allowMergeCommit = "allow_merge_commit"
                        case allowRebaseMerge = "allow_rebase_merge"
                        case allowAutoMerge = "allow_auto_merge"
                        case deleteBranchOnMerge = "delete_branch_on_merge"
                        case squashMergeCommitTitle = "squash_merge_commit_title"
                        case squashMergeCommitMessage = "squash_merge_commit_message"
                        case mergeCommitTitle = "merge_commit_title"
                        case mergeCommitMessage = "merge_commit_message"
                        case hasDownloads = "has_downloads"
                        case isTemplate = "is_template"
                    }
                }
                /// - Remark: Generated from `#/paths/user/repos/POST/requestBody/content/application\/json`.
                case json(Operations.ReposCreateForAuthenticatedUser.Input.Body.JsonPayload)
            }
            public var body: Operations.ReposCreateForAuthenticatedUser.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - headers:
            ///   - body:
            public init(
                headers: Operations.ReposCreateForAuthenticatedUser.Input.Headers = .init(),
                body: Operations.ReposCreateForAuthenticatedUser.Input.Body
            ) {
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Created: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/user/repos/POST/responses/201/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/user/repos/POST/responses/201/headers/Location`.
                    public var location: Swift.String?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - location:
                    public init(location: Swift.String? = nil) {
                        self.location = location
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposCreateForAuthenticatedUser.Output.Created.Headers
                /// - Remark: Generated from `#/paths/user/repos/POST/responses/201/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/user/repos/POST/responses/201/content/application\/json`.
                    case json(Components.Schemas.FullRepository)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.FullRepository {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposCreateForAuthenticatedUser.Output.Created.Body
                /// Creates a new `Created`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposCreateForAuthenticatedUser.Output.Created.Headers = .init(),
                    body: Operations.ReposCreateForAuthenticatedUser.Output.Created.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/201`.
            ///
            /// HTTP response code: `201 created`.
            case created(Operations.ReposCreateForAuthenticatedUser.Output.Created)
            /// The associated value of the enum case if `self` is `.created`.
            ///
            /// - Throws: An error if `self` is not `.created`.
            /// - SeeAlso: `.created`.
            public var created: Operations.ReposCreateForAuthenticatedUser.Output.Created {
                get throws {
                    switch self {
                    case let .created(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "created",
                            response: self
                        )
                    }
                }
            }
            /// Requires authentication
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.RequiresAuthentication)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.RequiresAuthentication {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Validation failed, or the endpoint has been spammed.
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Components.Responses.ValidationFailed)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Components.Responses.ValidationFailed {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Bad Request
            ///
            /// - Remark: Generated from `#/paths//user/repos/post(repos/create-for-authenticated-user)/responses/400`.
            ///
            /// HTTP response code: `400 badRequest`.
            case badRequest(Components.Responses.BadRequest)
            /// The associated value of the enum case if `self` is `.badRequest`.
            ///
            /// - Throws: An error if `self` is not `.badRequest`.
            /// - SeeAlso: `.badRequest`.
            public var badRequest: Components.Responses.BadRequest {
                get throws {
                    switch self {
                    case let .badRequest(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "badRequest",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case applicationScimJson
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                case "application/scim+json":
                    self = .applicationScimJson
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                case .applicationScimJson:
                    return "application/scim+json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json,
                    .applicationScimJson
                ]
            }
        }
    }
    /// List repository invitations for the authenticated user
    ///
    /// When authenticating as a user, this endpoint will list all currently open repository invitations for that user.
    ///
    /// - Remark: HTTP `GET /user/repository_invitations`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)`.
    public enum ReposListInvitationsForAuthenticatedUser {
        public static let id: Swift.String = "repos/list-invitations-for-authenticated-user"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/user/repository_invitations/GET/query`.
            public struct Query: Sendable, Hashable {
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/user/repository_invitations/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/user/repository_invitations/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListInvitationsForAuthenticatedUser.Input.Query
            /// - Remark: Generated from `#/paths/user/repository_invitations/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListInvitationsForAuthenticatedUser.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListInvitationsForAuthenticatedUser.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListInvitationsForAuthenticatedUser.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            public init(
                query: Operations.ReposListInvitationsForAuthenticatedUser.Input.Query = .init(),
                headers: Operations.ReposListInvitationsForAuthenticatedUser.Input.Headers = .init()
            ) {
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/user/repository_invitations/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/user/repository_invitations/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListInvitationsForAuthenticatedUser.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/user/repository_invitations/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/user/repository_invitations/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.RepositoryInvitation])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.RepositoryInvitation] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListInvitationsForAuthenticatedUser.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListInvitationsForAuthenticatedUser.Output.Ok.Headers = .init(),
                    body: Operations.ReposListInvitationsForAuthenticatedUser.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListInvitationsForAuthenticatedUser.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListInvitationsForAuthenticatedUser.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Requires authentication
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/get(repos/list-invitations-for-authenticated-user)/responses/401`.
            ///
            /// HTTP response code: `401 unauthorized`.
            case unauthorized(Components.Responses.RequiresAuthentication)
            /// The associated value of the enum case if `self` is `.unauthorized`.
            ///
            /// - Throws: An error if `self` is not `.unauthorized`.
            /// - SeeAlso: `.unauthorized`.
            public var unauthorized: Components.Responses.RequiresAuthentication {
                get throws {
                    switch self {
                    case let .unauthorized(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unauthorized",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Accept a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `PATCH /user/repository_invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)`.
    public enum ReposAcceptInvitationForAuthenticatedUser {
        public static let id: Swift.String = "repos/accept-invitation-for-authenticated-user"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/user/repository_invitations/{invitation_id}/PATCH/path`.
            public struct Path: Sendable, Hashable {
                /// The unique identifier of the invitation.
                ///
                /// - Remark: Generated from `#/paths/user/repository_invitations/{invitation_id}/PATCH/path/invitation_id`.
                public var invitationId: Components.Parameters.InvitationId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - invitationId: The unique identifier of the invitation.
                public init(invitationId: Components.Parameters.InvitationId) {
                    self.invitationId = invitationId
                }
            }
            public var path: Operations.ReposAcceptInvitationForAuthenticatedUser.Input.Path
            /// - Remark: Generated from `#/paths/user/repository_invitations/{invitation_id}/PATCH/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAcceptInvitationForAuthenticatedUser.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposAcceptInvitationForAuthenticatedUser.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposAcceptInvitationForAuthenticatedUser.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposAcceptInvitationForAuthenticatedUser.Input.Path,
                headers: Operations.ReposAcceptInvitationForAuthenticatedUser.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposAcceptInvitationForAuthenticatedUser.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposAcceptInvitationForAuthenticatedUser.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/patch(repos/accept-invitation-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// Decline a repository invitation
    ///
    ///
    ///
    /// - Remark: HTTP `DELETE /user/repository_invitations/{invitation_id}`.
    /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)`.
    public enum ReposDeclineInvitationForAuthenticatedUser {
        public static let id: Swift.String = "repos/decline-invitation-for-authenticated-user"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/user/repository_invitations/{invitation_id}/DELETE/path`.
            public struct Path: Sendable, Hashable {
                /// The unique identifier of the invitation.
                ///
                /// - Remark: Generated from `#/paths/user/repository_invitations/{invitation_id}/DELETE/path/invitation_id`.
                public var invitationId: Components.Parameters.InvitationId
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - invitationId: The unique identifier of the invitation.
                public init(invitationId: Components.Parameters.InvitationId) {
                    self.invitationId = invitationId
                }
            }
            public var path: Operations.ReposDeclineInvitationForAuthenticatedUser.Input.Path
            /// - Remark: Generated from `#/paths/user/repository_invitations/{invitation_id}/DELETE/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeclineInvitationForAuthenticatedUser.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposDeclineInvitationForAuthenticatedUser.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposDeclineInvitationForAuthenticatedUser.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - headers:
            public init(
                path: Operations.ReposDeclineInvitationForAuthenticatedUser.Input.Path,
                headers: Operations.ReposDeclineInvitationForAuthenticatedUser.Input.Headers = .init()
            ) {
                self.path = path
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct NoContent: Sendable, Hashable {
                /// Creates a new `NoContent`.
                public init() {}
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            case noContent(Operations.ReposDeclineInvitationForAuthenticatedUser.Output.NoContent)
            /// Response
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)/responses/204`.
            ///
            /// HTTP response code: `204 noContent`.
            public static var noContent: Self {
                .noContent(.init())
            }
            /// The associated value of the enum case if `self` is `.noContent`.
            ///
            /// - Throws: An error if `self` is not `.noContent`.
            /// - SeeAlso: `.noContent`.
            public var noContent: Operations.ReposDeclineInvitationForAuthenticatedUser.Output.NoContent {
                get throws {
                    switch self {
                    case let .noContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "noContent",
                            response: self
                        )
                    }
                }
            }
            /// Conflict
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)/responses/409`.
            ///
            /// HTTP response code: `409 conflict`.
            case conflict(Components.Responses.Conflict)
            /// The associated value of the enum case if `self` is `.conflict`.
            ///
            /// - Throws: An error if `self` is not `.conflict`.
            /// - SeeAlso: `.conflict`.
            public var conflict: Components.Responses.Conflict {
                get throws {
                    switch self {
                    case let .conflict(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "conflict",
                            response: self
                        )
                    }
                }
            }
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            case notModified(Components.Responses.NotModified)
            /// Not modified
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)/responses/304`.
            ///
            /// HTTP response code: `304 notModified`.
            public static var notModified: Self {
                .notModified(.init())
            }
            /// The associated value of the enum case if `self` is `.notModified`.
            ///
            /// - Throws: An error if `self` is not `.notModified`.
            /// - SeeAlso: `.notModified`.
            public var notModified: Components.Responses.NotModified {
                get throws {
                    switch self {
                    case let .notModified(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notModified",
                            response: self
                        )
                    }
                }
            }
            /// Resource not found
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)/responses/404`.
            ///
            /// HTTP response code: `404 notFound`.
            case notFound(Components.Responses.NotFound)
            /// The associated value of the enum case if `self` is `.notFound`.
            ///
            /// - Throws: An error if `self` is not `.notFound`.
            /// - SeeAlso: `.notFound`.
            public var notFound: Components.Responses.NotFound {
                get throws {
                    switch self {
                    case let .notFound(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "notFound",
                            response: self
                        )
                    }
                }
            }
            /// Forbidden
            ///
            /// - Remark: Generated from `#/paths//user/repository_invitations/{invitation_id}/delete(repos/decline-invitation-for-authenticated-user)/responses/403`.
            ///
            /// HTTP response code: `403 forbidden`.
            case forbidden(Components.Responses.Forbidden)
            /// The associated value of the enum case if `self` is `.forbidden`.
            ///
            /// - Throws: An error if `self` is not `.forbidden`.
            /// - SeeAlso: `.forbidden`.
            public var forbidden: Components.Responses.Forbidden {
                get throws {
                    switch self {
                    case let .forbidden(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "forbidden",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
    /// List repositories for a user
    ///
    /// Lists public repositories for the specified user.
    ///
    /// - Remark: HTTP `GET /users/{username}/repos`.
    /// - Remark: Generated from `#/paths//users/{username}/repos/get(repos/list-for-user)`.
    public enum ReposListForUser {
        public static let id: Swift.String = "repos/list-for-user"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/users/{username}/repos/GET/path`.
            public struct Path: Sendable, Hashable {
                /// The handle for the GitHub user account.
                ///
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/path/username`.
                public var username: Components.Parameters.Username
                /// Creates a new `Path`.
                ///
                /// - Parameters:
                ///   - username: The handle for the GitHub user account.
                public init(username: Components.Parameters.Username) {
                    self.username = username
                }
            }
            public var path: Operations.ReposListForUser.Input.Path
            /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query`.
            public struct Query: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/type`.
                @frozen public enum _TypePayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case all = "all"
                    case owner = "owner"
                    case member = "member"
                }
                /// Limit results to repositories of the specified type.
                ///
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/type`.
                public var _type: Operations.ReposListForUser.Input.Query._TypePayload?
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/sort`.
                @frozen public enum SortPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case created = "created"
                    case updated = "updated"
                    case pushed = "pushed"
                    case fullName = "full_name"
                }
                /// The property to sort the results by.
                ///
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/sort`.
                public var sort: Operations.ReposListForUser.Input.Query.SortPayload?
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/direction`.
                @frozen public enum DirectionPayload: String, Codable, Hashable, Sendable, CaseIterable {
                    case asc = "asc"
                    case desc = "desc"
                }
                /// The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
                ///
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/direction`.
                public var direction: Operations.ReposListForUser.Input.Query.DirectionPayload?
                /// The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/per_page`.
                public var perPage: Components.Parameters.PerPage?
                /// The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/query/page`.
                public var page: Components.Parameters.Page?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - _type: Limit results to repositories of the specified type.
                ///   - sort: The property to sort the results by.
                ///   - direction: The order to sort by. Default: `asc` when using `full_name`, otherwise `desc`.
                ///   - perPage: The number of results per page (max 100). For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                ///   - page: The page number of the results to fetch. For more information, see "[Using pagination in the REST API](https://docs.github.com/rest/using-the-rest-api/using-pagination-in-the-rest-api)."
                public init(
                    _type: Operations.ReposListForUser.Input.Query._TypePayload? = nil,
                    sort: Operations.ReposListForUser.Input.Query.SortPayload? = nil,
                    direction: Operations.ReposListForUser.Input.Query.DirectionPayload? = nil,
                    perPage: Components.Parameters.PerPage? = nil,
                    page: Components.Parameters.Page? = nil
                ) {
                    self._type = _type
                    self.sort = sort
                    self.direction = direction
                    self.perPage = perPage
                    self.page = page
                }
            }
            public var query: Operations.ReposListForUser.Input.Query
            /// - Remark: Generated from `#/paths/users/{username}/repos/GET/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForUser.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.ReposListForUser.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.ReposListForUser.Input.Headers
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - path:
            ///   - query:
            ///   - headers:
            public init(
                path: Operations.ReposListForUser.Input.Path,
                query: Operations.ReposListForUser.Input.Query = .init(),
                headers: Operations.ReposListForUser.Input.Headers = .init()
            ) {
                self.path = path
                self.query = query
                self.headers = headers
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/responses/200/headers`.
                public struct Headers: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/users/{username}/repos/GET/responses/200/headers/Link`.
                    public var link: Components.Headers.Link?
                    /// Creates a new `Headers`.
                    ///
                    /// - Parameters:
                    ///   - link:
                    public init(link: Components.Headers.Link? = nil) {
                        self.link = link
                    }
                }
                /// Received HTTP response headers
                public var headers: Operations.ReposListForUser.Output.Ok.Headers
                /// - Remark: Generated from `#/paths/users/{username}/repos/GET/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/users/{username}/repos/GET/responses/200/content/application\/json`.
                    case json([Components.Schemas.MinimalRepository])
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: [Components.Schemas.MinimalRepository] {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.ReposListForUser.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - headers: Received HTTP response headers
                ///   - body: Received HTTP response body
                public init(
                    headers: Operations.ReposListForUser.Output.Ok.Headers = .init(),
                    body: Operations.ReposListForUser.Output.Ok.Body
                ) {
                    self.headers = headers
                    self.body = body
                }
            }
            /// Response
            ///
            /// - Remark: Generated from `#/paths//users/{username}/repos/get(repos/list-for-user)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.ReposListForUser.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.ReposListForUser.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
}
